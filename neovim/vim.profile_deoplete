SCRIPT  /Users/stevezhang/.config/nvim/init.vim
Sourced 1 time
Total time:   0.028212
 Self time:   0.013350

count  total (s)   self (s)
                            " Use vim-plug to manage plugins
                            " Use the following command to profile the startup of vim/neovim
                            "     vim --cmd 'profile start vim.profile' --cmd 'profile func *' --cmd 'profile file *'
    1   0.002607   0.000094 call plug#begin('~/.local/share/nvim/plugged')
    1              0.000148     Plug 'flazz/vim-colorschemes'
    1              0.000197     Plug 'sirver/ultisnips' | Plug 'honza/vim-snippets'
    1              0.000092     Plug 'tpope/vim-surround'
    1              0.000090     Plug 'kien/ctrlp.vim'
    1              0.000091     Plug 'salsifis/vim-transpose'
    1              0.000088     Plug 'jiangmiao/auto-pairs'
    1              0.000092     Plug 'ervandew/supertab'
    1              0.000089     Plug 'Yggdroot/indentLine'
    1              0.000085     Plug 'godlygeek/tabular'
    1              0.000086     Plug 'majutsushi/tagbar'
    1              0.000089     Plug 'itchyny/lightline.vim'
    1              0.000088     Plug 'scrooloose/nerdtree'
    1              0.000218     Plug 'neomake/neomake'
    1              0.000119     Plug 'tpope/vim-sensible'
    1              0.000099     Plug 'tpope/vim-fugitive'
    1              0.000093     Plug 'tpope/vim-commentary'
    1              0.000137     Plug 'airblade/vim-gitgutter'
    1              0.000131     Plug 'raimondi/delimitmate'
                            "   Comment YCM due to slow startup ~430ms
                            "    Plug 'valloric/youcompleteme'
                            "   Use deoplete instead
    1              0.000003     if has('nvim')
    1              0.000129       Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
    1              0.000001     else
                                  Plug 'Shougo/deoplete.nvim'
                                  Plug 'roxma/nvim-yarp'
                                  Plug 'roxma/vim-hug-neovim-rpc'
                                endif
    1              0.000002     let g:deoplete#enable_at_startup = 1
    1   0.009477   0.000009 call plug#end()
                            
    1              0.000002 let mapleader=","
                            "选择colorscheme
                            "colorscheme wombat256mod
    1   0.002945   0.000063 colorscheme molokai
                            " Very important to fix the slow scroll!
    1              0.000003 set lazyredraw
                            
                            " platform-dependent settings
    1              0.000002 if has("unix")
    1              0.010664     let s:uname = system("uname")
                                " macOS
    1              0.000008     if s:uname == "Darwin\n"
    1              0.000003         let g:python_host_prog = "/usr/local/bin/python2"
    1              0.000004         let g:python3_host_prog = "/usr/local/bin/python3"
    1              0.000001     endif
    1              0.000001 endif
                            
                            " 安装所需插件
                            ""Plugin 'wincent/command-t'
                            """" syntax related
                            """Plugin 'octol/vim-cpp-enhanced-highlight'
                            """" Snippets related
                            " deoplete
                            
                            
                            " ==== UltiSnips ====
    1              0.000018 set runtimepath+=~/code/snippets
    1              0.000002 let g:UltiSnipsSnippetsDir = '~/code/snippets/UltiSnips'
    1              0.000001 let g:UltiSnipsEditSplit = 'vertical'
    1              0.000002 let g:UltiSnipsUsePythonVersion=3
                            " better key bindings for UltiSnipsExpandTrigger
    1              0.000001 let g:UltiSnipsExpandTrigger = "<tab>"
    1              0.000004 let g:UltiSnipsJumpForardTrigger = "<tab>"
    1              0.000002 let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
                            " if trigger not working, add these lines
                            " make YCM compatible with UltiSnips (using supertab)
    1              0.000006 let g:ycm_key_list_select_completion = ['<C-n>','<Down>']
    1              0.000003 let g:ycm_key_list_previous_completion = ['<C-p>','<Up>']
    1              0.000002 let g:SuperTabDefaultCompletionType = '<C-n>'
                            
                            " ==== NEOMAKE ====
    1              0.000001 let g:neomake_serialize = 1
    1              0.000002 let g:neomake_serialize_abort_on_error = 1
    1              0.000002 function! MyOnBattery()
                            "pmset -g batt | awk '/charg/ {print $4}'
                            "  return readfile('/sys/class/power_supply/AC/online') == ['0']
                            endfunction
                            
                            "if MyOnBattery()
                            "  call neomake#configure#automake('w')
                            "else
                            "  call neomake#configure#automake('nw', 1000)
                            "endif
                            
                            " ==== YCM ====
    1              0.000008 set completeopt=longest,menu
    1              0.000002 let g:ycm_min_num_of_chars_for_completion=2
    1              0.000001 let g:ycm_cache_omnifunc=0
    1              0.000002 let g:ycm_seed_identifiers_with_syntax=1
    1              0.000001 let g:ycm_complete_in_comments = 1
    1              0.000001 let g:ycm_complete_in_strings = 1
                            "let g:ycm_collect_identifiers_from_comments_and_strings = 0
    1              0.000002 let g:ycm_global_ycm_extra_conf = '~/.config/nvim/.ycm_extra_conf.py'
    1              0.000002 let g:ycm_server_python_interpreter = '/usr/local/bin/python3'
                            
                            " ==== NerdTree ====
    1              0.000002 let NERDTreeChDirMode=1
    1              0.000001 let NERDTreeShowBookmarks=1
    1              0.000001 let NERDTreeWinSize=25
    1              0.000005 let NERDTreeShowHidden=1
    1              0.000003 let NERDTreeIgnore=['\~$', '\.pyc$', '\.swp$', '\.git$','\.o','\.mod']
    1              0.000001 let NERDTreeQuitOnOpen=1
                            
                            " ==== Tabular ====
                            " align : in normal and visual mode
                            " by using a= to align equal mark
    1              0.000021 nmap <Leader>a= :Tabularize /=<CR>
    1              0.000005 vmap <Leader>a= :Tabularize /=<CR>
                            " by using a: to align after colon mark
    1              0.000004 nmap <Leader>a: :Tabularize /:\zs<CR>
    1              0.000004 vmap <Leader>a: :Tabularize /:\zs<CR>
                            " by using a\, (escape) to align comma mark
    1              0.000003 nmap <Leader>a\, :Tabularize /,<CR>
    1              0.000003 vmap <Leader>a\, :Tabularize /,<CR>
                            
                            " ==== Plugin indentLine settings. ====
    1              0.000002 let g:indentLine_char = "┆"
    1              0.000001 let g:indentLine_enabled = 1
    1              0.000002 let g:autopep8_disable_show_diff=1
                            
    1              0.000010 set nu
    1              0.000002 set rnu
    1              0.000005 set so=3
                            " 设置语法检测
                            " TAB键长度在indent文件夹中，以适用不同类型文件
    1              0.000003 set smarttab
    1              0.000004 set tabstop=8
                            " 自动缩进
    1              0.000006 set ai
                            " 智慧缩进
    1              0.000002 set si
    1              0.000005 set wrap
                            
                            " 设置unix文件格式
                            "set fileformat=uinix
                            
                            "去除错误时发出的杂音
                            "set noerrorbells
                            "set novisualbell
                            "set t_vb=
                            "set tm=500
                            "语法高亮
                            "syntax on
                            " always show the status line
                            "set laststatus=2
                            
                            " 忽略编译文件
    1              0.000002 set wildignore=*.o,*~,*.pyc,*.mod
                            
    1              0.000001 set shell=/bin/bash
                            
                            "set ruler                       " 显示标尺  
                            "autocmd InsertEnter * se cul    " 用浅色高亮当前行  
                            "打开文件类型检测, 加了这句才可以用智能补全
                            "set completeopt=longest,menu
                            "set foldmethod=syntax
                            
                            " Disable arrows
                            " habbit destroying
    1              0.000003 noremap <Up> <NOP>
    1              0.000003 noremap <Down> <NOP>
    1              0.000005 noremap <Left> <NOP>
    1              0.000003 noremap <Right> <NOP>
                            
                            " 寄存器复制粘贴
    1              0.000003 noremap <Leader>y "*y
    1              0.000003 noremap <Leader>p "*p
    1              0.000003 noremap <Leader>Y "+y
    1              0.000003 noremap <Leader>P "+p
                            
                            " 普通模式下，方向键改为切换窗口
    1              0.000003 noremap <Up>    <C-w>k
    1              0.000003 noremap <Down>  <C-w>j
    1              0.000002 noremap <Left>  <C-w>h
    1              0.000003 noremap <Right> <C-w>l
                            
                            " 普通模式下，用tab键导航标签页切换
    1              0.000002 noremap <tab> gt
    1              0.000003 noremap <s-tab> gT
                            
                            " 映射ESC
    1              0.000002 imap fj <esc>
    1              0.000002 vmap fj <esc>
                            
                            " 命令模式启动
    1              0.000002 nnoremap : ;
    1              0.000002 nnoremap ; :
                            
                            " 命令模式下，映射到:lclose以关闭编译结果
    1              0.000003 nnoremap nm :lclose<CR>
    1              0.000002 nnoremap mn :lclose<CR>
                            
                            " ===========
                            " Header part
                            " ===========
    1              0.000003 function HeaderPython()
                                call setline(1, "#!/usr/bin/env python")
                                call append(1, "# -*- coding: utf-8 -*-")
                                normal G
                                normal o
                            endf
    1              0.000015 autocmd bufnewfile *.py call HeaderPython()

SCRIPT  /Users/stevezhang/.local/share/nvim/site/autoload/plug.vim
Sourced 1 time
Total time:   0.002301
 Self time:   0.002171

count  total (s)   self (s)
                            " vim-plug: Vim plugin manager
                            " ============================
                            "
                            " Download plug.vim and put it in ~/.vim/autoload
                            "
                            "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
                            "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
                            "
                            " Edit your .vimrc
                            "
                            "   call plug#begin('~/.vim/plugged')
                            "
                            "   " Make sure you use single quotes
                            "
                            "   " Shorthand notation; fetches https://github.com/junegunn/vim-easy-align
                            "   Plug 'junegunn/vim-easy-align'
                            "
                            "   " Any valid git URL is allowed
                            "   Plug 'https://github.com/junegunn/vim-github-dashboard.git'
                            "
                            "   " Multiple Plug commands can be written in a single line using | separators
                            "   Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
                            "
                            "   " On-demand loading
                            "   Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }
                            "   Plug 'tpope/vim-fireplace', { 'for': 'clojure' }
                            "
                            "   " Using a non-master branch
                            "   Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' }
                            "
                            "   " Using a tagged release; wildcard allowed (requires git 1.9.2 or above)
                            "   Plug 'fatih/vim-go', { 'tag': '*' }
                            "
                            "   " Plugin options
                            "   Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' }
                            "
                            "   " Plugin outside ~/.vim/plugged with post-update hook
                            "   Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
                            "
                            "   " Unmanaged plugin (manually installed and updated)
                            "   Plug '~/my-prototype-plugin'
                            "
                            "   " Initialize plugin system
                            "   call plug#end()
                            "
                            " Then reload .vimrc and :PlugInstall to install plugins.
                            "
                            " Plug options:
                            "
                            "| Option                  | Description                                      |
                            "| ----------------------- | ------------------------------------------------ |
                            "| `branch`/`tag`/`commit` | Branch/tag/commit of the repository to use       |
                            "| `rtp`                   | Subdirectory that contains Vim plugin            |
                            "| `dir`                   | Custom directory for the plugin                  |
                            "| `as`                    | Use different name for the plugin                |
                            "| `do`                    | Post-update hook (string or funcref)             |
                            "| `on`                    | On-demand loading: Commands or `<Plug>`-mappings |
                            "| `for`                   | On-demand loading: File types                    |
                            "| `frozen`                | Do not update unless explicitly specified        |
                            "
                            " More information: https://github.com/junegunn/vim-plug
                            "
                            "
                            " Copyright (c) 2017 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000016 if exists('g:loaded_plug')
                              finish
                            endif
    1              0.000005 let g:loaded_plug = 1
                            
    1              0.000007 let s:cpo_save = &cpo
    1              0.000014 set cpo&vim
                            
    1              0.000002 let s:plug_src = 'https://github.com/junegunn/vim-plug.git'
    1              0.000004 let s:plug_tab = get(s:, 'plug_tab', -1)
    1              0.000002 let s:plug_buf = get(s:, 'plug_buf', -1)
    1              0.000007 let s:mac_gui = has('gui_macvim') && has('gui_running')
    1              0.000003 let s:is_win = has('win32')
    1              0.000012 let s:nvim = has('nvim-0.2') || (has('nvim') && exists('*jobwait') && !s:is_win)
    1              0.000008 let s:vim8 = has('patch-8.0.0039') && exists('*job_start')
    1              0.000042 let s:me = resolve(expand('<sfile>:p'))
    1              0.000004 let s:base_spec = { 'branch': 'master', 'frozen': 0 }
    1              0.000020 let s:TYPE = {
                            \   'string':  type(''),
                            \   'list':    type([]),
                            \   'dict':    type({}),
                            \   'funcref': type(function('call'))
                            \ }
    1              0.000003 let s:loaded = get(s:, 'loaded', {})
    1              0.000002 let s:triggers = get(s:, 'triggers', {})
                            
    1              0.000005 function! plug#begin(...)
                              if a:0 > 0
                                let s:plug_home_org = a:1
                                let home = s:path(fnamemodify(expand(a:1), ':p'))
                              elseif exists('g:plug_home')
                                let home = s:path(g:plug_home)
                              elseif !empty(&rtp)
                                let home = s:path(split(&rtp, ',')[0]) . '/plugged'
                              else
                                return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
                              endif
                              if fnamemodify(home, ':t') ==# 'plugin' && fnamemodify(home, ':h') ==# s:first_rtp
                                return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
                              endif
                            
                              let g:plug_home = home
                              let g:plugs = {}
                              let g:plugs_order = []
                              let s:triggers = {}
                            
                              call s:define_commands()
                              return 1
                            endfunction
                            
    1              0.000002 function! s:define_commands()
                              command! -nargs=+ -bar Plug call plug#(<args>)
                              if !executable('git')
                                return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
                              endif
                              command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
                              command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
                              command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
                              command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
                              command! -nargs=0 -bar PlugStatus  call s:status()
                              command! -nargs=0 -bar PlugDiff    call s:diff()
                              command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)
                            endfunction
                            
    1              0.000003 function! s:to_a(v)
                              return type(a:v) == s:TYPE.list ? a:v : [a:v]
                            endfunction
                            
    1              0.000001 function! s:to_s(v)
                              return type(a:v) == s:TYPE.string ? a:v : join(a:v, "\n") . "\n"
                            endfunction
                            
    1              0.000001 function! s:glob(from, pattern)
                              return s:lines(globpath(a:from, a:pattern))
                            endfunction
                            
    1              0.000001 function! s:source(from, ...)
                              let found = 0
                              for pattern in a:000
                                for vim in s:glob(a:from, pattern)
                                  execute 'source' s:esc(vim)
                                  let found = 1
                                endfor
                              endfor
                              return found
                            endfunction
                            
    1              0.000002 function! s:assoc(dict, key, val)
                              let a:dict[a:key] = add(get(a:dict, a:key, []), a:val)
                            endfunction
                            
    1              0.000001 function! s:ask(message, ...)
                              call inputsave()
                              echohl WarningMsg
                              let answer = input(a:message.(a:0 ? ' (y/N/a) ' : ' (y/N) '))
                              echohl None
                              call inputrestore()
                              echo "\r"
                              return (a:0 && answer =~? '^a') ? 2 : (answer =~? '^y') ? 1 : 0
                            endfunction
                            
    1              0.000001 function! s:ask_no_interrupt(...)
                              try
                                return call('s:ask', a:000)
                              catch
                                return 0
                              endtry
                            endfunction
                            
    1              0.000001 function! plug#end()
                              if !exists('g:plugs')
                                return s:err('Call plug#begin() first')
                              endif
                            
                              if exists('#PlugLOD')
                                augroup PlugLOD
                                  autocmd!
                                augroup END
                                augroup! PlugLOD
                              endif
                              let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
                            
                              if exists('g:did_load_filetypes')
                                filetype off
                              endif
                              for name in g:plugs_order
                                if !has_key(g:plugs, name)
                                  continue
                                endif
                                let plug = g:plugs[name]
                                if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
                                  let s:loaded[name] = 1
                                  continue
                                endif
                            
                                if has_key(plug, 'on')
                                  let s:triggers[name] = { 'map': [], 'cmd': [] }
                                  for cmd in s:to_a(plug.on)
                                    if cmd =~? '^<Plug>.\+'
                                      if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
                                        call s:assoc(lod.map, cmd, name)
                                      endif
                                      call add(s:triggers[name].map, cmd)
                                    elseif cmd =~# '^[A-Z]'
                                      let cmd = substitute(cmd, '!*$', '', '')
                                      if exists(':'.cmd) != 2
                                        call s:assoc(lod.cmd, cmd, name)
                                      endif
                                      call add(s:triggers[name].cmd, cmd)
                                    else
                                      call s:err('Invalid `on` option: '.cmd.
                                      \ '. Should start with an uppercase letter or `<Plug>`.')
                                    endif
                                  endfor
                                endif
                            
                                if has_key(plug, 'for')
                                  let types = s:to_a(plug.for)
                                  if !empty(types)
                                    augroup filetypedetect
                                    call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
                                    augroup END
                                  endif
                                  for type in types
                                    call s:assoc(lod.ft, type, name)
                                  endfor
                                endif
                              endfor
                            
                              for [cmd, names] in items(lod.cmd)
                                execute printf(
                                \ 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)',
                                \ cmd, string(cmd), string(names))
                              endfor
                            
                              for [map, names] in items(lod.map)
                                for [mode, map_prefix, key_prefix] in
                                      \ [['i', '<C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
                                  execute printf(
                                  \ '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>',
                                  \ mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
                                endfor
                              endfor
                            
                              for [ft, names] in items(lod.ft)
                                augroup PlugLOD
                                  execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)',
                                        \ ft, string(ft), string(names))
                                augroup END
                              endfor
                            
                              call s:reorg_rtp()
                              filetype plugin indent on
                              if has('vim_starting')
                                if has('syntax') && !exists('g:syntax_on')
                                  syntax enable
                                end
                              else
                                call s:reload_plugins()
                              endif
                            endfunction
                            
    1              0.000002 function! s:loaded_names()
                              return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')
                            endfunction
                            
    1              0.000002 function! s:load_plugin(spec)
                              call s:source(s:rtp(a:spec), 'plugin/**/*.vim', 'after/plugin/**/*.vim')
                            endfunction
                            
    1              0.000002 function! s:reload_plugins()
                              for name in s:loaded_names()
                                call s:load_plugin(g:plugs[name])
                              endfor
                            endfunction
                            
    1              0.000002 function! s:trim(str)
                              return substitute(a:str, '[\/]\+$', '', '')
                            endfunction
                            
    1              0.000002 function! s:version_requirement(val, min)
                              for idx in range(0, len(a:min) - 1)
                                let v = get(a:val, idx, 0)
                                if     v < a:min[idx] | return 0
                                elseif v > a:min[idx] | return 1
                                endif
                              endfor
                              return 1
                            endfunction
                            
    1              0.000001 function! s:git_version_requirement(...)
                              if !exists('s:git_version')
                                let s:git_version = map(split(split(s:system('git --version'))[2], '\.'), 'str2nr(v:val)')
                              endif
                              return s:version_requirement(s:git_version, a:000)
                            endfunction
                            
    1              0.000001 function! s:progress_opt(base)
                              return a:base && !s:is_win &&
                                    \ s:git_version_requirement(1, 7, 1) ? '--progress' : ''
                            endfunction
                            
    1              0.000001 if s:is_win
                              function! s:rtp(spec)
                                return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
                              endfunction
                            
                              function! s:path(path)
                                return s:trim(substitute(a:path, '/', '\', 'g'))
                              endfunction
                            
                              function! s:dirpath(path)
                                return s:path(a:path) . '\'
                              endfunction
                            
                              function! s:is_local_plug(repo)
                                return a:repo =~? '^[a-z]:\|^[%~]'
                              endfunction
                            else
    1              0.000002   function! s:rtp(spec)
                                return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
                              endfunction
                            
    1              0.000001   function! s:path(path)
                                return s:trim(a:path)
                              endfunction
                            
    1              0.000001   function! s:dirpath(path)
                                return substitute(a:path, '[/\\]*$', '/', '')
                              endfunction
                            
    1              0.000001   function! s:is_local_plug(repo)
                                return a:repo[0] =~ '[/$~]'
                              endfunction
    1              0.000001 endif
                            
    1              0.000001 function! s:err(msg)
                              echohl ErrorMsg
                              echom '[vim-plug] '.a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:warn(cmd, msg)
                              echohl WarningMsg
                              execute a:cmd 'a:msg'
                              echohl None
                            endfunction
                            
    1              0.000003 function! s:esc(path)
                              return escape(a:path, ' ')
                            endfunction
                            
    1              0.000001 function! s:escrtp(path)
                              return escape(a:path, ' ,')
                            endfunction
                            
    1              0.000001 function! s:remove_rtp()
                              for name in s:loaded_names()
                                let rtp = s:rtp(g:plugs[name])
                                execute 'set rtp-='.s:escrtp(rtp)
                                let after = globpath(rtp, 'after')
                                if isdirectory(after)
                                  execute 'set rtp-='.s:escrtp(after)
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! s:reorg_rtp()
                              if !empty(s:first_rtp)
                                execute 'set rtp-='.s:first_rtp
                                execute 'set rtp-='.s:last_rtp
                              endif
                            
                              " &rtp is modified from outside
                              if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
                              endif
                            
                              let s:middle = get(s:, 'middle', &rtp)
                              let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
                              let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
                              let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',')
                                             \ . ','.s:middle.','
                                             \ . join(map(afters, 'escape(v:val, ",")'), ',')
                              let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
                              let s:prtp   = &rtp
                            
                              if !empty(s:first_rtp)
                                execute 'set rtp^='.s:first_rtp
                                execute 'set rtp+='.s:last_rtp
                              endif
                            endfunction
                            
    1              0.000001 function! s:doautocmd(...)
                              if exists('#'.join(a:000, '#'))
                                execute 'doautocmd' ((v:version > 703 || has('patch442')) ? '<nomodeline>' : '') join(a:000)
                              endif
                            endfunction
                            
    1              0.000001 function! s:dobufread(names)
                              for name in a:names
                                let path = s:rtp(g:plugs[name]).'/**'
                                for dir in ['ftdetect', 'ftplugin']
                                  if len(finddir(dir, path))
                                    if exists('#BufRead')
                                      doautocmd BufRead
                                    endif
                                    return
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000001 function! plug#load(...)
                              if a:0 == 0
                                return s:err('Argument missing: plugin name(s) required')
                              endif
                              if !exists('g:plugs')
                                return s:err('plug#begin was not called')
                              endif
                              let names = a:0 == 1 && type(a:1) == s:TYPE.list ? a:1 : a:000
                              let unknowns = filter(copy(names), '!has_key(g:plugs, v:val)')
                              if !empty(unknowns)
                                let s = len(unknowns) > 1 ? 's' : ''
                                return s:err(printf('Unknown plugin%s: %s', s, join(unknowns, ', ')))
                              end
                              let unloaded = filter(copy(names), '!get(s:loaded, v:val, 0)')
                              if !empty(unloaded)
                                for name in unloaded
                                  call s:lod([name], ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                                endfor
                                call s:dobufread(unloaded)
                                return 1
                              end
                              return 0
                            endfunction
                            
    1              0.000001 function! s:remove_triggers(name)
                              if !has_key(s:triggers, a:name)
                                return
                              endif
                              for cmd in s:triggers[a:name].cmd
                                execute 'silent! delc' cmd
                              endfor
                              for map in s:triggers[a:name].map
                                execute 'silent! unmap' map
                                execute 'silent! iunmap' map
                              endfor
                              call remove(s:triggers, a:name)
                            endfunction
                            
    1              0.000001 function! s:lod(names, types, ...)
                              for name in a:names
                                call s:remove_triggers(name)
                                let s:loaded[name] = 1
                              endfor
                              call s:reorg_rtp()
                            
                              for name in a:names
                                let rtp = s:rtp(g:plugs[name])
                                for dir in a:types
                                  call s:source(rtp, dir.'/**/*.vim')
                                endfor
                                if a:0
                                  if !s:source(rtp, a:1) && !empty(s:glob(rtp, a:2))
                                    execute 'runtime' a:1
                                  endif
                                  call s:source(rtp, a:2)
                                endif
                                call s:doautocmd('User', name)
                              endfor
                            endfunction
                            
    1              0.000002 function! s:lod_ft(pat, names)
                              let syn = 'syntax/'.a:pat.'.vim'
                              call s:lod(a:names, ['plugin', 'after/plugin'], syn, 'after/'.syn)
                              execute 'autocmd! PlugLOD FileType' a:pat
                              call s:doautocmd('filetypeplugin', 'FileType')
                              call s:doautocmd('filetypeindent', 'FileType')
                            endfunction
                            
    1              0.000002 function! s:lod_cmd(cmd, bang, l1, l2, args, names)
                              call s:lod(a:names, ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                              call s:dobufread(a:names)
                              execute printf('%s%s%s %s', (a:l1 == a:l2 ? '' : (a:l1.','.a:l2)), a:cmd, a:bang, a:args)
                            endfunction
                            
    1              0.000002 function! s:lod_map(map, names, with_prefix, prefix)
                              call s:lod(a:names, ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                              call s:dobufread(a:names)
                              let extra = ''
                              while 1
                                let c = getchar(0)
                                if c == 0
                                  break
                                endif
                                let extra .= nr2char(c)
                              endwhile
                            
                              if a:with_prefix
                                let prefix = v:count ? v:count : ''
                                let prefix .= '"'.v:register.a:prefix
                                if mode(1) == 'no'
                                  if v:operator == 'c'
                                    let prefix = "\<esc>" . prefix
                                  endif
                                  let prefix .= v:operator
                                endif
                                call feedkeys(prefix, 'n')
                              endif
                              call feedkeys(substitute(a:map, '^<Plug>', "\<Plug>", '') . extra)
                            endfunction
                            
    1              0.000002 function! plug#(repo, ...)
                              if a:0 > 1
                                return s:err('Invalid number of arguments (1..2)')
                              endif
                            
                              try
                                let repo = s:trim(a:repo)
                                let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
                                let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
                                let spec = extend(s:infer_properties(name, repo), opts)
                                if !has_key(g:plugs, name)
                                  call add(g:plugs_order, name)
                                endif
                                let g:plugs[name] = spec
                                let s:loaded[name] = get(s:loaded, name, 0)
                              catch
                                return s:err(v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:parse_options(arg)
                              let opts = copy(s:base_spec)
                              let type = type(a:arg)
                              if type == s:TYPE.string
                                let opts.tag = a:arg
                              elseif type == s:TYPE.dict
                                call extend(opts, a:arg)
                                if has_key(opts, 'dir')
                                  let opts.dir = s:dirpath(expand(opts.dir))
                                endif
                              else
                                throw 'Invalid argument type (expected: string or dictionary)'
                              endif
                              return opts
                            endfunction
                            
    1              0.000002 function! s:infer_properties(name, repo)
                              let repo = a:repo
                              if s:is_local_plug(repo)
                                return { 'dir': s:dirpath(expand(repo)) }
                              else
                                if repo =~ ':'
                                  let uri = repo
                                else
                                  if repo !~ '/'
                                    throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
                                  endif
                                  let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
                                  let uri = printf(fmt, repo)
                                endif
                                return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
                              endif
                            endfunction
                            
    1              0.000001 function! s:install(force, names)
                              call s:update_impl(0, a:force, a:names)
                            endfunction
                            
    1              0.000003 function! s:update(force, names)
                              call s:update_impl(1, a:force, a:names)
                            endfunction
                            
    1              0.000001 function! plug#helptags()
                              if !exists('g:plugs')
                                return s:err('plug#begin was not called')
                              endif
                              for spec in values(g:plugs)
                                let docd = join([s:rtp(spec), 'doc'], '/')
                                if isdirectory(docd)
                                  silent! execute 'helptags' s:esc(docd)
                                endif
                              endfor
                              return 1
                            endfunction
                            
    1              0.000001 function! s:syntax()
                              syntax clear
                              syntax region plug1 start=/\%1l/ end=/\%2l/ contains=plugNumber
                              syntax region plug2 start=/\%2l/ end=/\%3l/ contains=plugBracket,plugX
                              syn match plugNumber /[0-9]\+[0-9.]*/ contained
                              syn match plugBracket /[[\]]/ contained
                              syn match plugX /x/ contained
                              syn match plugDash /^-/
                              syn match plugPlus /^+/
                              syn match plugStar /^*/
                              syn match plugMessage /\(^- \)\@<=.*/
                              syn match plugName /\(^- \)\@<=[^ ]*:/
                              syn match plugSha /\%(: \)\@<=[0-9a-f]\{4,}$/
                              syn match plugTag /(tag: [^)]\+)/
                              syn match plugInstall /\(^+ \)\@<=[^:]*/
                              syn match plugUpdate /\(^* \)\@<=[^:]*/
                              syn match plugCommit /^  \X*[0-9a-f]\{7,9} .*/ contains=plugRelDate,plugEdge,plugTag
                              syn match plugEdge /^  \X\+$/
                              syn match plugEdge /^  \X*/ contained nextgroup=plugSha
                              syn match plugSha /[0-9a-f]\{7,9}/ contained
                              syn match plugRelDate /([^)]*)$/ contained
                              syn match plugNotLoaded /(not loaded)$/
                              syn match plugError /^x.*/
                              syn region plugDeleted start=/^\~ .*/ end=/^\ze\S/
                              syn match plugH2 /^.*:\n-\+$/
                              syn keyword Function PlugInstall PlugStatus PlugUpdate PlugClean
                              hi def link plug1       Title
                              hi def link plug2       Repeat
                              hi def link plugH2      Type
                              hi def link plugX       Exception
                              hi def link plugBracket Structure
                              hi def link plugNumber  Number
                            
                              hi def link plugDash    Special
                              hi def link plugPlus    Constant
                              hi def link plugStar    Boolean
                            
                              hi def link plugMessage Function
                              hi def link plugName    Label
                              hi def link plugInstall Function
                              hi def link plugUpdate  Type
                            
                              hi def link plugError   Error
                              hi def link plugDeleted Ignore
                              hi def link plugRelDate Comment
                              hi def link plugEdge    PreProc
                              hi def link plugSha     Identifier
                              hi def link plugTag     Constant
                            
                              hi def link plugNotLoaded Comment
                            endfunction
                            
    1              0.000001 function! s:lpad(str, len)
                              return a:str . repeat(' ', a:len - len(a:str))
                            endfunction
                            
    1              0.000001 function! s:lines(msg)
                              return split(a:msg, "[\r\n]")
                            endfunction
                            
    1              0.000001 function! s:lastline(msg)
                              return get(s:lines(a:msg), -1, '')
                            endfunction
                            
    1              0.000001 function! s:new_window()
                              execute get(g:, 'plug_window', 'vertical topleft new')
                            endfunction
                            
    1              0.000001 function! s:plug_window_exists()
                              let buflist = tabpagebuflist(s:plug_tab)
                              return !empty(buflist) && index(buflist, s:plug_buf) >= 0
                            endfunction
                            
    1              0.000001 function! s:switch_in()
                              if !s:plug_window_exists()
                                return 0
                              endif
                            
                              if winbufnr(0) != s:plug_buf
                                let s:pos = [tabpagenr(), winnr(), winsaveview()]
                                execute 'normal!' s:plug_tab.'gt'
                                let winnr = bufwinnr(s:plug_buf)
                                execute winnr.'wincmd w'
                                call add(s:pos, winsaveview())
                              else
                                let s:pos = [winsaveview()]
                              endif
                            
                              setlocal modifiable
                              return 1
                            endfunction
                            
    1              0.000001 function! s:switch_out(...)
                              call winrestview(s:pos[-1])
                              setlocal nomodifiable
                              if a:0 > 0
                                execute a:1
                              endif
                            
                              if len(s:pos) > 1
                                execute 'normal!' s:pos[0].'gt'
                                execute s:pos[1] 'wincmd w'
                                call winrestview(s:pos[2])
                              endif
                            endfunction
                            
    1              0.000001 function! s:finish_bindings()
                              nnoremap <silent> <buffer> R  :call <SID>retry()<cr>
                              nnoremap <silent> <buffer> D  :PlugDiff<cr>
                              nnoremap <silent> <buffer> S  :PlugStatus<cr>
                              nnoremap <silent> <buffer> U  :call <SID>status_update()<cr>
                              xnoremap <silent> <buffer> U  :call <SID>status_update()<cr>
                              nnoremap <silent> <buffer> ]] :silent! call <SID>section('')<cr>
                              nnoremap <silent> <buffer> [[ :silent! call <SID>section('b')<cr>
                            endfunction
                            
    1              0.000001 function! s:prepare(...)
                              if empty(getcwd())
                                throw 'Invalid current working directory. Cannot proceed.'
                              endif
                            
                              for evar in ['$GIT_DIR', '$GIT_WORK_TREE']
                                if exists(evar)
                                  throw evar.' detected. Cannot proceed.'
                                endif
                              endfor
                            
                              call s:job_abort()
                              if s:switch_in()
                                if b:plug_preview == 1
                                  pc
                                endif
                                enew
                              else
                                call s:new_window()
                              endif
                            
                              nnoremap <silent> <buffer> q  :if b:plug_preview==1<bar>pc<bar>endif<bar>bd<cr>
                              if a:0 == 0
                                call s:finish_bindings()
                              endif
                              let b:plug_preview = -1
                              let s:plug_tab = tabpagenr()
                              let s:plug_buf = winbufnr(0)
                              call s:assign_name()
                            
                              for k in ['<cr>', 'L', 'o', 'X', 'd', 'dd']
                                execute 'silent! unmap <buffer>' k
                              endfor
                              setlocal buftype=nofile bufhidden=wipe nobuflisted nolist noswapfile nowrap cursorline modifiable nospell
                              if exists('+colorcolumn')
                                setlocal colorcolumn=
                              endif
                              setf vim-plug
                              if exists('g:syntax_on')
                                call s:syntax()
                              endif
                            endfunction
                            
    1              0.000001 function! s:assign_name()
                              " Assign buffer name
                              let prefix = '[Plugins]'
                              let name   = prefix
                              let idx    = 2
                              while bufexists(name)
                                let name = printf('%s (%s)', prefix, idx)
                                let idx = idx + 1
                              endwhile
                              silent! execute 'f' fnameescape(name)
                            endfunction
                            
    1              0.000001 function! s:chsh(swap)
                              let prev = [&shell, &shellcmdflag, &shellredir]
                              if s:is_win
                                set shell=cmd.exe shellcmdflag=/c shellredir=>%s\ 2>&1
                              elseif a:swap
                                set shell=sh shellredir=>%s\ 2>&1
                              endif
                              return prev
                            endfunction
                            
    1              0.000001 function! s:bang(cmd, ...)
                              try
                                let [sh, shellcmdflag, shrd] = s:chsh(a:0)
                                " FIXME: Escaping is incomplete. We could use shellescape with eval,
                                "        but it won't work on Windows.
                                let cmd = a:0 ? s:with_cd(a:cmd, a:1) : a:cmd
                                if s:is_win
                                  let batchfile = tempname().'.bat'
                                  call writefile(["@echo off\r", cmd . "\r"], batchfile)
                                  let cmd = batchfile
                                endif
                                let g:_plug_bang = (s:is_win && has('gui_running') ? 'silent ' : '').'!'.escape(cmd, '#!%')
                                execute "normal! :execute g:_plug_bang\<cr>\<cr>"
                              finally
                                unlet g:_plug_bang
                                let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                                if s:is_win
                                  call delete(batchfile)
                                endif
                              endtry
                              return v:shell_error ? 'Exit status: ' . v:shell_error : ''
                            endfunction
                            
    1              0.000001 function! s:regress_bar()
                              let bar = substitute(getline(2)[1:-2], '.*\zs=', 'x', '')
                              call s:progress_bar(2, bar, len(bar))
                            endfunction
                            
    1              0.000001 function! s:is_updated(dir)
                              return !empty(s:system_chomp('git log --pretty=format:"%h" "HEAD...HEAD@{1}"', a:dir))
                            endfunction
                            
    1              0.000001 function! s:do(pull, force, todo)
                              for [name, spec] in items(a:todo)
                                if !isdirectory(spec.dir)
                                  continue
                                endif
                                let installed = has_key(s:update.new, name)
                                let updated = installed ? 0 :
                                  \ (a:pull && index(s:update.errors, name) < 0 && s:is_updated(spec.dir))
                                if a:force || installed || updated
                                  execute 'cd' s:esc(spec.dir)
                                  call append(3, '- Post-update hook for '. name .' ... ')
                                  let error = ''
                                  let type = type(spec.do)
                                  if type == s:TYPE.string
                                    if spec.do[0] == ':'
                                      if !get(s:loaded, name, 0)
                                        let s:loaded[name] = 1
                                        call s:reorg_rtp()
                                      endif
                                      call s:load_plugin(spec)
                                      try
                                        execute spec.do[1:]
                                      catch
                                        let error = v:exception
                                      endtry
                                      if !s:plug_window_exists()
                                        cd -
                                        throw 'Warning: vim-plug was terminated by the post-update hook of '.name
                                      endif
                                    else
                                      let error = s:bang(spec.do)
                                    endif
                                  elseif type == s:TYPE.funcref
                                    try
                                      let status = installed ? 'installed' : (updated ? 'updated' : 'unchanged')
                                      call spec.do({ 'name': name, 'status': status, 'force': a:force })
                                    catch
                                      let error = v:exception
                                    endtry
                                  else
                                    let error = 'Invalid hook type'
                                  endif
                                  call s:switch_in()
                                  call setline(4, empty(error) ? (getline(4) . 'OK')
                                                             \ : ('x' . getline(4)[1:] . error))
                                  if !empty(error)
                                    call add(s:update.errors, name)
                                    call s:regress_bar()
                                  endif
                                  cd -
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! s:hash_match(a, b)
                              return stridx(a:a, a:b) == 0 || stridx(a:b, a:a) == 0
                            endfunction
                            
    1              0.000003 function! s:checkout(spec)
                              let sha = a:spec.commit
                              let output = s:system('git rev-parse HEAD', a:spec.dir)
                              if !v:shell_error && !s:hash_match(sha, s:lines(output)[0])
                                let output = s:system(
                                      \ 'git fetch --depth 999999 && git checkout '.s:esc(sha).' --', a:spec.dir)
                              endif
                              return output
                            endfunction
                            
    1              0.000001 function! s:finish(pull)
                              let new_frozen = len(filter(keys(s:update.new), 'g:plugs[v:val].frozen'))
                              if new_frozen
                                let s = new_frozen > 1 ? 's' : ''
                                call append(3, printf('- Installed %d frozen plugin%s', new_frozen, s))
                              endif
                              call append(3, '- Finishing ... ') | 4
                              redraw
                              call plug#helptags()
                              call plug#end()
                              call setline(4, getline(4) . 'Done!')
                              redraw
                              let msgs = []
                              if !empty(s:update.errors)
                                call add(msgs, "Press 'R' to retry.")
                              endif
                              if a:pull && len(s:update.new) < len(filter(getline(5, '$'),
                                            \ "v:val =~ '^- ' && v:val !~# 'Already up.to.date'"))
                                call add(msgs, "Press 'D' to see the updated changes.")
                              endif
                              echo join(msgs, ' ')
                              call s:finish_bindings()
                            endfunction
                            
    1              0.000001 function! s:retry()
                              if empty(s:update.errors)
                                return
                              endif
                              echo
                              call s:update_impl(s:update.pull, s:update.force,
                                    \ extend(copy(s:update.errors), [s:update.threads]))
                            endfunction
                            
    1              0.000001 function! s:is_managed(name)
                              return has_key(g:plugs[a:name], 'uri')
                            endfunction
                            
    1              0.000001 function! s:names(...)
                              return sort(filter(keys(g:plugs), 'stridx(v:val, a:1) == 0 && s:is_managed(v:val)'))
                            endfunction
                            
    1              0.000001 function! s:check_ruby()
                              silent! ruby require 'thread'; VIM::command("let g:plug_ruby = '#{RUBY_VERSION}'")
                              if !exists('g:plug_ruby')
                                redraw!
                                return s:warn('echom', 'Warning: Ruby interface is broken')
                              endif
                              let ruby_version = split(g:plug_ruby, '\.')
                              unlet g:plug_ruby
                              return s:version_requirement(ruby_version, [1, 8, 7])
                            endfunction
                            
    1              0.000002 function! s:update_impl(pull, force, args) abort
                              let sync = index(a:args, '--sync') >= 0 || has('vim_starting')
                              let args = filter(copy(a:args), 'v:val != "--sync"')
                              let threads = (len(args) > 0 && args[-1] =~ '^[1-9][0-9]*$') ?
                                              \ remove(args, -1) : get(g:, 'plug_threads', 16)
                            
                              let managed = filter(copy(g:plugs), 's:is_managed(v:key)')
                              let todo = empty(args) ? filter(managed, '!v:val.frozen || !isdirectory(v:val.dir)') :
                                                     \ filter(managed, 'index(args, v:key) >= 0')
                            
                              if empty(todo)
                                return s:warn('echo', 'No plugin to '. (a:pull ? 'update' : 'install'))
                              endif
                            
                              if !s:is_win && s:git_version_requirement(2, 3)
                                let s:git_terminal_prompt = exists('$GIT_TERMINAL_PROMPT') ? $GIT_TERMINAL_PROMPT : ''
                                let $GIT_TERMINAL_PROMPT = 0
                                for plug in values(todo)
                                  let plug.uri = substitute(plug.uri,
                                        \ '^https://git::@github\.com', 'https://github.com', '')
                                endfor
                              endif
                            
                              if !isdirectory(g:plug_home)
                                try
                                  call mkdir(g:plug_home, 'p')
                                catch
                                  return s:err(printf('Invalid plug directory: %s. '.
                                          \ 'Try to call plug#begin with a valid directory', g:plug_home))
                                endtry
                              endif
                            
                              if has('nvim') && !exists('*jobwait') && threads > 1
                                call s:warn('echom', '[vim-plug] Update Neovim for parallel installer')
                              endif
                            
                              let use_job = s:nvim || s:vim8
                              let python = (has('python') || has('python3')) && !use_job
                              let ruby = has('ruby') && !use_job && (v:version >= 703 || v:version == 702 && has('patch374')) && !(s:is_win && has('gui_running')) && threads > 1 && s:check_ruby()
                            
                              let s:update = {
                                \ 'start':   reltime(),
                                \ 'all':     todo,
                                \ 'todo':    copy(todo),
                                \ 'errors':  [],
                                \ 'pull':    a:pull,
                                \ 'force':   a:force,
                                \ 'new':     {},
                                \ 'threads': (python || ruby || use_job) ? min([len(todo), threads]) : 1,
                                \ 'bar':     '',
                                \ 'fin':     0
                              \ }
                            
                              call s:prepare(1)
                              call append(0, ['', ''])
                              normal! 2G
                              silent! redraw
                            
                              let s:clone_opt = get(g:, 'plug_shallow', 1) ?
                                    \ '--depth 1' . (s:git_version_requirement(1, 7, 10) ? ' --no-single-branch' : '') : ''
                            
                              if has('win32unix')
                                let s:clone_opt .= ' -c core.eol=lf -c core.autocrlf=input'
                              endif
                            
                              let s:submodule_opt = s:git_version_requirement(2, 8) ? ' --jobs='.threads : ''
                            
                              " Python version requirement (>= 2.7)
                              if python && !has('python3') && !ruby && !use_job && s:update.threads > 1
                                redir => pyv
                                silent python import platform; print platform.python_version()
                                redir END
                                let python = s:version_requirement(
                                      \ map(split(split(pyv)[0], '\.'), 'str2nr(v:val)'), [2, 6])
                              endif
                            
                              if (python || ruby) && s:update.threads > 1
                                try
                                  let imd = &imd
                                  if s:mac_gui
                                    set noimd
                                  endif
                                  if ruby
                                    call s:update_ruby()
                                  else
                                    call s:update_python()
                                  endif
                                catch
                                  let lines = getline(4, '$')
                                  let printed = {}
                                  silent! 4,$d _
                                  for line in lines
                                    let name = s:extract_name(line, '.', '')
                                    if empty(name) || !has_key(printed, name)
                                      call append('$', line)
                                      if !empty(name)
                                        let printed[name] = 1
                                        if line[0] == 'x' && index(s:update.errors, name) < 0
                                          call add(s:update.errors, name)
                                        end
                                      endif
                                    endif
                                  endfor
                                finally
                                  let &imd = imd
                                  call s:update_finish()
                                endtry
                              else
                                call s:update_vim()
                                while use_job && sync
                                  sleep 100m
                                  if s:update.fin
                                    break
                                  endif
                                endwhile
                              endif
                            endfunction
                            
    1              0.000001 function! s:log4(name, msg)
                              call setline(4, printf('- %s (%s)', a:msg, a:name))
                              redraw
                            endfunction
                            
    1              0.000001 function! s:update_finish()
                              if exists('s:git_terminal_prompt')
                                let $GIT_TERMINAL_PROMPT = s:git_terminal_prompt
                              endif
                              if s:switch_in()
                                call append(3, '- Updating ...') | 4
                                for [name, spec] in items(filter(copy(s:update.all), 'index(s:update.errors, v:key) < 0 && (s:update.force || s:update.pull || has_key(s:update.new, v:key))'))
                                  let [pos, _] = s:logpos(name)
                                  if !pos
                                    continue
                                  endif
                                  if has_key(spec, 'commit')
                                    call s:log4(name, 'Checking out '.spec.commit)
                                    let out = s:checkout(spec)
                                  elseif has_key(spec, 'tag')
                                    let tag = spec.tag
                                    if tag =~ '\*'
                                      let tags = s:lines(s:system('git tag --list '.s:shellesc(tag).' --sort -version:refname 2>&1', spec.dir))
                                      if !v:shell_error && !empty(tags)
                                        let tag = tags[0]
                                        call s:log4(name, printf('Latest tag for %s -> %s', spec.tag, tag))
                                        call append(3, '')
                                      endif
                                    endif
                                    call s:log4(name, 'Checking out '.tag)
                                    let out = s:system('git checkout -q '.s:esc(tag).' -- 2>&1', spec.dir)
                                  else
                                    let branch = s:esc(get(spec, 'branch', 'master'))
                                    call s:log4(name, 'Merging origin/'.branch)
                                    let out = s:system('git checkout -q '.branch.' -- 2>&1'
                                          \. (has_key(s:update.new, name) ? '' : ('&& git merge --ff-only origin/'.branch.' 2>&1')), spec.dir)
                                  endif
                                  if !v:shell_error && filereadable(spec.dir.'/.gitmodules') &&
                                        \ (s:update.force || has_key(s:update.new, name) || s:is_updated(spec.dir))
                                    call s:log4(name, 'Updating submodules. This may take a while.')
                                    let out .= s:bang('git submodule update --init --recursive'.s:submodule_opt.' 2>&1', spec.dir)
                                  endif
                                  let msg = s:format_message(v:shell_error ? 'x': '-', name, out)
                                  if v:shell_error
                                    call add(s:update.errors, name)
                                    call s:regress_bar()
                                    silent execute pos 'd _'
                                    call append(4, msg) | 4
                                  elseif !empty(out)
                                    call setline(pos, msg[0])
                                  endif
                                  redraw
                                endfor
                                silent 4 d _
                                try
                                  call s:do(s:update.pull, s:update.force, filter(copy(s:update.all), 'index(s:update.errors, v:key) < 0 && has_key(v:val, "do")'))
                                catch
                                  call s:warn('echom', v:exception)
                                  call s:warn('echo', '')
                                  return
                                endtry
                                call s:finish(s:update.pull)
                                call setline(1, 'Updated. Elapsed time: ' . split(reltimestr(reltime(s:update.start)))[0] . ' sec.')
                                call s:switch_out('normal! gg')
                              endif
                            endfunction
                            
    1              0.000001 function! s:job_abort()
                              if (!s:nvim && !s:vim8) || !exists('s:jobs')
                                return
                              endif
                            
                              for [name, j] in items(s:jobs)
                                if s:nvim
                                  silent! call jobstop(j.jobid)
                                elseif s:vim8
                                  silent! call job_stop(j.jobid)
                                endif
                                if j.new
                                  call s:system('rm -rf ' . s:shellesc(g:plugs[name].dir))
                                endif
                              endfor
                              let s:jobs = {}
                            endfunction
                            
    1              0.000002 function! s:last_non_empty_line(lines)
                              let len = len(a:lines)
                              for idx in range(len)
                                let line = a:lines[len-idx-1]
                                if !empty(line)
                                  return line
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:job_out_cb(self, data) abort
                              let self = a:self
                              let data = remove(self.lines, -1) . a:data
                              let lines = map(split(data, "\n", 1), 'split(v:val, "\r", 1)[-1]')
                              call extend(self.lines, lines)
                              " To reduce the number of buffer updates
                              let self.tick = get(self, 'tick', -1) + 1
                              if !self.running || self.tick % len(s:jobs) == 0
                                let bullet = self.running ? (self.new ? '+' : '*') : (self.error ? 'x' : '-')
                                let result = self.error ? join(self.lines, "\n") : s:last_non_empty_line(self.lines)
                                call s:log(bullet, self.name, result)
                              endif
                            endfunction
                            
    1              0.000002 function! s:job_exit_cb(self, data) abort
                              let a:self.running = 0
                              let a:self.error = a:data != 0
                              call s:reap(a:self.name)
                              call s:tick()
                            endfunction
                            
    1              0.000002 function! s:job_cb(fn, job, ch, data)
                              if !s:plug_window_exists() " plug window closed
                                return s:job_abort()
                              endif
                              call call(a:fn, [a:job, a:data])
                            endfunction
                            
    1              0.000002 function! s:nvim_cb(job_id, data, event) dict abort
                              return a:event == 'stdout' ?
                                \ s:job_cb('s:job_out_cb',  self, 0, join(a:data, "\n")) :
                                \ s:job_cb('s:job_exit_cb', self, 0, a:data)
                            endfunction
                            
    1              0.000001 function! s:spawn(name, cmd, opts)
                              let job = { 'name': a:name, 'running': 1, 'error': 0, 'lines': [''],
                                        \ 'batchfile': (s:is_win && (s:nvim || s:vim8)) ? tempname().'.bat' : '',
                                        \ 'new': get(a:opts, 'new', 0) }
                              let s:jobs[a:name] = job
                              let cmd = has_key(a:opts, 'dir') ? s:with_cd(a:cmd, a:opts.dir) : a:cmd
                              if !empty(job.batchfile)
                                call writefile(["@echo off\r", cmd . "\r"], job.batchfile)
                                let cmd = job.batchfile
                              endif
                              let argv = add(s:is_win ? ['cmd', '/c'] : ['sh', '-c'], cmd)
                            
                              if s:nvim
                                call extend(job, {
                                \ 'on_stdout': function('s:nvim_cb'),
                                \ 'on_exit':   function('s:nvim_cb'),
                                \ })
                                let jid = jobstart(argv, job)
                                if jid > 0
                                  let job.jobid = jid
                                else
                                  let job.running = 0
                                  let job.error   = 1
                                  let job.lines   = [jid < 0 ? argv[0].' is not executable' :
                                        \ 'Invalid arguments (or job table is full)']
                                endif
                              elseif s:vim8
                                let jid = job_start(s:is_win ? join(argv, ' ') : argv, {
                                \ 'out_cb':   function('s:job_cb', ['s:job_out_cb',  job]),
                                \ 'exit_cb':  function('s:job_cb', ['s:job_exit_cb', job]),
                                \ 'out_mode': 'raw'
                                \})
                                if job_status(jid) == 'run'
                                  let job.jobid = jid
                                else
                                  let job.running = 0
                                  let job.error   = 1
                                  let job.lines   = ['Failed to start job']
                                endif
                              else
                                let job.lines = s:lines(call('s:system', [cmd]))
                                let job.error = v:shell_error != 0
                                let job.running = 0
                              endif
                            endfunction
                            
    1              0.000001 function! s:reap(name)
                              let job = s:jobs[a:name]
                              if job.error
                                call add(s:update.errors, a:name)
                              elseif get(job, 'new', 0)
                                let s:update.new[a:name] = 1
                              endif
                              let s:update.bar .= job.error ? 'x' : '='
                            
                              let bullet = job.error ? 'x' : '-'
                              let result = job.error ? join(job.lines, "\n") : s:last_non_empty_line(job.lines)
                              call s:log(bullet, a:name, empty(result) ? 'OK' : result)
                              call s:bar()
                            
                              if has_key(job, 'batchfile') && !empty(job.batchfile)
                                call delete(job.batchfile)
                              endif
                              call remove(s:jobs, a:name)
                            endfunction
                            
    1              0.000001 function! s:bar()
                              if s:switch_in()
                                let total = len(s:update.all)
                                call setline(1, (s:update.pull ? 'Updating' : 'Installing').
                                      \ ' plugins ('.len(s:update.bar).'/'.total.')')
                                call s:progress_bar(2, s:update.bar, total)
                                call s:switch_out()
                              endif
                            endfunction
                            
    1              0.000001 function! s:logpos(name)
                              for i in range(4, line('$'))
                                if getline(i) =~# '^[-+x*] '.a:name.':'
                                  for j in range(i + 1, line('$'))
                                    if getline(j) !~ '^ '
                                      return [i, j - 1]
                                    endif
                                  endfor
                                  return [i, i]
                                endif
                              endfor
                              return [0, 0]
                            endfunction
                            
    1              0.000001 function! s:log(bullet, name, lines)
                              if s:switch_in()
                                let [b, e] = s:logpos(a:name)
                                if b > 0
                                  silent execute printf('%d,%d d _', b, e)
                                  if b > winheight('.')
                                    let b = 4
                                  endif
                                else
                                  let b = 4
                                endif
                                " FIXME For some reason, nomodifiable is set after :d in vim8
                                setlocal modifiable
                                call append(b - 1, s:format_message(a:bullet, a:name, a:lines))
                                call s:switch_out()
                              endif
                            endfunction
                            
    1              0.000001 function! s:update_vim()
                              let s:jobs = {}
                            
                              call s:bar()
                              call s:tick()
                            endfunction
                            
    1              0.000001 function! s:tick()
                              let pull = s:update.pull
                              let prog = s:progress_opt(s:nvim || s:vim8)
                            while 1 " Without TCO, Vim stack is bound to explode
                              if empty(s:update.todo)
                                if empty(s:jobs) && !s:update.fin
                                  call s:update_finish()
                                  let s:update.fin = 1
                                endif
                                return
                              endif
                            
                              let name = keys(s:update.todo)[0]
                              let spec = remove(s:update.todo, name)
                              let new  = !isdirectory(spec.dir)
                            
                              call s:log(new ? '+' : '*', name, pull ? 'Updating ...' : 'Installing ...')
                              redraw
                            
                              let has_tag = has_key(spec, 'tag')
                              if !new
                                let [error, _] = s:git_validate(spec, 0)
                                if empty(error)
                                  if pull
                                    let fetch_opt = (has_tag && !empty(globpath(spec.dir, '.git/shallow'))) ? '--depth 99999999' : ''
                                    call s:spawn(name, printf('git fetch %s %s 2>&1', fetch_opt, prog), { 'dir': spec.dir })
                                  else
                                    let s:jobs[name] = { 'running': 0, 'lines': ['Already installed'], 'error': 0 }
                                  endif
                                else
                                  let s:jobs[name] = { 'running': 0, 'lines': s:lines(error), 'error': 1 }
                                endif
                              else
                                call s:spawn(name,
                                      \ printf('git clone %s %s %s %s 2>&1',
                                      \ has_tag ? '' : s:clone_opt,
                                      \ prog,
                                      \ s:shellesc(spec.uri),
                                      \ s:shellesc(s:trim(spec.dir))), { 'new': 1 })
                              endif
                            
                              if !s:jobs[name].running
                                call s:reap(name)
                              endif
                              if len(s:jobs) >= s:update.threads
                                break
                              endif
                            endwhile
                            endfunction
                            
    1              0.000001 function! s:update_python()
                            let py_exe = has('python') ? 'python' : 'python3'
                            execute py_exe "<< EOF"
                            import datetime
                            import functools
                            import os
                            try:
                              import queue
                            except ImportError:
                              import Queue as queue
                            import random
                            import re
                            import shutil
                            import signal
                            import subprocess
                            import tempfile
                            import threading as thr
                            import time
                            import traceback
                            import vim
                            
                            G_NVIM = vim.eval("has('nvim')") == '1'
                            G_PULL = vim.eval('s:update.pull') == '1'
                            G_RETRIES = int(vim.eval('get(g:, "plug_retries", 2)')) + 1
                            G_TIMEOUT = int(vim.eval('get(g:, "plug_timeout", 60)'))
                            G_CLONE_OPT = vim.eval('s:clone_opt')
                            G_PROGRESS = vim.eval('s:progress_opt(1)')
                            G_LOG_PROB = 1.0 / int(vim.eval('s:update.threads'))
                            G_STOP = thr.Event()
                            G_IS_WIN = vim.eval('s:is_win') == '1'
                            
                            class PlugError(Exception):
                              def __init__(self, msg):
                                self.msg = msg
                            class CmdTimedOut(PlugError):
                              pass
                            class CmdFailed(PlugError):
                              pass
                            class InvalidURI(PlugError):
                              pass
                            class Action(object):
                              INSTALL, UPDATE, ERROR, DONE = ['+', '*', 'x', '-']
                            
                            class Buffer(object):
                              def __init__(self, lock, num_plugs, is_pull):
                                self.bar = ''
                                self.event = 'Updating' if is_pull else 'Installing'
                                self.lock = lock
                                self.maxy = int(vim.eval('winheight(".")'))
                                self.num_plugs = num_plugs
                            
                              def __where(self, name):
                                """ Find first line with name in current buffer. Return line num. """
                                found, lnum = False, 0
                                matcher = re.compile('^[-+x*] {0}:'.format(name))
                                for line in vim.current.buffer:
                                  if matcher.search(line) is not None:
                                    found = True
                                    break
                                  lnum += 1
                            
                                if not found:
                                  lnum = -1
                                return lnum
                            
                              def header(self):
                                curbuf = vim.current.buffer
                                curbuf[0] = self.event + ' plugins ({0}/{1})'.format(len(self.bar), self.num_plugs)
                            
                                num_spaces = self.num_plugs - len(self.bar)
                                curbuf[1] = '[{0}{1}]'.format(self.bar, num_spaces * ' ')
                            
                                with self.lock:
                                  vim.command('normal! 2G')
                                  vim.command('redraw')
                            
                              def write(self, action, name, lines):
                                first, rest = lines[0], lines[1:]
                                msg = ['{0} {1}{2}{3}'.format(action, name, ': ' if first else '', first)]
                                msg.extend(['    ' + line for line in rest])
                            
                                try:
                                  if action == Action.ERROR:
                                    self.bar += 'x'
                                    vim.command("call add(s:update.errors, '{0}')".format(name))
                                  elif action == Action.DONE:
                                    self.bar += '='
                            
                                  curbuf = vim.current.buffer
                                  lnum = self.__where(name)
                                  if lnum != -1: # Found matching line num
                                    del curbuf[lnum]
                                    if lnum > self.maxy and action in set([Action.INSTALL, Action.UPDATE]):
                                      lnum = 3
                                  else:
                                    lnum = 3
                                  curbuf.append(msg, lnum)
                            
                                  self.header()
                                except vim.error:
                                  pass
                            
                            class Command(object):
                              CD = 'cd /d' if G_IS_WIN else 'cd'
                            
                              def __init__(self, cmd, cmd_dir=None, timeout=60, cb=None, clean=None):
                                self.cmd = cmd
                                if cmd_dir:
                                  self.cmd = '{0} {1} && {2}'.format(Command.CD, cmd_dir, self.cmd)
                                self.timeout = timeout
                                self.callback = cb if cb else (lambda msg: None)
                                self.clean = clean if clean else (lambda: None)
                                self.proc = None
                            
                              @property
                              def alive(self):
                                """ Returns true only if command still running. """
                                return self.proc and self.proc.poll() is None
                            
                              def execute(self, ntries=3):
                                """ Execute the command with ntries if CmdTimedOut.
                                    Returns the output of the command if no Exception.
                                """
                                attempt, finished, limit = 0, False, self.timeout
                            
                                while not finished:
                                  try:
                                    attempt += 1
                                    result = self.try_command()
                                    finished = True
                                    return result
                                  except CmdTimedOut:
                                    if attempt != ntries:
                                      self.notify_retry()
                                      self.timeout += limit
                                    else:
                                      raise
                            
                              def notify_retry(self):
                                """ Retry required for command, notify user. """
                                for count in range(3, 0, -1):
                                  if G_STOP.is_set():
                                    raise KeyboardInterrupt
                                  msg = 'Timeout. Will retry in {0} second{1} ...'.format(
                                        count, 's' if count != 1 else '')
                                  self.callback([msg])
                                  time.sleep(1)
                                self.callback(['Retrying ...'])
                            
                              def try_command(self):
                                """ Execute a cmd & poll for callback. Returns list of output.
                                    Raises CmdFailed   -> return code for Popen isn't 0
                                    Raises CmdTimedOut -> command exceeded timeout without new output
                                """
                                first_line = True
                            
                                try:
                                  tfile = tempfile.NamedTemporaryFile(mode='w+b')
                                  preexec_fn = not G_IS_WIN and os.setsid or None
                                  self.proc = subprocess.Popen(self.cmd, stdout=tfile,
                                                               stderr=subprocess.STDOUT,
                                                               stdin=subprocess.PIPE, shell=True,
                                                               preexec_fn=preexec_fn)
                                  thrd = thr.Thread(target=(lambda proc: proc.wait()), args=(self.proc,))
                                  thrd.start()
                            
                                  thread_not_started = True
                                  while thread_not_started:
                                    try:
                                      thrd.join(0.1)
                                      thread_not_started = False
                                    except RuntimeError:
                                      pass
                            
                                  while self.alive:
                                    if G_STOP.is_set():
                                      raise KeyboardInterrupt
                            
                                    if first_line or random.random() < G_LOG_PROB:
                                      first_line = False
                                      line = '' if G_IS_WIN else nonblock_read(tfile.name)
                                      if line:
                                        self.callback([line])
                            
                                    time_diff = time.time() - os.path.getmtime(tfile.name)
                                    if time_diff > self.timeout:
                                      raise CmdTimedOut(['Timeout!'])
                            
                                    thrd.join(0.5)
                            
                                  tfile.seek(0)
                                  result = [line.decode('utf-8', 'replace').rstrip() for line in tfile]
                            
                                  if self.proc.returncode != 0:
                                    raise CmdFailed([''] + result)
                            
                                  return result
                                except:
                                  self.terminate()
                                  raise
                            
                              def terminate(self):
                                """ Terminate process and cleanup. """
                                if self.alive:
                                  if G_IS_WIN:
                                    os.kill(self.proc.pid, signal.SIGINT)
                                  else:
                                    os.killpg(self.proc.pid, signal.SIGTERM)
                                self.clean()
                            
                            class Plugin(object):
                              def __init__(self, name, args, buf_q, lock):
                                self.name = name
                                self.args = args
                                self.buf_q = buf_q
                                self.lock = lock
                                self.tag = args.get('tag', 0)
                            
                              def manage(self):
                                try:
                                  if os.path.exists(self.args['dir']):
                                    self.update()
                                  else:
                                    self.install()
                                    with self.lock:
                                      thread_vim_command("let s:update.new['{0}'] = 1".format(self.name))
                                except PlugError as exc:
                                  self.write(Action.ERROR, self.name, exc.msg)
                                except KeyboardInterrupt:
                                  G_STOP.set()
                                  self.write(Action.ERROR, self.name, ['Interrupted!'])
                                except:
                                  # Any exception except those above print stack trace
                                  msg = 'Trace:\n{0}'.format(traceback.format_exc().rstrip())
                                  self.write(Action.ERROR, self.name, msg.split('\n'))
                                  raise
                            
                              def install(self):
                                target = self.args['dir']
                                if target[-1] == '\\':
                                  target = target[0:-1]
                            
                                def clean(target):
                                  def _clean():
                                    try:
                                      shutil.rmtree(target)
                                    except OSError:
                                      pass
                                  return _clean
                            
                                self.write(Action.INSTALL, self.name, ['Installing ...'])
                                callback = functools.partial(self.write, Action.INSTALL, self.name)
                                cmd = 'git clone {0} {1} {2} {3} 2>&1'.format(
                                      '' if self.tag else G_CLONE_OPT, G_PROGRESS, self.args['uri'],
                                      esc(target))
                                com = Command(cmd, None, G_TIMEOUT, callback, clean(target))
                                result = com.execute(G_RETRIES)
                                self.write(Action.DONE, self.name, result[-1:])
                            
                              def repo_uri(self):
                                cmd = 'git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url'
                                command = Command(cmd, self.args['dir'], G_TIMEOUT,)
                                result = command.execute(G_RETRIES)
                                return result[-1]
                            
                              def update(self):
                                actual_uri = self.repo_uri()
                                expect_uri = self.args['uri']
                                regex = re.compile(r'^(?:\w+://)?(?:[^@/]*@)?([^:/]*(?::[0-9]*)?)[:/](.*?)(?:\.git)?/?$')
                                ma = regex.match(actual_uri)
                                mb = regex.match(expect_uri)
                                if ma is None or mb is None or ma.groups() != mb.groups():
                                  msg = ['',
                                         'Invalid URI: {0}'.format(actual_uri),
                                         'Expected     {0}'.format(expect_uri),
                                         'PlugClean required.']
                                  raise InvalidURI(msg)
                            
                                if G_PULL:
                                  self.write(Action.UPDATE, self.name, ['Updating ...'])
                                  callback = functools.partial(self.write, Action.UPDATE, self.name)
                                  fetch_opt = '--depth 99999999' if self.tag and os.path.isfile(os.path.join(self.args['dir'], '.git/shallow')) else ''
                                  cmd = 'git fetch {0} {1} 2>&1'.format(fetch_opt, G_PROGRESS)
                                  com = Command(cmd, self.args['dir'], G_TIMEOUT, callback)
                                  result = com.execute(G_RETRIES)
                                  self.write(Action.DONE, self.name, result[-1:])
                                else:
                                  self.write(Action.DONE, self.name, ['Already installed'])
                            
                              def write(self, action, name, msg):
                                self.buf_q.put((action, name, msg))
                            
                            class PlugThread(thr.Thread):
                              def __init__(self, tname, args):
                                super(PlugThread, self).__init__()
                                self.tname = tname
                                self.args = args
                            
                              def run(self):
                                thr.current_thread().name = self.tname
                                buf_q, work_q, lock = self.args
                            
                                try:
                                  while not G_STOP.is_set():
                                    name, args = work_q.get_nowait()
                                    plug = Plugin(name, args, buf_q, lock)
                                    plug.manage()
                                    work_q.task_done()
                                except queue.Empty:
                                  pass
                            
                            class RefreshThread(thr.Thread):
                              def __init__(self, lock):
                                super(RefreshThread, self).__init__()
                                self.lock = lock
                                self.running = True
                            
                              def run(self):
                                while self.running:
                                  with self.lock:
                                    thread_vim_command('noautocmd normal! a')
                                  time.sleep(0.33)
                            
                              def stop(self):
                                self.running = False
                            
                            if G_NVIM:
                              def thread_vim_command(cmd):
                                vim.session.threadsafe_call(lambda: vim.command(cmd))
                            else:
                              def thread_vim_command(cmd):
                                vim.command(cmd)
                            
                            def esc(name):
                              return '"' + name.replace('"', '\"') + '"'
                            
                            def nonblock_read(fname):
                              """ Read a file with nonblock flag. Return the last line. """
                              fread = os.open(fname, os.O_RDONLY | os.O_NONBLOCK)
                              buf = os.read(fread, 100000).decode('utf-8', 'replace')
                              os.close(fread)
                            
                              line = buf.rstrip('\r\n')
                              left = max(line.rfind('\r'), line.rfind('\n'))
                              if left != -1:
                                left += 1
                                line = line[left:]
                            
                              return line
                            
                            def main():
                              thr.current_thread().name = 'main'
                              nthreads = int(vim.eval('s:update.threads'))
                              plugs = vim.eval('s:update.todo')
                              mac_gui = vim.eval('s:mac_gui') == '1'
                            
                              lock = thr.Lock()
                              buf = Buffer(lock, len(plugs), G_PULL)
                              buf_q, work_q = queue.Queue(), queue.Queue()
                              for work in plugs.items():
                                work_q.put(work)
                            
                              start_cnt = thr.active_count()
                              for num in range(nthreads):
                                tname = 'PlugT-{0:02}'.format(num)
                                thread = PlugThread(tname, (buf_q, work_q, lock))
                                thread.start()
                              if mac_gui:
                                rthread = RefreshThread(lock)
                                rthread.start()
                            
                              while not buf_q.empty() or thr.active_count() != start_cnt:
                                try:
                                  action, name, msg = buf_q.get(True, 0.25)
                                  buf.write(action, name, ['OK'] if not msg else msg)
                                  buf_q.task_done()
                                except queue.Empty:
                                  pass
                                except KeyboardInterrupt:
                                  G_STOP.set()
                            
                              if mac_gui:
                                rthread.stop()
                                rthread.join()
                            
                            main()
                            EOF
                            endfunction
                            
    1              0.000003 function! s:update_ruby()
                              ruby << EOF
                              module PlugStream
                                SEP = ["\r", "\n", nil]
                                def get_line
                                  buffer = ''
                                  loop do
                                    char = readchar rescue return
                                    if SEP.include? char.chr
                                      buffer << $/
                                      break
                                    else
                                      buffer << char
                                    end
                                  end
                                  buffer
                                end
                              end unless defined?(PlugStream)
                            
                              def esc arg
                                %["#{arg.gsub('"', '\"')}"]
                              end
                            
                              def killall pid
                                pids = [pid]
                                if /mswin|mingw|bccwin/ =~ RUBY_PLATFORM
                                  pids.each { |pid| Process.kill 'INT', pid.to_i rescue nil }
                                else
                                  unless `which pgrep 2> /dev/null`.empty?
                                    children = pids
                                    until children.empty?
                                      children = children.map { |pid|
                                        `pgrep -P #{pid}`.lines.map { |l| l.chomp }
                                      }.flatten
                                      pids += children
                                    end
                                  end
                                  pids.each { |pid| Process.kill 'TERM', pid.to_i rescue nil }
                                end
                              end
                            
                              def compare_git_uri a, b
                                regex = %r{^(?:\w+://)?(?:[^@/]*@)?([^:/]*(?::[0-9]*)?)[:/](.*?)(?:\.git)?/?$}
                                regex.match(a).to_a.drop(1) == regex.match(b).to_a.drop(1)
                              end
                            
                              require 'thread'
                              require 'fileutils'
                              require 'timeout'
                              running = true
                              iswin = VIM::evaluate('s:is_win').to_i == 1
                              pull  = VIM::evaluate('s:update.pull').to_i == 1
                              base  = VIM::evaluate('g:plug_home')
                              all   = VIM::evaluate('s:update.todo')
                              limit = VIM::evaluate('get(g:, "plug_timeout", 60)')
                              tries = VIM::evaluate('get(g:, "plug_retries", 2)') + 1
                              nthr  = VIM::evaluate('s:update.threads').to_i
                              maxy  = VIM::evaluate('winheight(".")').to_i
                              vim7  = VIM::evaluate('v:version').to_i <= 703 && RUBY_PLATFORM =~ /darwin/
                              cd    = iswin ? 'cd /d' : 'cd'
                              tot   = VIM::evaluate('len(s:update.todo)') || 0
                              bar   = ''
                              skip  = 'Already installed'
                              mtx   = Mutex.new
                              take1 = proc { mtx.synchronize { running && all.shift } }
                              logh  = proc {
                                cnt = bar.length
                                $curbuf[1] = "#{pull ? 'Updating' : 'Installing'} plugins (#{cnt}/#{tot})"
                                $curbuf[2] = '[' + bar.ljust(tot) + ']'
                                VIM::command('normal! 2G')
                                VIM::command('redraw')
                              }
                              where = proc { |name| (1..($curbuf.length)).find { |l| $curbuf[l] =~ /^[-+x*] #{name}:/ } }
                              log   = proc { |name, result, type|
                                mtx.synchronize do
                                  ing  = ![true, false].include?(type)
                                  bar += type ? '=' : 'x' unless ing
                                  b = case type
                                      when :install  then '+' when :update then '*'
                                      when true, nil then '-' else
                                        VIM::command("call add(s:update.errors, '#{name}')")
                                        'x'
                                      end
                                  result =
                                    if type || type.nil?
                                      ["#{b} #{name}: #{result.lines.to_a.last || 'OK'}"]
                                    elsif result =~ /^Interrupted|^Timeout/
                                      ["#{b} #{name}: #{result}"]
                                    else
                                      ["#{b} #{name}"] + result.lines.map { |l| "    " << l }
                                    end
                                  if lnum = where.call(name)
                                    $curbuf.delete lnum
                                    lnum = 4 if ing && lnum > maxy
                                  end
                                  result.each_with_index do |line, offset|
                                    $curbuf.append((lnum || 4) - 1 + offset, line.gsub(/\e\[./, '').chomp)
                                  end
                                  logh.call
                                end
                              }
                              bt = proc { |cmd, name, type, cleanup|
                                tried = timeout = 0
                                begin
                                  tried += 1
                                  timeout += limit
                                  fd = nil
                                  data = ''
                                  if iswin
                                    Timeout::timeout(timeout) do
                                      tmp = VIM::evaluate('tempname()')
                                      system("(#{cmd}) > #{tmp}")
                                      data = File.read(tmp).chomp
                                      File.unlink tmp rescue nil
                                    end
                                  else
                                    fd = IO.popen(cmd).extend(PlugStream)
                                    first_line = true
                                    log_prob = 1.0 / nthr
                                    while line = Timeout::timeout(timeout) { fd.get_line }
                                      data << line
                                      log.call name, line.chomp, type if name && (first_line || rand < log_prob)
                                      first_line = false
                                    end
                                    fd.close
                                  end
                                  [$? == 0, data.chomp]
                                rescue Timeout::Error, Interrupt => e
                                  if fd && !fd.closed?
                                    killall fd.pid
                                    fd.close
                                  end
                                  cleanup.call if cleanup
                                  if e.is_a?(Timeout::Error) && tried < tries
                                    3.downto(1) do |countdown|
                                      s = countdown > 1 ? 's' : ''
                                      log.call name, "Timeout. Will retry in #{countdown} second#{s} ...", type
                                      sleep 1
                                    end
                                    log.call name, 'Retrying ...', type
                                    retry
                                  end
                                  [false, e.is_a?(Interrupt) ? "Interrupted!" : "Timeout!"]
                                end
                              }
                              main = Thread.current
                              threads = []
                              watcher = Thread.new {
                                if vim7
                                  while VIM::evaluate('getchar(1)')
                                    sleep 0.1
                                  end
                                else
                                  require 'io/console' # >= Ruby 1.9
                                  nil until IO.console.getch == 3.chr
                                end
                                mtx.synchronize do
                                  running = false
                                  threads.each { |t| t.raise Interrupt } unless vim7
                                end
                                threads.each { |t| t.join rescue nil }
                                main.kill
                              }
                              refresh = Thread.new {
                                while true
                                  mtx.synchronize do
                                    break unless running
                                    VIM::command('noautocmd normal! a')
                                  end
                                  sleep 0.2
                                end
                              } if VIM::evaluate('s:mac_gui') == 1
                            
                              clone_opt = VIM::evaluate('s:clone_opt')
                              progress = VIM::evaluate('s:progress_opt(1)')
                              nthr.times do
                                mtx.synchronize do
                                  threads << Thread.new {
                                    while pair = take1.call
                                      name = pair.first
                                      dir, uri, tag = pair.last.values_at *%w[dir uri tag]
                                      exists = File.directory? dir
                                      ok, result =
                                        if exists
                                          chdir = "#{cd} #{iswin ? dir : esc(dir)}"
                                          ret, data = bt.call "#{chdir} && git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url", nil, nil, nil
                                          current_uri = data.lines.to_a.last
                                          if !ret
                                            if data =~ /^Interrupted|^Timeout/
                                              [false, data]
                                            else
                                              [false, [data.chomp, "PlugClean required."].join($/)]
                                            end
                                          elsif !compare_git_uri(current_uri, uri)
                                            [false, ["Invalid URI: #{current_uri}",
                                                     "Expected:    #{uri}",
                                                     "PlugClean required."].join($/)]
                                          else
                                            if pull
                                              log.call name, 'Updating ...', :update
                                              fetch_opt = (tag && File.exist?(File.join(dir, '.git/shallow'))) ? '--depth 99999999' : ''
                                              bt.call "#{chdir} && git fetch #{fetch_opt} #{progress} 2>&1", name, :update, nil
                                            else
                                              [true, skip]
                                            end
                                          end
                                        else
                                          d = esc dir.sub(%r{[\\/]+$}, '')
                                          log.call name, 'Installing ...', :install
                                          bt.call "git clone #{clone_opt unless tag} #{progress} #{uri} #{d} 2>&1", name, :install, proc {
                                            FileUtils.rm_rf dir
                                          }
                                        end
                                      mtx.synchronize { VIM::command("let s:update.new['#{name}'] = 1") } if !exists && ok
                                      log.call name, result, ok
                                    end
                                  } if running
                                end
                              end
                              threads.each { |t| t.join rescue nil }
                              logh.call
                              refresh.kill if refresh
                              watcher.kill
                            EOF
                            endfunction
                            
    1              0.000002 function! s:shellesc_cmd(arg)
                              let escaped = substitute(a:arg, '[&|<>()@^]', '^&', 'g')
                              let escaped = substitute(escaped, '%', '%%', 'g')
                              let escaped = substitute(escaped, '"', '\\^&', 'g')
                              let escaped = substitute(escaped, '\(\\\+\)\(\\^\)', '\1\1\2', 'g')
                              return '^"'.substitute(escaped, '\(\\\+\)$', '\1\1', '').'^"'
                            endfunction
                            
    1              0.000001 function! s:shellesc(arg)
                              if &shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
                              endif
                              return shellescape(a:arg)
                            endfunction
                            
    1              0.000001 function! s:glob_dir(path)
                              return map(filter(s:glob(a:path, '**'), 'isdirectory(v:val)'), 's:dirpath(v:val)')
                            endfunction
                            
    1              0.000002 function! s:progress_bar(line, bar, total)
                              call setline(a:line, '[' . s:lpad(a:bar, a:total) . ']')
                            endfunction
                            
    1              0.000001 function! s:compare_git_uri(a, b)
                              " See `git help clone'
                              " https:// [user@] github.com[:port] / junegunn/vim-plug [.git]
                              "          [git@]  github.com[:port] : junegunn/vim-plug [.git]
                              " file://                            / junegunn/vim-plug        [/]
                              "                                    / junegunn/vim-plug        [/]
                              let pat = '^\%(\w\+://\)\='.'\%([^@/]*@\)\='.'\([^:/]*\%(:[0-9]*\)\=\)'.'[:/]'.'\(.\{-}\)'.'\%(\.git\)\=/\?$'
                              let ma = matchlist(a:a, pat)
                              let mb = matchlist(a:b, pat)
                              return ma[1:2] ==# mb[1:2]
                            endfunction
                            
    1              0.000002 function! s:format_message(bullet, name, message)
                              if a:bullet != 'x'
                                return [printf('%s %s: %s', a:bullet, a:name, s:lastline(a:message))]
                              else
                                let lines = map(s:lines(a:message), '"    ".v:val')
                                return extend([printf('x %s:', a:name)], lines)
                              endif
                            endfunction
                            
    1              0.000001 function! s:with_cd(cmd, dir)
                              return printf('cd%s %s && %s', s:is_win ? ' /d' : '', s:shellesc(a:dir), a:cmd)
                            endfunction
                            
    1              0.000001 function! s:system(cmd, ...)
                              try
                                let [sh, shellcmdflag, shrd] = s:chsh(1)
                                let cmd = a:0 > 0 ? s:with_cd(a:cmd, a:1) : a:cmd
                                if s:is_win
                                  let batchfile = tempname().'.bat'
                                  call writefile(["@echo off\r", cmd . "\r"], batchfile)
                                  let cmd = batchfile
                                endif
                                return system(s:is_win ? '('.cmd.')' : cmd)
                              finally
                                let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                                if s:is_win
                                  call delete(batchfile)
                                endif
                              endtry
                            endfunction
                            
    1              0.000001 function! s:system_chomp(...)
                              let ret = call('s:system', a:000)
                              return v:shell_error ? '' : substitute(ret, '\n$', '', '')
                            endfunction
                            
    1              0.000002 function! s:git_validate(spec, check_branch)
                              let err = ''
                              if isdirectory(a:spec.dir)
                                let result = s:lines(s:system('git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url', a:spec.dir))
                                let remote = result[-1]
                                if v:shell_error
                                  let err = join([remote, 'PlugClean required.'], "\n")
                                elseif !s:compare_git_uri(remote, a:spec.uri)
                                  let err = join(['Invalid URI: '.remote,
                                                \ 'Expected:    '.a:spec.uri,
                                                \ 'PlugClean required.'], "\n")
                                elseif a:check_branch && has_key(a:spec, 'commit')
                                  let result = s:lines(s:system('git rev-parse HEAD 2>&1', a:spec.dir))
                                  let sha = result[-1]
                                  if v:shell_error
                                    let err = join(add(result, 'PlugClean required.'), "\n")
                                  elseif !s:hash_match(sha, a:spec.commit)
                                    let err = join([printf('Invalid HEAD (expected: %s, actual: %s)',
                                                          \ a:spec.commit[:6], sha[:6]),
                                                  \ 'PlugUpdate required.'], "\n")
                                  endif
                                elseif a:check_branch
                                  let branch = result[0]
                                  " Check tag
                                  if has_key(a:spec, 'tag')
                                    let tag = s:system_chomp('git describe --exact-match --tags HEAD 2>&1', a:spec.dir)
                                    if a:spec.tag !=# tag && a:spec.tag !~ '\*'
                                      let err = printf('Invalid tag: %s (expected: %s). Try PlugUpdate.',
                                            \ (empty(tag) ? 'N/A' : tag), a:spec.tag)
                                    endif
                                  " Check branch
                                  elseif a:spec.branch !=# branch
                                    let err = printf('Invalid branch: %s (expected: %s). Try PlugUpdate.',
                                          \ branch, a:spec.branch)
                                  endif
                                  if empty(err)
                                    let [ahead, behind] = split(s:lastline(s:system(printf(
                                          \ 'git rev-list --count --left-right HEAD...origin/%s',
                                          \ a:spec.branch), a:spec.dir)), '\t')
                                    if !v:shell_error && ahead
                                      if behind
                                        " Only mention PlugClean if diverged, otherwise it's likely to be
                                        " pushable (and probably not that messed up).
                                        let err = printf(
                                              \ "Diverged from origin/%s (%d commit(s) ahead and %d commit(s) behind!\n"
                                              \ .'Backup local changes and run PlugClean and PlugUpdate to reinstall it.', a:spec.branch, ahead, behind)
                                      else
                                        let err = printf("Ahead of origin/%s by %d commit(s).\n"
                                              \ .'Cannot update until local changes are pushed.',
                                              \ a:spec.branch, ahead)
                                      endif
                                    endif
                                  endif
                                endif
                              else
                                let err = 'Not found'
                              endif
                              return [err, err =~# 'PlugClean']
                            endfunction
                            
    1              0.000001 function! s:rm_rf(dir)
                              if isdirectory(a:dir)
                                call s:system((s:is_win ? 'rmdir /S /Q ' : 'rm -rf ') . s:shellesc(a:dir))
                              endif
                            endfunction
                            
    1              0.000001 function! s:clean(force)
                              call s:prepare()
                              call append(0, 'Searching for invalid plugins in '.g:plug_home)
                              call append(1, '')
                            
                              " List of valid directories
                              let dirs = []
                              let errs = {}
                              let [cnt, total] = [0, len(g:plugs)]
                              for [name, spec] in items(g:plugs)
                                if !s:is_managed(name)
                                  call add(dirs, spec.dir)
                                else
                                  let [err, clean] = s:git_validate(spec, 1)
                                  if clean
                                    let errs[spec.dir] = s:lines(err)[0]
                                  else
                                    call add(dirs, spec.dir)
                                  endif
                                endif
                                let cnt += 1
                                call s:progress_bar(2, repeat('=', cnt), total)
                                normal! 2G
                                redraw
                              endfor
                            
                              let allowed = {}
                              for dir in dirs
                                let allowed[s:dirpath(fnamemodify(dir, ':h:h'))] = 1
                                let allowed[dir] = 1
                                for child in s:glob_dir(dir)
                                  let allowed[child] = 1
                                endfor
                              endfor
                            
                              let todo = []
                              let found = sort(s:glob_dir(g:plug_home))
                              while !empty(found)
                                let f = remove(found, 0)
                                if !has_key(allowed, f) && isdirectory(f)
                                  call add(todo, f)
                                  call append(line('$'), '- ' . f)
                                  if has_key(errs, f)
                                    call append(line('$'), '    ' . errs[f])
                                  endif
                                  let found = filter(found, 'stridx(v:val, f) != 0')
                                end
                              endwhile
                            
                              4
                              redraw
                              if empty(todo)
                                call append(line('$'), 'Already clean.')
                              else
                                let s:clean_count = 0
                                call append(3, ['Directories to delete:', ''])
                                redraw!
                                if a:force || s:ask_no_interrupt('Delete all directories?')
                                  call s:delete([6, line('$')], 1)
                                else
                                  call setline(4, 'Cancelled.')
                                  nnoremap <silent> <buffer> d :set opfunc=<sid>delete_op<cr>g@
                                  nmap     <silent> <buffer> dd d_
                                  xnoremap <silent> <buffer> d :<c-u>call <sid>delete_op(visualmode(), 1)<cr>
                                  echo 'Delete the lines (d{motion}) to delete the corresponding directories'
                                endif
                              endif
                              4
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000001 function! s:delete_op(type, ...)
                              call s:delete(a:0 ? [line("'<"), line("'>")] : [line("'["), line("']")], 0)
                            endfunction
                            
    1              0.000001 function! s:delete(range, force)
                              let [l1, l2] = a:range
                              let force = a:force
                              while l1 <= l2
                                let line = getline(l1)
                                if line =~ '^- ' && isdirectory(line[2:])
                                  execute l1
                                  redraw!
                                  let answer = force ? 1 : s:ask('Delete '.line[2:].'?', 1)
                                  let force = force || answer > 1
                                  if answer
                                    call s:rm_rf(line[2:])
                                    setlocal modifiable
                                    call setline(l1, '~'.line[1:])
                                    let s:clean_count += 1
                                    call setline(4, printf('Removed %d directories.', s:clean_count))
                                    setlocal nomodifiable
                                  endif
                                endif
                                let l1 += 1
                              endwhile
                            endfunction
                            
    1              0.000008 function! s:upgrade()
                              echo 'Downloading the latest version of vim-plug'
                              redraw
                              let tmp = tempname()
                              let new = tmp . '/plug.vim'
                            
                              try
                                let out = s:system(printf('git clone --depth 1 %s %s', s:plug_src, tmp))
                                if v:shell_error
                                  return s:err('Error upgrading vim-plug: '. out)
                                endif
                            
                                if readfile(s:me) ==# readfile(new)
                                  echo 'vim-plug is already up-to-date'
                                  return 0
                                else
                                  call rename(s:me, s:me . '.old')
                                  call rename(new, s:me)
                                  unlet g:loaded_plug
                                  echo 'vim-plug has been upgraded'
                                  return 1
                                endif
                              finally
                                silent! call s:rm_rf(tmp)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:upgrade_specs()
                              for spec in values(g:plugs)
                                let spec.frozen = get(spec, 'frozen', 0)
                              endfor
                            endfunction
                            
    1              0.000001 function! s:status()
                              call s:prepare()
                              call append(0, 'Checking plugins')
                              call append(1, '')
                            
                              let ecnt = 0
                              let unloaded = 0
                              let [cnt, total] = [0, len(g:plugs)]
                              for [name, spec] in items(g:plugs)
                                let is_dir = isdirectory(spec.dir)
                                if has_key(spec, 'uri')
                                  if is_dir
                                    let [err, _] = s:git_validate(spec, 1)
                                    let [valid, msg] = [empty(err), empty(err) ? 'OK' : err]
                                  else
                                    let [valid, msg] = [0, 'Not found. Try PlugInstall.']
                                  endif
                                else
                                  if is_dir
                                    let [valid, msg] = [1, 'OK']
                                  else
                                    let [valid, msg] = [0, 'Not found.']
                                  endif
                                endif
                                let cnt += 1
                                let ecnt += !valid
                                " `s:loaded` entry can be missing if PlugUpgraded
                                if is_dir && get(s:loaded, name, -1) == 0
                                  let unloaded = 1
                                  let msg .= ' (not loaded)'
                                endif
                                call s:progress_bar(2, repeat('=', cnt), total)
                                call append(3, s:format_message(valid ? '-' : 'x', name, msg))
                                normal! 2G
                                redraw
                              endfor
                              call setline(1, 'Finished. '.ecnt.' error(s).')
                              normal! gg
                              setlocal nomodifiable
                              if unloaded
                                echo "Press 'L' on each line to load plugin, or 'U' to update"
                                nnoremap <silent> <buffer> L :call <SID>status_load(line('.'))<cr>
                                xnoremap <silent> <buffer> L :call <SID>status_load(line('.'))<cr>
                              end
                            endfunction
                            
    1              0.000002 function! s:extract_name(str, prefix, suffix)
                              return matchstr(a:str, '^'.a:prefix.' \zs[^:]\+\ze:.*'.a:suffix.'$')
                            endfunction
                            
    1              0.000003 function! s:status_load(lnum)
                              let line = getline(a:lnum)
                              let name = s:extract_name(line, '-', '(not loaded)')
                              if !empty(name)
                                call plug#load(name)
                                setlocal modifiable
                                call setline(a:lnum, substitute(line, ' (not loaded)$', '', ''))
                                setlocal nomodifiable
                              endif
                            endfunction
                            
    1              0.000001 function! s:status_update() range
                              let lines = getline(a:firstline, a:lastline)
                              let names = filter(map(lines, 's:extract_name(v:val, "[x-]", "")'), '!empty(v:val)')
                              if !empty(names)
                                echo
                                execute 'PlugUpdate' join(names)
                              endif
                            endfunction
                            
    1              0.000001 function! s:is_preview_window_open()
                              silent! wincmd P
                              if &previewwindow
                                wincmd p
                                return 1
                              endif
                            endfunction
                            
    1              0.000001 function! s:find_name(lnum)
                              for lnum in reverse(range(1, a:lnum))
                                let line = getline(lnum)
                                if empty(line)
                                  return ''
                                endif
                                let name = s:extract_name(line, '-', '')
                                if !empty(name)
                                  return name
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:preview_commit()
                              if b:plug_preview < 0
                                let b:plug_preview = !s:is_preview_window_open()
                              endif
                            
                              let sha = matchstr(getline('.'), '^  \X*\zs[0-9a-f]\{7,9}')
                              if empty(sha)
                                return
                              endif
                            
                              let name = s:find_name(line('.'))
                              if empty(name) || !has_key(g:plugs, name) || !isdirectory(g:plugs[name].dir)
                                return
                              endif
                            
                              if exists('g:plug_pwindow') && !s:is_preview_window_open()
                                execute g:plug_pwindow
                                execute 'e' sha
                              else
                                execute 'pedit' sha
                                wincmd P
                              endif
                              setlocal previewwindow filetype=git buftype=nofile nobuflisted modifiable
                              try
                                let [sh, shellcmdflag, shrd] = s:chsh(1)
                                let cmd = 'cd '.s:shellesc(g:plugs[name].dir).' && git show --no-color --pretty=medium '.sha
                                if s:is_win
                                  let batchfile = tempname().'.bat'
                                  call writefile(["@echo off\r", cmd . "\r"], batchfile)
                                  let cmd = batchfile
                                endif
                                execute 'silent %!' cmd
                              finally
                                let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                                if s:is_win
                                  call delete(batchfile)
                                endif
                              endtry
                              setlocal nomodifiable
                              nnoremap <silent> <buffer> q :q<cr>
                              wincmd p
                            endfunction
                            
    1              0.000001 function! s:section(flags)
                              call search('\(^[x-] \)\@<=[^:]\+:', a:flags)
                            endfunction
                            
    1              0.000001 function! s:format_git_log(line)
                              let indent = '  '
                              let tokens = split(a:line, nr2char(1))
                              if len(tokens) != 5
                                return indent.substitute(a:line, '\s*$', '', '')
                              endif
                              let [graph, sha, refs, subject, date] = tokens
                              let tag = matchstr(refs, 'tag: [^,)]\+')
                              let tag = empty(tag) ? ' ' : ' ('.tag.') '
                              return printf('%s%s%s%s%s (%s)', indent, graph, sha, tag, subject, date)
                            endfunction
                            
    1              0.000002 function! s:append_ul(lnum, text)
                              call append(a:lnum, ['', a:text, repeat('-', len(a:text))])
                            endfunction
                            
    1              0.000001 function! s:diff()
                              call s:prepare()
                              call append(0, ['Collecting changes ...', ''])
                              let cnts = [0, 0]
                              let bar = ''
                              let total = filter(copy(g:plugs), 's:is_managed(v:key) && isdirectory(v:val.dir)')
                              call s:progress_bar(2, bar, len(total))
                              for origin in [1, 0]
                                let plugs = reverse(sort(items(filter(copy(total), (origin ? '' : '!').'(has_key(v:val, "commit") || has_key(v:val, "tag"))'))))
                                if empty(plugs)
                                  continue
                                endif
                                call s:append_ul(2, origin ? 'Pending updates:' : 'Last update:')
                                for [k, v] in plugs
                                  let range = origin ? '..origin/'.v.branch : 'HEAD@{1}..'
                                  let diff = s:system_chomp('git log --graph --color=never '.join(map(['--pretty=format:%x01%h%x01%d%x01%s%x01%cr', range], 's:shellesc(v:val)')), v.dir)
                                  if !empty(diff)
                                    let ref = has_key(v, 'tag') ? (' (tag: '.v.tag.')') : has_key(v, 'commit') ? (' '.v.commit) : ''
                                    call append(5, extend(['', '- '.k.':'.ref], map(s:lines(diff), 's:format_git_log(v:val)')))
                                    let cnts[origin] += 1
                                  endif
                                  let bar .= '='
                                  call s:progress_bar(2, bar, len(total))
                                  normal! 2G
                                  redraw
                                endfor
                                if !cnts[origin]
                                  call append(5, ['', 'N/A'])
                                endif
                              endfor
                              call setline(1, printf('%d plugin(s) updated.', cnts[0])
                                    \ . (cnts[1] ? printf(' %d plugin(s) have pending updates.', cnts[1]) : ''))
                            
                              if cnts[0] || cnts[1]
                                nnoremap <silent> <buffer> <plug>(plug-preview) :silent! call <SID>preview_commit()<cr>
                                if empty(maparg("\<cr>", 'n'))
                                  nmap <buffer> <cr> <plug>(plug-preview)
                                endif
                                if empty(maparg('o', 'n'))
                                  nmap <buffer> o <plug>(plug-preview)
                                endif
                              endif
                              if cnts[0]
                                nnoremap <silent> <buffer> X :call <SID>revert()<cr>
                                echo "Press 'X' on each block to revert the update"
                              endif
                              normal! gg
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000001 function! s:revert()
                              if search('^Pending updates', 'bnW')
                                return
                              endif
                            
                              let name = s:find_name(line('.'))
                              if empty(name) || !has_key(g:plugs, name) ||
                                \ input(printf('Revert the update of %s? (y/N) ', name)) !~? '^y'
                                return
                              endif
                            
                              call s:system('git reset --hard HEAD@{1} && git checkout '.s:esc(g:plugs[name].branch).' --', g:plugs[name].dir)
                              setlocal modifiable
                              normal! "_dap
                              setlocal nomodifiable
                              echo 'Reverted'
                            endfunction
                            
    1              0.000001 function! s:snapshot(force, ...) abort
                              call s:prepare()
                              setf vim
                              call append(0, ['" Generated by vim-plug',
                                            \ '" '.strftime("%c"),
                                            \ '" :source this file in vim to restore the snapshot',
                                            \ '" or execute: vim -S snapshot.vim',
                                            \ '', '', 'PlugUpdate!'])
                              1
                              let anchor = line('$') - 3
                              let names = sort(keys(filter(copy(g:plugs),
                                    \'has_key(v:val, "uri") && !has_key(v:val, "commit") && isdirectory(v:val.dir)')))
                              for name in reverse(names)
                                let sha = s:system_chomp('git rev-parse --short HEAD', g:plugs[name].dir)
                                if !empty(sha)
                                  call append(anchor, printf("silent! let g:plugs['%s'].commit = '%s'", name, sha))
                                  redraw
                                endif
                              endfor
                            
                              if a:0 > 0
                                let fn = expand(a:1)
                                if filereadable(fn) && !(a:force || s:ask(a:1.' already exists. Overwrite?'))
                                  return
                                endif
                                call writefile(getline(1, '$'), fn)
                                echo 'Saved as '.a:1
                                silent execute 'e' s:esc(fn)
                                setf vim
                              endif
                            endfunction
                            
    1              0.000001 function! s:split_rtp()
                              return split(&rtp, '\\\@<!,')
                            endfunction
                            
    1   0.000109   0.000032 let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))
    1   0.000062   0.000010 let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))
                            
    1              0.000002 if exists('g:plugs')
                              let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))
                              call s:upgrade_specs()
                              call s:define_commands()
                            endif
                            
    1              0.000005 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/filetype.vim
Sourced 1 time
Total time:   0.006808
 Self time:   0.006772

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2018 Feb 14
                            
                            " Listen very carefully, I will say this only once
    1              0.000004 if exists("did_load_filetypes")
                              finish
                            endif
    1              0.000002 let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000004 let s:cpo_save = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000001 augroup filetypedetect
                            
                            " Ignored extensions
    1              0.000003 if exists("*fnameescape")
    1              0.000056 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    1              0.000010 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    1              0.000006 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
    1              0.000001 elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    1              0.000003 if !exists("g:ft_ignore_pat")
    1              0.000002   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
    1              0.000001 endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
    1              0.000002 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Vim help file
    1              0.000016 au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt setf help
                            
                            " Abaqus or Trasys
    1              0.000005 au BufNewFile,BufRead *.inp			call dist#ft#Check_inp()
                            
                            " A-A-P recipe
    1              0.000004 au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
    1              0.000021 au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
    1              0.000004 au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
    1              0.000004 au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
    1              0.000004 au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
    1              0.000014 au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
    1              0.000011 au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
    1              0.000004 au BufNewFile,BufRead *.gpr			setf ada
                            
                            " AHDL
    1              0.000003 au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
    1              0.000003 au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
    1              0.000009 au BufNewFile,BufRead build.xml			setf ant
                            
                            " Arduino
    1              0.000006 au BufNewFile,BufRead *.ino,*.pde		setf arduino
                            
                            " Apache style config file
    1              0.000008 au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
    1              0.000012 au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " XA65 MOS6510 cross assembler
    1              0.000004 au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
    1              0.000004 au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
    1              0.000005 au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
    1              0.000017 au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
    1              0.000007 au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
    1              0.000005 au BufNewFile,BufRead apt.conf		       setf aptconf
    1              0.000005 au BufNewFile,BufRead */.aptitude/config       setf aptconf
    1              0.000019 au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
    1              0.000012 au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
    1              0.000004 au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
    1              0.000017 au BufNewFile,BufRead *.asciidoc,*.adoc		setf asciidoc
                            
                            " ASN.1
    1              0.000009 au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
    1              0.000006 au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
    1              0.000009 au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
    1              0.000017 au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
    1              0.000016 au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call dist#ft#FTasm()
                            
                            " Macro (VAX)
    1              0.000004 au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
    1              0.000011 au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
    1              0.000004 au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
    1              0.000004 au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
    1              0.000012 au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
    1              0.000006 au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
    1              0.000004 au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
    1              0.000003 au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
    1              0.000010 au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
    1              0.000004 au BufNewFile,BufRead *.bas			call dist#ft#FTVB("basic")
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
    1              0.000013 au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
    1              0.000008 au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
    1              0.000006 au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
    1              0.000008 au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    1              0.000005 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    1              0.000004 au BufNewFile,BufRead *.btm			call dist#ft#FTbtm()
                            
                            " BC calculator
    1              0.000004 au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
    1              0.000006 au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
    1              0.000003 au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
    1              0.000003 au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
                            " sudoedit uses namedXXXX.conf
    1              0.000017 au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key	setf named
                            
                            " BIND zone
    1              0.000005 au BufNewFile,BufRead named.root		setf bindzone
    1              0.000004 au BufNewFile,BufRead *.db			call dist#ft#BindzoneCheck('')
                            
                            " Blank
    1              0.000003 au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
    1              0.000012 au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " Bazel (http://bazel.io)
    1              0.000010 autocmd BufRead,BufNewFile *.bzl,WORKSPACE 	setf bzl
    1              0.000003 if has("fname_case")
                              " There is another check for BUILD further below.
    1              0.000004   autocmd BufRead,BufNewFile BUILD		setf bzl
    1              0.000001 endif
                            
                            " C or lpc
    1              0.000007 au BufNewFile,BufRead *.c			call dist#ft#FTlpc()
                            
                            " Calendar
    1              0.000005 au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
    1              0.000004 au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
    1              0.000006 au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
    1              0.000007 au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
    1              0.000004 au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
    1              0.000022 au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
    1              0.000005 au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
    1              0.000004 au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
    1              0.000004 au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
    1              0.000007 au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
    1              0.000004 au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
    1              0.000004 au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    1              0.000009 au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
    1              0.000005 au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
    1              0.000025 au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
    1              0.000002 if has("fname_case")
    1              0.000008   au BufNewFile,BufRead *.C,*.H setf cpp
    1              0.000001 endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
    1              0.000004 au BufNewFile,BufRead *.h			call dist#ft#FTheader()
                            
                            " Ch (CHscript)
    1              0.000004 au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
    1              0.000004 au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
    1              0.000007 au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
    1              0.000004 au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
    1              0.000022 au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
    1              0.000009 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    1              0.000008 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
    1              0.000004 au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
    1              0.000004 au BufNewFile,BufRead *.ch			call dist#ft#FTchange()
                            
                            " ChordPro
    1              0.000019 au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
    1              0.000006 au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
    1              0.000003 au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
    1              0.000006 au BufNewFile,BufRead *.ent			call dist#ft#FTent()
                            
                            " Clipper (or FoxPro; could also be eviews)
    1              0.000007 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
    1              0.000013 au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc		setf clojure
                            
                            " Cmake
    1              0.000014 au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
    1              0.000015 au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
    1              0.000006 au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
    1              0.000011 au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
    1              0.000006 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
    1              0.000004 au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
    1              0.000011 au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
    1              0.000013 au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
    1              0.000004 au BufNewFile,BufRead *.cu			setf cuda
                            
                            " Dockerfile
    1              0.000011 au BufNewFile,BufRead Dockerfile,*.Dockerfile	setf dockerfile
                            
                            " WildPackets EtherPeek Decoder
    1              0.000004 au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
    1              0.000006 au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
    1              0.000008 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Euphoria 3 or 4
    1              0.000018 au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()
    1              0.000002 if has("fname_case")
    1              0.000015    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
    1              0.000001 endif
                            
                            " Lynx config files
    1              0.000007 au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
    1              0.000010 au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
    1              0.000008 au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
    1              0.000004 au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
    1              0.000004 au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
    1              0.000007 au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
    1              0.000006 au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
    1              0.000003 au BufNewFile,BufRead *.pld			setf cupl
    1              0.000006 au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
    1              0.000005 au BufNewFile,BufRead */debian/control		setf debcontrol
    1              0.000008 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Sources.list
    1              0.000009 au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
    1              0.000008 au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
    1              0.000005 au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
    1              0.000008 au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
    1              0.000006 au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
    1              0.000004 au BufNewFile,BufRead *.d			call dist#ft#DtraceCheck()
                            
                            " Desktop files
    1              0.000011 au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
    1              0.000010 au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
    1              0.000005 au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
    1              0.000009 au BufNewFile,BufRead *.diff,*.rej		setf diff
    1              0.000006 au BufNewFile,BufRead *.patch
                            	\ if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |
                            	\   setf gitsendemail |
                            	\ else |
                            	\   setf diff |
                            	\ endif
                            
                            " Dircolors
    1              0.000015 au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
    1              0.000010 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    1              0.000004 au BufNewFile,BufRead *.com			call dist#ft#BindzoneCheck('dcl')
                            
                            " DOT
    1              0.000004 au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
    1              0.000003 au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
    1              0.000007 au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
    1              0.000004 au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
    1              0.000003 au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
    1              0.000013 au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
    1              0.000006 au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
    1              0.000004 au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
    1              0.000003 au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
    1              0.000009 au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
    1              0.000006 au BufNewFile,BufRead *.ed\(f\|if\|o\)		setf edif
    1              0.000006 au BufNewFile,BufRead *.edn
                            	\ if getline(1) =~ '^\s*(\s*edif\>' |
                            	\   setf edif |
                            	\ else |
                            	\   setf clojure |
                            	\ endif
                            
                            " EditorConfig (close enough to dosini)
    1              0.000008 au BufNewFile,BufRead .editorconfig		setf dosini
                            
                            " Embedix Component Description
    1              0.000004 au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman or Euphoria
    1              0.000006 au BufNewFile,BufRead *.e,*.E			call dist#ft#FTe()
                            
                            " Elinks configuration
    1              0.000013 au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
                            " ERicsson LANGuage; Yaws is erlang too
    1              0.000011 au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
    1              0.000005 au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
    1              0.000007 au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
    1              0.000006 au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
    1              0.000004 au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
    1              0.000006 au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
    1              0.000005 au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
    1              0.000004 au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
    1              0.000007 au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
    1              0.000004 au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
    1              0.000006 au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
    1              0.000007 au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
    1              0.000005 au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
    1              0.000009 au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
    1              0.000005 au BufNewFile,BufRead auto.master		setf conf
    1              0.000009 au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
    1              0.000006 au BufNewFile,BufRead *.fs,*.ft			setf forth
                            
                            " Reva Forth
    1              0.000004 au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
    1              0.000002 if has("fname_case")
    1              0.000028   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
    1              0.000001 endif
    1              0.000029 au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
    1              0.000006 au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
    1              0.000007 au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
    1              0.000007 au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
    1              0.000008 au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
    1              0.000010 au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
    1              0.000014 au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG setf gitcommit
    1              0.000014 au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
    1              0.000006 au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
    1              0.000008 au BufNewFile,BufRead */.config/git/config	setf gitconfig
    1              0.000004 if !empty($XDG_CONFIG_HOME)
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config	setf gitconfig
                            endif
    1              0.000005 au BufNewFile,BufRead git-rebase-todo		setf gitrebase
    1              0.000009 au BufRead,BufNewFile .gitsendemail.msg.??????	setf gitsendemail
    1              0.000006 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    1              0.000006 au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
    1              0.000010 au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
    1              0.000007 au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
    1              0.000007 au BufNewFile,BufRead */.gnupg/options		setf gpg
    1              0.000010 au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
    1              0.000007 au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
    1              0.000003 if !empty($GNUPGHOME)
                              au BufNewFile,BufRead $GNUPGHOME/options	setf gpg
                              au BufNewFile,BufRead $GNUPGHOME/gpg.conf	setf gpg
                            endif
                            
                            " gnash(1) configuration files
    1              0.000017 au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
    1              0.000008 au BufNewFile,BufRead gitolite.conf		setf gitolite
    1              0.000007 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
    1              0.000010 au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
    1              0.000006 au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " Go (Google)
    1              0.000004 au BufNewFile,BufRead *.go			setf go
                            
                            " GrADS scripts
    1              0.000004 au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
    1              0.000004 au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
    1              0.000009 au BufNewFile,BufRead *.gradle,*.groovy		setf groovy
                            
                            " GNU Server Pages
    1              0.000004 au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
    1              0.000050 au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
    1              0.000009 au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
    1              0.000004 au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
    1              0.000006 au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
    1              0.000010 au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
    1              0.000004 au BufNewFile,BufRead *.lhs			setf lhaskell
    1              0.000006 au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
    1              0.000004 au BufNewFile,BufRead *.ht			setf haste
    1              0.000004 au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
    1              0.000013 au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
    1              0.000008 au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
    1              0.000004 au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
    1              0.000015 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
                            
                            " HTML with Ruby - eRuby
    1              0.000009 au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
    1              0.000005 au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
    1              0.000004 au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
    1              0.000008 au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
    1              0.000011 au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
    1              0.000004 au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
    1              0.000015 au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
    1              0.000004 au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
    1              0.000004 au BufNewFile,BufRead *.idl			call dist#ft#FTidl()
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
    1              0.000008 au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
    1              0.000005 au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
    1              0.000005 au BufNewFile,BufRead .indent.pro		setf indent
    1              0.000007 au BufNewFile,BufRead indent.pro		call dist#ft#ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    1              0.000004 au BufNewFile,BufRead *.pro			call dist#ft#ProtoCheck('idlang')
                            
                            " Indent RC
    1              0.000006 au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
    1              0.000006 au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
    1              0.000011 au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
    1              0.000016 au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
    1              0.000029 au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c 	setf upstreamlog
    1              0.000015 au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
    1              0.000015 au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
    1              0.000017 au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog
                            
                            " Ipfilter
    1              0.000013 au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
    1              0.000011 au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
    1              0.000004 au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
    1              0.000004 au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
    1              0.000006 au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
    1              0.000004 au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
    1              0.000006 au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
    1              0.000008 au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
    1              0.000006 au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
    1              0.000009 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
    1              0.000017 au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript
                            
                            " Java Server Pages
    1              0.000006 au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    1              0.000017 au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
    1              0.000008 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
    1              0.000004 au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
    1              0.000003 au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
    1              0.000011 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " JSON
    1              0.000013 au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest	setf json
                            
                            " Kixtart
    1              0.000004 au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
    1              0.000003 au BufNewFile,BufRead *.k			setf kwt
                            
                            " Kivy
    1              0.000006 au BufNewFile,BufRead *.kv			setf kivy
                            
                            " KDE script
    1              0.000004 au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
    1              0.000010 au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
    1              0.000006 au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
    1              0.000009 au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
    1              0.000017 au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
    1              0.000004 au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
    1              0.000004 au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
    1              0.000004 au BufNewFile,BufRead *.ld			setf ld
                            
                            " Less
    1              0.000006 au BufNewFile,BufRead *.less			setf less
                            
                            " Lex
    1              0.000013 au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
                            
                            " Libao
    1              0.000011 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
    1              0.000013 au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
    1              0.000013 au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
    1              0.000006 au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
    1              0.000004 au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
    1              0.000002 if has("fname_case")
    1              0.000026   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
    1              0.000001 else
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
                            endif
                            
                            " SBCL implementation of Common Lisp
    1              0.000010 au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
    1              0.000004 au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
    1              0.000009 au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
    1              0.000008 au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
    1              0.000006 au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
    1              0.000007 au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
    1              0.000004 au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
    1              0.000006 au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
    1              0.000009 au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
    1              0.000004 au BufNewFile,BufRead *.lua			setf lua
                            
                            " Luarocks
    1              0.000007 au BufNewFile,BufRead *.rockspec		setf lua
                            
                            " Linden Scripting Language (Second Life)
    1              0.000004 au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
    1              0.000004 au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
    1              0.000005 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
    1              0.000006 au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
    1              0.000068 au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
    1              0.000012 au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
    1              0.000010 au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
    1              0.000015 au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
    1              0.000006 au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
    1              0.000006 au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
    1              0.000004 au BufNewFile,BufRead *.man			setf nroff
                            
                            " Man config
    1              0.000011 au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
    1              0.000011 au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
    1              0.000004 au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
    1              0.000021 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
                            
                            " Mason
    1              0.000009 au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
                            
                            " Mathematica, Matlab, Murphi or Objective C
    1              0.000006 au BufNewFile,BufRead *.m			call dist#ft#FTm()
                            
                            " Mathematica notebook
    1              0.000004 au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
    1              0.000004 au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
    1              0.000008 au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
    1              0.000007 au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
    1              0.000023 au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
    1              0.000006 au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
    1              0.000004 au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
    1              0.000004 au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MIX - Knuth assembly
    1              0.000009 au BufNewFile,BufRead *.mix,*.mixal		setf mix
                            
                            " MMIX or VMS makefile
    1              0.000004 au BufNewFile,BufRead *.mms			call dist#ft#FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
    1              0.000005 au BufNewFile,BufRead *.mmp			setf mmp
                            
                            " Modsim III (or LambdaProlog)
    1              0.000008 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2  (.md removed in favor of Markdown)
    1              0.000013 au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
    1              0.000005 au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
    1              0.000013 au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
    1              0.000004 au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
    1              0.000018 au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
    1              0.000012 au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Motorola S record
    1              0.000015 au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec
                            
                            " Mrxvtrc
    1              0.000012 au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
    1              0.000004 au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
    1              0.000004 au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
    1              0.000008 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
    1              0.000006 au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
    1              0.000004 au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
    1              0.000007 au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
    1              0.000005 au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " N1QL
    1              0.000009 au BufRead,BufNewfile *.n1ql,*.nql		setf n1ql
                            
                            " Nano
    1              0.000008 au BufNewFile,BufRead */etc/nanorc,*.nanorc  	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
    1              0.000008 au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Noemutt setup file
    1              0.000004 au BufNewFile,BufRead Neomuttrc			setf neomuttrc
                            
                            " Netrc
    1              0.000007 au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
    1              0.000004 au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
    1              0.000004 au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    1              0.000005 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    1              0.000018 au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
    1              0.000004 au BufNewFile,BufRead *.[1-9]			call dist#ft#FTnroff()
                            
                            " Nroff or Objective C++
    1              0.000004 au BufNewFile,BufRead *.mm			call dist#ft#FTmm()
                            
                            " Not Quite C
    1              0.000004 au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSE - Nmap Script Engine - uses Lua syntax
    1              0.000006 au BufNewFile,BufRead *.nse			setf lua
                            
                            " NSIS
    1              0.000006 au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCAML
    1              0.000018 au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
    1              0.000004 au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
    1              0.000006 au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
    1              0.000006 au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
    1              0.000005 au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
    1              0.000004 au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
    1              0.000007 au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
    1              0.000005 au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
    1              0.000011 au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
    1              0.000039 au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
    1              0.000004 au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
    1              0.000004 au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
    1              0.000006 au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " PCMK - HAE - crm configure edit 
    1              0.000004 au BufNewFile,BufRead *.pcmk 			setf pcmk
                            
                            " Perl
    1              0.000002 if has("fname_case")
    1              0.000006   au BufNewFile,BufRead *.pl,*.PL		call dist#ft#FTpl()
    1              0.000001 else
                              au BufNewFile,BufRead *.pl			call dist#ft#FTpl()
                            endif
    1              0.000012 au BufNewFile,BufRead *.plx,*.al,*.psgi		setf perl
    1              0.000011 au BufNewFile,BufRead *.p6,*.pm6,*.pl6		setf perl6
                            
                            " Perl, XPM or XPM2
    1              0.000006 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
    1              0.000004 au BufNewFile,BufRead *.pod			setf pod
    1              0.000006 au BufNewFile,BufRead *.pod6			setf pod6
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
    1              0.000013 au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike
    1              0.000013 au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
                            
                            " Pinfo config
    1              0.000010 au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
    1              0.000004 au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
    1              0.000015 au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/1, PL/I
    1              0.000008 au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
    1              0.000010 au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
    1              0.000006 au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
    1              0.000003 au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
    1              0.000009 au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
    1              0.000004 au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
    1              0.000021 au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
    1              0.000004 au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
    1              0.000006 au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
    1              0.000005 au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
    1              0.000004 au BufNewFile,BufRead *.inc			call dist#ft#FTinc()
                            
                            " Printcap and Termcap
    1              0.000007 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    1              0.000005 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
    1              0.000004 au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
    1              0.000008 au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
    1              0.000004 au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
    1              0.000004 au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
    1              0.000004 au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
    1              0.000010 au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
    1              0.000004 au BufNewFile,BufRead *.w			call dist#ft#FTprogress_cweb()
                            
                            " Progress or assembly
    1              0.000006 au BufNewFile,BufRead *.i			call dist#ft#FTprogress_asm()
                            
                            " Progress or Pascal
    1              0.000004 au BufNewFile,BufRead *.p			call dist#ft#FTprogress_pascal()
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    1              0.000004 au BufNewFile,BufRead *.psf			setf psf
    1              0.000011 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
    1              0.000004 au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
    1              0.000003 au BufNewFile,BufRead *.pml			setf promela
                            
                            " Google protocol buffers
    1              0.000006 au BufNewFile,BufRead *.proto			setf proto
                            
                            " Protocols
    1              0.000005 au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
    1              0.000008 au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python, Python Shell Startup Files
                            " Quixote (Python-based web framework)
    1              0.000018 au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl  setf python
                            
                            " Radiance
    1              0.000008 au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
    1              0.000011 au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
    1              0.000004 au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
    1              0.000010 au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
    1              0.000007 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
    1              0.000003 au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
    1              0.000031 au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R (Splus)
    1              0.000002 if has("fname_case")
    1              0.000006   au BufNewFile,BufRead *.s,*.S			setf r
    1              0.000001 else
                              au BufNewFile,BufRead *.s			setf r
                            endif
                            
                            " R Help file
    1              0.000001 if has("fname_case")
    1              0.000009   au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
    1              0.000001 else
                              au BufNewFile,BufRead *.rd			setf rhelp
                            endif
                            
                            " R noweb file
    1              0.000002 if has("fname_case")
    1              0.000020   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
    1              0.000001 else
                              au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
                            endif
                            
                            " R Markdown file
    1              0.000002 if has("fname_case")
    1              0.000088   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
    1              0.000002 else
                              au BufNewFile,BufRead *.rmd,*.smd			setf rmd
                            endif
                            
                            " R reStructuredText file
    1              0.000003 if has("fname_case")
    1              0.000015   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
    1              0.000001 else
                              au BufNewFile,BufRead *.rrst,*.srst			setf rrst
                            endif
                            
                            " Rexx, Rebol or R
    1              0.000011 au BufNewFile,BufRead *.r,*.R				call dist#ft#FTr()
                            
                            " Remind
    1              0.000050 au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
    1              0.000008 au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
    1              0.000005 au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
    1              0.000004 au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
    1              0.000020 au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
    1              0.000005 au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
    1              0.000004 au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
    1              0.000006 au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
    1              0.000004 au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
    1              0.000007 au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
    1              0.000009 au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
    1              0.000023 au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rust
    1              0.000004 au BufNewFile,BufRead *.rs			setf rust
                            
                            " Rackup
    1              0.000023 au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
    1              0.000004 au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
    1              0.000011 au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
    1              0.000019 au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
    1              0.000006 au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
    1              0.000005 au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
    1              0.000004 au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
    1              0.000004 au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
    1              0.000006 au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scala
    1              0.000004 au BufNewFile,BufRead *.scala			setf scala
                            
                            " SBT - Scala Build Tool
    1              0.000004 au BufNewFile,BufRead *.sbt			setf sbt
                            
                            " Scilab
    1              0.000009 au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
    1              0.000004 au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
    1              0.000004 au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
    1              0.000009 au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
    1              0.000004 au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
    1              0.000003 au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
    1              0.000007 au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    1              0.000004 au BufNewFile,BufRead *.mc			call dist#ft#McSetf()
                            
                            " Services
    1              0.000005 au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
    1              0.000008 au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
    1              0.000005 au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
    1              0.000007 au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
    1              0.000005 au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
    1              0.000015 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    1              0.000013 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
    1              0.000004 au BufNewFile,BufRead catalog			setf catalog
    1              0.000008 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
    1              0.000056 au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call dist#ft#SetFileTypeSH("bash")
    1              0.000007 au BufNewFile,BufRead .kshrc*,*.ksh call dist#ft#SetFileTypeSH("ksh")
    1              0.000018 au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
                            
                            " Shell script (Arch Linux) or PHP file (Drupal)
    1              0.000008 au BufNewFile,BufRead *.install
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   call dist#ft#SetFileTypeSH("bash") |
                            	\ endif
                            
                            " tcsh scripts
    1              0.000016 au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call dist#ft#SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
    1              0.000027 au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
                            
                            " Z-Shell script
    1              0.000014 au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
    1              0.000012 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    1              0.000004 au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
    1              0.000011 au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme
                            
                            " Screen RC
    1              0.000010 au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
    1              0.000004 au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
    1              0.000008 au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
    1              0.000015 au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
    1              0.000014 au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
    1              0.000011 au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
    1              0.000004 au BufNewFile,BufRead .slrnrc			setf slrnrc
    1              0.000004 au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
    1              0.000006 au BufNewFile,BufRead *.st			setf st
    1              0.000007 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
    1              0.000004 au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
    1              0.000008 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    1              0.000007 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
    1              0.000006 au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
    1              0.000008 au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
    1              0.000006 au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
    1              0.000013 au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
    1              0.000007 au BufNewFile,BufRead *.rules			call dist#ft#FTRules()
                            
                            " Spec (Linux RPM)
    1              0.000004 au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
    1              0.000011 au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
    1              0.000004 au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
    1              0.000009 au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
    1              0.000006 au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
    1              0.000007 au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
    1              0.000015 au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
    1              0.000004 au BufNewFile,BufRead *.sql			call dist#ft#SQL()
                            
                            " SQLJ
    1              0.000004 au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
    1              0.000008 au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
    1              0.000011 au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
    1              0.000005 au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
    1              0.000013 au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata	setf stata
                            " Also *.class, but not when it's a Java bytecode file
    1              0.000008 au BufNewFile,BufRead *.class
                            	\ if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
                            
                            " SMCL
    1              0.000009 au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
    1              0.000006 au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
    1              0.000005 au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
    1              0.000004 au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
    1              0.000013 au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Systemd unit files
    1              0.000012 au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}	setf systemd
                            
                            " Synopsys Design Constraints
    1              0.000004 au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
    1              0.000011 au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
    1              0.000004 au BufNewFile,BufRead *.svg			setf svg
                            
                            " Tads (or Nroff or Perl test file)
    1              0.000005 au BufNewFile,BufRead *.t
                            	\ if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
                            
                            " Tags
    1              0.000007 au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
    1              0.000004 au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
    1              0.000008 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
    1              0.000006 au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
    1              0.000018 au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
    1              0.000004 au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
    1              0.000003 au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Tera Term Language
    1              0.000003 au BufRead,BufNewFile *.ttl			setf teraterm
                            
                            " Terminfo
    1              0.000006 au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
    1              0.000015 au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
    1              0.000004 au BufNewFile,BufRead *.tex			call dist#ft#FTtex()
                            
                            " ConTeXt
    1              0.000011 au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
                            
                            " Texinfo
    1              0.000011 au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
    1              0.000005 au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
    1              0.000009 au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
    1              0.000012 au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " tmux configuration
    1              0.000006 au BufNewFile,BufRead {.,}tmux*.conf		setf tmux
                            
                            " TPP - Text Presentation Program
    1              0.000006 au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
    1              0.000004 au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
    1              0.000005 au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
    1              0.000006 au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
    1              0.000004 au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
    1              0.000004 au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " Tutor mode
    1              0.000006 au BufNewFile,BufReadPost *.tutor		setf tutor
                            
                            " TWIG files
    1              0.000004 au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Motif UIT/UIL files
    1              0.000007 au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
    1              0.000010 au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
    1              0.000008 au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
    1              0.000006 au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
    1              0.000004 au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
    1              0.000008 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
    1              0.000007 au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
    1              0.000007 au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
    1              0.000013 au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
    1              0.000012 au BufNewFile,BufRead */.init/*.conf,*/.init/*.override	       setf upstart
    1              0.000006 au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
    1              0.000007 au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vera
    1              0.000011 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
    1              0.000004 au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
    1              0.000008 au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " SystemVerilog
    1              0.000009 au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
                            
                            " VHDL
    1              0.000014 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
    1              0.000007 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    1              0.000014 au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
    1              0.000008 au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
    1              0.000013 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    1              0.000006 au BufNewFile,BufRead *.frm			call dist#ft#FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
    1              0.000004 au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
    1              0.000005 au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
    1              0.000004 au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Vroom (vim testing and executable documentation)
    1              0.000006 au BufNewFile,BufRead *.vroom			setf vroom
                            
                            " Webmacro
    1              0.000004 au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
    1              0.000010 au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
    1              0.000004 au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
    1              0.000003 au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
    1              0.000004 au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WPL
    1              0.000006 au BufNewFile,BufRead *.wpl			setf xml
                            
                            " WvDial
    1              0.000010 au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
    1              0.000004 au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
    1              0.000005 au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    1              0.000006 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
    1              0.000007 au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
    1              0.000006 au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
    1              0.000004 au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
    1              0.000005 au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
    1              0.000007 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    1              0.000009 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    1              0.000013 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
    1              0.000008 au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
    1              0.000004 au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
    1              0.000021 au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
    1              0.000006 au BufNewFile,BufRead *.msc,*.msf		setf xmath
    1              0.000005 au BufNewFile,BufRead *.ms
                            	\ if !dist#ft#FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    1              0.000006 au BufNewFile,BufRead *.xml			call dist#ft#FTxml()
                            
                            " XMI (holding UML models) is also XML
    1              0.000004 au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
    1              0.000010 au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
    1              0.000006 au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
    1              0.000004 au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
    1              0.000009 au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
    1              0.000005 au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
    1              0.000004 au BufNewFile,BufRead *.xlf			setf xml
    1              0.000004 au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
    1              0.000006 au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
    1              0.000004 au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
    1              0.000017 au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
    1              0.000004 au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
    1              0.000010 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
    1              0.000016 au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
                            
                            " Yacc or racc
    1              0.000034 au BufNewFile,BufRead *.y			call dist#ft#FTy()
                            
                            " Yaml
    1              0.000011 au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " yum conf (close enough to dosini)
    1              0.000007 au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
    1              0.000005 au BufNewFile,BufRead *.zu			setf zimbu
                            " Zimbu Templates
    1              0.000005 au BufNewFile,BufRead *.zut			setf zimbutempl
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    1              0.000014 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call dist#ft#FThtml()
                            "   zsql (zope sql method)
    1              0.000023 au BufNewFile,BufRead *.zsql			call dist#ft#SQL()
                            
                            " Z80 assembler asz80
    1              0.000005 au BufNewFile,BufRead *.z8a			setf z8a
                            
    1              0.000001 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    1              0.000007 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    1              0.000001 augroup filetypedetect
    1              0.000007 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    1              0.000004 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache config files
    1              0.000028 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    1              0.000034 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    1              0.000011 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    1              0.000009 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
    1              0.000005 au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " Bazel build file
    1              0.000003 if !has("fname_case")
                              au BufNewFile,BufRead BUILD			setf bzl
                            endif
                            
                            " BIND zone
    1              0.000012 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
    1              0.000019 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    1              0.000008 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    1              0.000014 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    1              0.000008 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    1              0.000004 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    1              0.000004 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    1              0.000012 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    1              0.000009 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    1              0.000007 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
    1              0.000007 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    1              0.000009 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    1              0.000044 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
    1              0.000005 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    1              0.000008 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    1              0.000006 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    1              0.000005 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    1              0.000008 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    1              0.000011 au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
    1              0.000005 au BufNewFile,BufRead reportbug-*		call s:StarSetf('mail')
                            
                            " Modconf
    1              0.000009 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    1              0.000005 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    1              0.000013 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    1              0.000011 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Neomutt setup file
    1              0.000009 au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*	call s:StarSetf('neomuttrc')
    1              0.000010 au BufNewFile,BufRead neomuttrc*,Neomuttrc*		call s:StarSetf('neomuttrc')
                            
                            " Nroff macros
    1              0.000004 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " OpenBSD hostname.if
    1              0.000008 au BufNewFile,BufRead /etc/hostname.*		call s:StarSetf('config')
                            
                            " Pam conf
    1              0.000005 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    1              0.000009 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    1              0.000006 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
    1              0.000004 au BufRead,BufNewFile *.rdf			call dist#ft#Redif()
                            
                            " Remind
    1              0.000007 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
    1              0.000004 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    1              0.000008 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    1              0.000016 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    1              0.000006 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    1              0.000011 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    1              0.000005 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    1              0.000005 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    1              0.000008 au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script
    1              0.000006 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
    1              0.000017 au BufNewFile,BufRead *.text,README setf text
                            
                            " Help files match *.txt but should have a last line that is a modeline. 
    1              0.000005 au BufNewFile,BufRead *.txt
                                    \  if getline('$') !~ 'vim:.*ft=help'
                                    \|   setf text
                                    \| endif       
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
    1   0.000417   0.000380 runtime! ftdetect/*.vim
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
    1              0.000001 augroup END
                            
                            " Generic configuration file. Use FALLBACK, it's just guessing!
    1              0.000008 au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf FALLBACK conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
    1              0.000007 if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
                            endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
    1              0.000002 func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
    1              0.000006 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/ultisnips/ftdetect/snippets.vim
Sourced 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                            " recognize .snippet files
    1              0.000004 if has("autocmd")
    1              0.000006     autocmd BufNewFile,BufRead *.snippets setf snippets
    1              0.000003 endif

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/ftplugin.vim
Sourced 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    1              0.000004 if exists("did_load_ftplugin")
                              finish
                            endif
    1              0.000002 let did_load_ftplugin = 1
                            
    1              0.000001 augroup filetypeplugin
    1              0.000004   au FileType * call s:LoadFTPlugin()
                            
    1              0.000002   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                            	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000003 augroup END

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/indent.vim
Sourced 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000003 if exists("did_indent_on")
                              finish
                            endif
    1              0.000002 let did_indent_on = 1
                            
    1              0.000001 augroup filetypeindent
    1              0.000004   au FileType * call s:LoadIndent()
    1              0.000002   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                            	exe 'runtime! indent/' . name . '.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000003 augroup END

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/syntax/syntax.vim
Sourced 1 time
Total time:   0.000792
 Self time:   0.000225

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 04
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000004 if !has("syntax")
                              finish
                            endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000003 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
                            endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1   0.000742   0.000175 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000003 if exists("did_load_filetypes")
    1              0.000002   let s:did_ft = 1
    1              0.000001 else
                              filetype on
                              let s:did_ft = 0
                            endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected.
    1              0.000001 augroup syntaxset
    1              0.000004   au! FileType *	exe "set syntax=" . expand("<amatch>")
    1              0.000001 augroup END
                            
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1              0.000002 doautoall syntaxset FileType
    1              0.000001 if !s:did_ft
                              doautoall filetypedetect BufRead
                            endif

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/syntax/synload.vim
Sourced 1 time
Total time:   0.000555
 Self time:   0.000311

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Nov 04
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000004 if !has("syntax")
                              finish
                            endif
                            
                            " let others know that syntax has been switched on
    1              0.000002 let syntax_on = 1
                            
                            " Set the default highlighting colors.  Use a color scheme if specified.
    1              0.000002 if exists("colors_name")
                              exe "colors " . colors_name
                            else
    1   0.000449   0.000206   runtime! syntax/syncolor.vim
    1              0.000001 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000005 let s:cpo_save = &cpo
    1              0.000004 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000002 au! Syntax
                            
    1              0.000004 au Syntax *		call s:SynSet()
                            
    1              0.000002 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
                                for name in split(s, '\.')
                                  exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000018 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000003 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
                            endif
                            
                            " Restore 'cpoptions'
    1              0.000004 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/syntax/syncolor.vim
Sourced 4 times
Total time:   0.000820
 Self time:   0.000820

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    4              0.000016 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    3              0.000010   command -nargs=* SynColor hi <args>
    3              0.000007   command -nargs=* SynLink hi link <args>
    3              0.000002 else
    1              0.000001   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
                                command -nargs=* SynColor hi def <args>
                                command -nargs=* SynLink hi def link <args>
                              elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
    1              0.000003     command -nargs=* SynColor hi <args>
    1              0.000002     command -nargs=* SynLink hi! link <args>
    1              0.000001   else
                                " User defined syncolor file has already set the colors.
                                finish
                              endif
    1              0.000001 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    4              0.000008 if &background == "dark"
                              SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
                              SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
                              SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
                              SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
                              SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
                              SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
                              SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
                              SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
                              SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
                            else
    4              0.000031   SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
    4              0.000037   SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
    4              0.000042   SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
    4              0.000022   SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
    4              0.000023   SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
    4              0.000037   SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
    4              0.000038   SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
    4              0.000038   SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
    4              0.000018   SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    4              0.000003 endif
    4              0.000060 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    4              0.000046 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    4              0.000012 SynLink String		Constant
    4              0.000009 SynLink Character	Constant
    4              0.000009 SynLink Number		Constant
    4              0.000008 SynLink Boolean		Constant
    4              0.000010 SynLink Float		Number
    4              0.000010 SynLink Function	Identifier
    4              0.000009 SynLink Conditional	Statement
    4              0.000008 SynLink Repeat		Statement
    4              0.000008 SynLink Label		Statement
    4              0.000009 SynLink Operator	Statement
    4              0.000008 SynLink Keyword		Statement
    4              0.000008 SynLink Exception	Statement
    4              0.000008 SynLink Include		PreProc
    4              0.000010 SynLink Define		PreProc
    4              0.000008 SynLink Macro		PreProc
    4              0.000008 SynLink PreCondit	PreProc
    4              0.000010 SynLink StorageClass	Type
    4              0.000009 SynLink Structure	Type
    4              0.000009 SynLink Typedef		Type
    4              0.000010 SynLink Tag		Special
    4              0.000009 SynLink SpecialChar	Special
    4              0.000011 SynLink Delimiter	Special
    4              0.000008 SynLink SpecialComment	Special
    4              0.000008 SynLink Debug		Special
                            
    4              0.000004 delcommand SynColor
    4              0.000014 delcommand SynLink

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/vim-colorschemes/colors/molokai.vim
Sourced 1 time
Total time:   0.002867
 Self time:   0.002265

count  total (s)   self (s)
                            " Vim color file
                            "
                            " Author: Tomas Restrepo <tomas@winterdom.com>
                            " https://github.com/tomasr/molokai
                            "
                            " Note: Based on the Monokai theme for TextMate
                            " by Wimer Hazenberg and its darker variant
                            " by Hamish Stuart Macpherson
                            "
                            
    1   0.000960   0.000756 hi clear
                            
    1              0.000002 if version > 580
                                " no guarantees for version 5.8 and below, but this makes it stop
                                " complaining
    1   0.000947   0.000747     hi clear
    1              0.000004     if exists("syntax_on")
    1   0.000407   0.000209         syntax reset
    1              0.000001     endif
    1              0.000001 endif
    1              0.000004 let g:colors_name="molokai"
                            
    1              0.000002 if exists("g:molokai_original")
                                let s:molokai_original = g:molokai_original
                            else
    1              0.000002     let s:molokai_original = 0
    1              0.000001 endif
                            
                            
    1              0.000009 hi Boolean         guifg=#AE81FF
    1              0.000002 hi Character       guifg=#E6DB74
    1              0.000002 hi Number          guifg=#AE81FF
    1              0.000002 hi String          guifg=#E6DB74
    1              0.000002 hi Conditional     guifg=#F92672               gui=bold
    1              0.000002 hi Constant        guifg=#AE81FF               gui=bold
    1              0.000003 hi Cursor          guifg=#000000 guibg=#F8F8F0
    1              0.000003 hi iCursor         guifg=#000000 guibg=#F8F8F0
    1              0.000002 hi Debug           guifg=#BCA3A3               gui=bold
    1              0.000002 hi Define          guifg=#66D9EF
    1              0.000002 hi Delimiter       guifg=#8F8F8F
    1              0.000002 hi DiffAdd                       guibg=#13354A
    1              0.000003 hi DiffChange      guifg=#89807D guibg=#4C4745
    1              0.000002 hi DiffDelete      guifg=#960050 guibg=#1E0010
    1              0.000003 hi DiffText                      guibg=#4C4745 gui=italic,bold
                            
    1              0.000003 hi Directory       guifg=#A6E22E               gui=bold
    1              0.000002 hi Error           guifg=#E6DB74 guibg=#1E0010
    1              0.000003 hi ErrorMsg        guifg=#F92672 guibg=#232526 gui=bold
    1              0.000002 hi Exception       guifg=#A6E22E               gui=bold
    1              0.000001 hi Float           guifg=#AE81FF
    1              0.000003 hi FoldColumn      guifg=#465457 guibg=#000000
    1              0.000002 hi Folded          guifg=#465457 guibg=#000000
    1              0.000004 hi Function        guifg=#A6E22E
    1              0.000002 hi Identifier      guifg=#FD971F
    1              0.000002 hi Ignore          guifg=#808080 guibg=bg
    1              0.000002 hi IncSearch       guifg=#C4BE89 guibg=#000000
                            
    1              0.000002 hi Keyword         guifg=#F92672               gui=bold
    1              0.000002 hi Label           guifg=#E6DB74               gui=none
    1              0.000002 hi Macro           guifg=#C4BE89               gui=italic
    1              0.000003 hi SpecialKey      guifg=#66D9EF               gui=italic
                            
    1              0.000003 hi MatchParen      guifg=#000000 guibg=#FD971F gui=bold
    1              0.000002 hi ModeMsg         guifg=#E6DB74
    1              0.000002 hi MoreMsg         guifg=#E6DB74
    1              0.000002 hi Operator        guifg=#F92672
                            
                            " complete menu
    1              0.000002 hi Pmenu           guifg=#66D9EF guibg=#000000
    1              0.000002 hi PmenuSel                      guibg=#808080
    1              0.000002 hi PmenuSbar                     guibg=#080808
    1              0.000002 hi PmenuThumb      guifg=#66D9EF
                            
    1              0.000002 hi PreCondit       guifg=#A6E22E               gui=bold
    1              0.000002 hi PreProc         guifg=#A6E22E
    1              0.000002 hi Question        guifg=#66D9EF
    1              0.000002 hi Repeat          guifg=#F92672               gui=bold
    1              0.000003 hi Search          guifg=#000000 guibg=#FFE792
                            " marks
    1              0.000003 hi SignColumn      guifg=#A6E22E guibg=#232526
    1              0.000002 hi SpecialChar     guifg=#F92672               gui=bold
    1              0.000002 hi SpecialComment  guifg=#7E8E91               gui=bold
    1              0.000002 hi Special         guifg=#66D9EF guibg=bg      gui=italic
    1              0.000003 if has("spell")
    1              0.000005     hi SpellBad    guisp=#FF0000 gui=undercurl
    1              0.000003     hi SpellCap    guisp=#7070F0 gui=undercurl
    1              0.000003     hi SpellLocal  guisp=#70F0F0 gui=undercurl
    1              0.000003     hi SpellRare   guisp=#FFFFFF gui=undercurl
    1              0.000001 endif
    1              0.000002 hi Statement       guifg=#F92672               gui=bold
    1              0.000003 hi StatusLine      guifg=#455354 guibg=fg
    1              0.000003 hi StatusLineNC    guifg=#808080 guibg=#080808
    1              0.000002 hi StorageClass    guifg=#FD971F               gui=italic
    1              0.000001 hi Structure       guifg=#66D9EF
    1              0.000002 hi Tag             guifg=#F92672               gui=italic
    1              0.000002 hi Title           guifg=#ef5939
    1              0.000002 hi Todo            guifg=#FFFFFF guibg=bg      gui=bold
                            
    1              0.000001 hi Typedef         guifg=#66D9EF
    1              0.000002 hi Type            guifg=#66D9EF               gui=none
    1              0.000002 hi Underlined      guifg=#808080               gui=underline
                            
    1              0.000003 hi VertSplit       guifg=#808080 guibg=#080808 gui=bold
    1              0.000003 hi VisualNOS                     guibg=#403D3D
    1              0.000003 hi Visual                        guibg=#403D3D
    1              0.000003 hi WarningMsg      guifg=#FFFFFF guibg=#333333 gui=bold
    1              0.000003 hi WildMenu        guifg=#66D9EF guibg=#000000
                            
    1              0.000002 hi TabLineFill     guifg=#1B1D1E guibg=#1B1D1E
    1              0.000003 hi TabLine         guibg=#1B1D1E guifg=#808080 gui=none
                            
    1              0.000002 if s:molokai_original == 1
                               hi Normal          guifg=#F8F8F2 guibg=#272822
                               hi Comment         guifg=#75715E
                               hi CursorLine                    guibg=#3E3D32
                               hi CursorLineNr    guifg=#FD971F               gui=none
                               hi CursorColumn                  guibg=#3E3D32
                               hi ColorColumn                   guibg=#3B3A32
                               hi LineNr          guifg=#BCBCBC guibg=#3B3A32
                               hi NonText         guifg=#75715E
                               hi SpecialKey      guifg=#75715E
                            else
    1              0.000052    hi Normal          guifg=#F8F8F2 guibg=#1B1D1E
    1              0.000002    hi Comment         guifg=#7E8E91
    1              0.000002    hi CursorLine                    guibg=#293739
    1              0.000003    hi CursorLineNr    guifg=#FD971F               gui=none
    1              0.000002    hi CursorColumn                  guibg=#293739
    1              0.000002    hi ColorColumn                   guibg=#232526
    1              0.000003    hi LineNr          guifg=#465457 guibg=#232526
    1              0.000002    hi NonText         guifg=#465457
    1              0.000002    hi SpecialKey      guifg=#465457
    1              0.000001 end
                            
                            "
                            " Support for 256-color terminal
                            "
    1              0.000002 if &t_Co > 255
    1              0.000001    if s:molokai_original == 1
                                  hi Normal                   ctermbg=234
                                  hi CursorLine               ctermbg=235   cterm=none
                                  hi CursorLineNr ctermfg=208               cterm=none
                               else
    1              0.000038       hi Normal       ctermfg=252 ctermbg=233
    1              0.000003       hi CursorLine               ctermbg=234   cterm=none
    1              0.000003       hi CursorLineNr ctermfg=208               cterm=none
    1              0.000001    endif
    1              0.000001    hi Boolean         ctermfg=135
    1              0.000001    hi Character       ctermfg=144
    1              0.000004    hi Number          ctermfg=135
    1              0.000002    hi String          ctermfg=144
    1              0.000002    hi Conditional     ctermfg=161               cterm=bold
    1              0.000002    hi Constant        ctermfg=135               cterm=bold
    1              0.000002    hi Cursor          ctermfg=16  ctermbg=253
    1              0.000002    hi Debug           ctermfg=225               cterm=bold
    1              0.000001    hi Define          ctermfg=81
    1              0.000002    hi Delimiter       ctermfg=241
                            
    1              0.000002    hi DiffAdd                     ctermbg=24
    1              0.000002    hi DiffChange      ctermfg=181 ctermbg=239
    1              0.000002    hi DiffDelete      ctermfg=162 ctermbg=53
    1              0.000002    hi DiffText                    ctermbg=102 cterm=bold
                            
    1              0.000002    hi Directory       ctermfg=118               cterm=bold
    1              0.000002    hi Error           ctermfg=219 ctermbg=89
    1              0.000003    hi ErrorMsg        ctermfg=199 ctermbg=16    cterm=bold
    1              0.000002    hi Exception       ctermfg=118               cterm=bold
    1              0.000001    hi Float           ctermfg=135
    1              0.000002    hi FoldColumn      ctermfg=67  ctermbg=16
    1              0.000002    hi Folded          ctermfg=67  ctermbg=16
    1              0.000001    hi Function        ctermfg=118
    1              0.000002    hi Identifier      ctermfg=208               cterm=none
    1              0.000002    hi Ignore          ctermfg=244 ctermbg=232
    1              0.000002    hi IncSearch       ctermfg=193 ctermbg=16
                            
    1              0.000002    hi keyword         ctermfg=161               cterm=bold
    1              0.000002    hi Label           ctermfg=229               cterm=none
    1              0.000001    hi Macro           ctermfg=193
    1              0.000002    hi SpecialKey      ctermfg=81
                            
    1              0.000003    hi MatchParen      ctermfg=233  ctermbg=208 cterm=bold
    1              0.000004    hi ModeMsg         ctermfg=229
    1              0.000002    hi MoreMsg         ctermfg=229
    1              0.000002    hi Operator        ctermfg=161
                            
                               " complete menu
    1              0.000002    hi Pmenu           ctermfg=81  ctermbg=16
    1              0.000002    hi PmenuSel        ctermfg=255 ctermbg=242
    1              0.000002    hi PmenuSbar                   ctermbg=232
    1              0.000002    hi PmenuThumb      ctermfg=81
                            
    1              0.000002    hi PreCondit       ctermfg=118               cterm=bold
    1              0.000001    hi PreProc         ctermfg=118
    1              0.000002    hi Question        ctermfg=81
    1              0.000002    hi Repeat          ctermfg=161               cterm=bold
    1              0.000003    hi Search          ctermfg=0   ctermbg=222   cterm=NONE
                            
                               " marks column
    1              0.000002    hi SignColumn      ctermfg=118 ctermbg=235
    1              0.000002    hi SpecialChar     ctermfg=161               cterm=bold
    1              0.000002    hi SpecialComment  ctermfg=245               cterm=bold
    1              0.000002    hi Special         ctermfg=81
    1              0.000003    if has("spell")
    1              0.000002        hi SpellBad                ctermbg=52
    1              0.000002        hi SpellCap                ctermbg=17
    1              0.000002        hi SpellLocal              ctermbg=17
    1              0.000003        hi SpellRare  ctermfg=none ctermbg=none  cterm=reverse
    1              0.000001    endif
    1              0.000002    hi Statement       ctermfg=161               cterm=bold
    1              0.000002    hi StatusLine      ctermfg=238 ctermbg=253
    1              0.000002    hi StatusLineNC    ctermfg=244 ctermbg=232
    1              0.000002    hi StorageClass    ctermfg=208
    1              0.000001    hi Structure       ctermfg=81
    1              0.000003    hi Tag             ctermfg=161
    1              0.000002    hi Title           ctermfg=166
    1              0.000002    hi Todo            ctermfg=231 ctermbg=232   cterm=bold
                            
    1              0.000001    hi Typedef         ctermfg=81
    1              0.000002    hi Type            ctermfg=81                cterm=none
    1              0.000002    hi Underlined      ctermfg=244               cterm=underline
                            
    1              0.000003    hi VertSplit       ctermfg=244 ctermbg=232   cterm=bold
    1              0.000002    hi VisualNOS                   ctermbg=238
    1              0.000002    hi Visual                      ctermbg=235
    1              0.000003    hi WarningMsg      ctermfg=231 ctermbg=238   cterm=bold
    1              0.000002    hi WildMenu        ctermfg=81  ctermbg=16
                            
    1              0.000001    hi Comment         ctermfg=59
    1              0.000002    hi CursorColumn                ctermbg=236
    1              0.000003    hi ColorColumn                 ctermbg=236
    1              0.000002    hi LineNr          ctermfg=250 ctermbg=236
    1              0.000002    hi NonText         ctermfg=59
                            
    1              0.000002    hi SpecialKey      ctermfg=59
                            
    1              0.000003    if exists("g:rehash256") && g:rehash256 == 1
                                   hi Normal       ctermfg=252 ctermbg=234
                                   hi CursorLine               ctermbg=236   cterm=none
                                   hi CursorLineNr ctermfg=208               cterm=none
                            
                                   hi Boolean         ctermfg=141
                                   hi Character       ctermfg=222
                                   hi Number          ctermfg=141
                                   hi String          ctermfg=222
                                   hi Conditional     ctermfg=197               cterm=bold
                                   hi Constant        ctermfg=141               cterm=bold
                            
                                   hi DiffDelete      ctermfg=125 ctermbg=233
                            
                                   hi Directory       ctermfg=154               cterm=bold
                                   hi Error           ctermfg=222 ctermbg=233
                                   hi Exception       ctermfg=154               cterm=bold
                                   hi Float           ctermfg=141
                                   hi Function        ctermfg=154
                                   hi Identifier      ctermfg=208
                            
                                   hi Keyword         ctermfg=197               cterm=bold
                                   hi Operator        ctermfg=197
                                   hi PreCondit       ctermfg=154               cterm=bold
                                   hi PreProc         ctermfg=154
                                   hi Repeat          ctermfg=197               cterm=bold
                            
                                   hi Statement       ctermfg=197               cterm=bold
                                   hi Tag             ctermfg=197
                                   hi Title           ctermfg=203
                                   hi Visual                      ctermbg=238
                            
                                   hi Comment         ctermfg=244
                                   hi LineNr          ctermfg=239 ctermbg=235
                                   hi NonText         ctermfg=239
                                   hi SpecialKey      ctermfg=239
                               endif
    1              0.000001 end
                            
                            " Must be at the end, because of ctermbg=234 bug.
                            " https://groups.google.com/forum/#!msg/vim_dev/afPqwAFNdrU/nqh6tOM87QUJ
    1              0.000006 set background=dark

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/ultisnips/plugin/UltiSnips.vim
Sourced 1 time
Total time:   0.001606
 Self time:   0.000520

count  total (s)   self (s)
    1              0.000009 if exists('did_plugin_ultisnips') || &cp
                                finish
                            endif
    1              0.000002 let did_plugin_ultisnips=1
                            
    1              0.000001 if version < 704
                               echohl WarningMsg
                               echom  "UltiSnips requires Vim >= 7.4"
                               echohl None
                               finish
                            endif
                            
    1              0.000003 if !exists("g:UltiSnipsUsePythonVersion")
                               let g:_uspy=":py3 "
                               if !has("python3")
                                   if !has("python")
                                       if !exists("g:UltiSnipsNoPythonWarning")
                                           echohl WarningMsg
                                           echom  "UltiSnips requires py >= 2.7 or py3"
                                           echohl None
                                       endif
                                       unlet g:_uspy
                                       finish
                                   endif
                                   let g:_uspy=":py "
                               endif
                            else
                               " Use user-provided value, but check if it's available.
                               " This uses `has()`, because e.g. `exists(":python3")` is always 2.
    1              0.000002    if g:UltiSnipsUsePythonVersion == 2 && has('python')
                                   let g:_uspy=":python "
                               elseif g:UltiSnipsUsePythonVersion == 3 && has('python3')
    1              0.000003        let g:_uspy=":python3 "
    1              0.000001    endif
    1              0.000002    if !exists('g:_uspy')
                                   echohl WarningMsg
                                   echom  "UltiSnips: the Python version from g:UltiSnipsUsePythonVersion (".g:UltiSnipsUsePythonVersion.") is not available."
                                   echohl None
                                   finish
                               endif
    1              0.000001 endif
                            
                            " The Commands we define.
    1              0.000007 command! -bang -nargs=? -complete=customlist,UltiSnips#FileTypeComplete UltiSnipsEdit
                                \ :call UltiSnips#Edit(<q-bang>, <q-args>)
                            
    1              0.000003 command! -nargs=1 UltiSnipsAddFiletypes :call UltiSnips#AddFiletypes(<q-args>)
                            
    1              0.000001 augroup UltiSnips_AutoTrigger
    1              0.000151     au!
    1              0.000005     au InsertCharPre * call UltiSnips#TrackChange()
    1              0.000003     au TextChangedI * call UltiSnips#TrackChange()
    1              0.000001 augroup END
                            
    1   0.000242   0.000082 call UltiSnips#map_keys#MapKeys()
                            
                            " vim: ts=8 sts=4 sw=4

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/autoload/provider/python3.vim
Sourced 1 time
Total time:   0.000909
 Self time:   0.000442

count  total (s)   self (s)
                            " The Python3 provider uses a Python3 host to emulate an environment for running
                            " python3 plugins. :help provider
                            "
                            " Associating the plugin with the Python3 host is the first step because
                            " plugins will be passed as command-line arguments
                            
    1              0.000004 if exists('g:loaded_python3_provider')
                              finish
                            endif
    1              0.000003 let g:loaded_python3_provider = 1
                            
    1   0.000311   0.000192 let [s:prog, s:err] = provider#pythonx#Detect(3)
                            
    1              0.000002 function! provider#python3#Prog() abort
                              return s:prog
                            endfunction
                            
    1              0.000001 function! provider#python3#Error() abort
                              return s:err
                            endfunction
                            
    1              0.000002 if s:prog == ''
                              " Detection failed
                              finish
                            endif
                            
                            " The Python3 provider plugin will run in a separate instance of the Python3
                            " host.
    1   0.000455   0.000190 call remote#host#RegisterClone('legacy-python3-provider', 'python3')
    1   0.000092   0.000009 call remote#host#RegisterPlugin('legacy-python3-provider', 'script_host.py', [])
                            
    1              0.000002 function! provider#python3#Call(method, args) abort
                              if s:err != ''
                                return
                              endif
                              if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
                              return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/autoload/provider/pythonx.vim
Sourced 1 time
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
                            " The Python provider helper
    1              0.000004 if exists('s:loaded_pythonx_provider')
                              finish
                            endif
                            
    1              0.000002 let s:loaded_pythonx_provider = 1
                            
    1              0.000002 function! provider#pythonx#Require(host) abort
                              let ver = (a:host.orig_name ==# 'python') ? 2 : 3
                            
                              " Python host arguments
                              let prog = (ver == '2' ?  provider#python#Prog() : provider#python3#Prog())
                              let args = [prog, '-c', 'import sys; sys.path.remove(""); import neovim; neovim.start_host()']
                            
                              " Collect registered Python plugins into args
                              let python_plugins = remote#host#PluginsForHost(a:host.name)
                              for plugin in python_plugins
                                call add(args, plugin.path)
                              endfor
                            
                              return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE')
                            endfunction
                            
    1              0.000002 function! provider#pythonx#Detect(major_ver) abort
                              if a:major_ver == 2
                                if exists('g:python_host_prog')
                                  return [g:python_host_prog, '']
                                else
                                  let progs = ['python2', 'python2.7', 'python2.6', 'python']
                                endif
                              else
                                if exists('g:python3_host_prog')
                                  return [g:python3_host_prog, '']
                                else
                                  let progs = ['python3', 'python3.7', 'python3.6', 'python3.5',
                                        \ 'python3.4', 'python3.3', 'python']
                                endif
                              endif
                            
                              let errors = []
                            
                              for prog in progs
                                let [result, err] = s:check_interpreter(prog, a:major_ver)
                                if result
                                  return [prog, err]
                                endif
                                " Accumulate errors in case we don't find
                                " any suitable Python interpreter.
                                call add(errors, err)
                              endfor
                            
                              " No suitable Python interpreter found.
                              return ['', 'provider/pythonx: Could not load Python ' . a:major_ver
                                    \ . ":\n" .  join(errors, "\n")]
                            endfunction
                            
    1              0.000003 function! s:check_interpreter(prog, major_ver) abort
                              let prog_path = exepath(a:prog)
                              if prog_path ==# ''
                                return [0, a:prog . ' not found in search path or not executable.']
                              endif
                            
                              let min_version = (a:major_ver == 2) ? '2.6' : '3.3'
                            
                              " Try to load neovim module, and output Python version.
                              " Return codes:
                              "   0  Neovim module can be loaded.
                              "   2  Neovim module cannot be loaded.
                              "   Otherwise something else went wrong (e.g. 1 or 127).
                              let prog_ver = system([ a:prog , '-c' ,
                                    \ 'import sys; ' .
                                    \ 'sys.path.remove(""); ' .
                                    \ 'sys.stdout.write(str(sys.version_info[0]) + "." + str(sys.version_info[1])); ' .
                                    \ 'import pkgutil; ' .
                                    \ 'exit(2*int(pkgutil.get_loader("neovim") is None))'
                                    \ ])
                            
                              if v:shell_error == 2 || v:shell_error == 0
                                " Check version only for expected return codes.
                                if prog_ver !~ '^' . a:major_ver
                                  return [0, prog_path . ' is Python ' . prog_ver . ' and cannot provide Python '
                                        \ . a:major_ver . '.']
                                elseif prog_ver =~ '^' . a:major_ver && prog_ver < min_version
                                  return [0, prog_path . ' is Python ' . prog_ver . ' and cannot provide Python >= '
                                        \ . min_version . '.']
                                endif
                              endif
                            
                              if v:shell_error == 2
                                return [0, prog_path.' does not have the "neovim" module. :help provider-python']
                              elseif v:shell_error == 127
                                " This can happen with pyenv's shims.
                                return [0, prog_path . ' does not exist: ' . prog_ver]
                              elseif v:shell_error
                                return [0, 'Checking ' . prog_path . ' caused an unknown error. '
                                      \ . '(' . v:shell_error . ', output: ' . prog_ver . ')'
                                      \ . ' Report this at https://github.com/neovim/neovim']
                              endif
                            
                              return [1, '']
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/autoload/remote/host.vim
Sourced 1 time
Total time:   0.000235
 Self time:   0.000189

count  total (s)   self (s)
    1              0.000006 let s:hosts = {}
    1              0.000002 let s:plugin_patterns = {}
    1              0.000002 let s:plugins_for_host = {}
                            
                            " Register a host by associating it with a factory(funcref)
    1              0.000002 function! remote#host#Register(name, pattern, factory) abort
                              let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
                              let s:plugin_patterns[a:name] = a:pattern
                              if type(a:factory) == type(1) && a:factory
                                " Passed a channel directly
                                let s:hosts[a:name].channel = a:factory
                              endif
                            endfunction
                            
                            " Register a clone to an existing host. The new host will use the same factory
                            " as `source`, but it will run as a different process. This can be used by
                            " plugins that should run isolated from other plugins created for the same host
                            " type
    1              0.000002 function! remote#host#RegisterClone(name, orig_name) abort
                              if !has_key(s:hosts, a:orig_name)
                                throw 'No host named "'.a:orig_name.'" is registered'
                              endif
                              let Factory = s:hosts[a:orig_name].factory
                              let s:hosts[a:name] = {
                                    \ 'factory': Factory,
                                    \ 'channel': 0,
                                    \ 'initialized': 0,
                                    \ 'orig_name': a:orig_name
                                    \ }
                            endfunction
                            
                            " Get a host channel, bootstrapping it if necessary
    1              0.000002 function! remote#host#Require(name) abort
                              if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
                              let host = s:hosts[a:name]
                              if !host.channel && !host.initialized
                                let host_info = {
                                      \ 'name': a:name,
                                      \ 'orig_name': get(host, 'orig_name', a:name)
                                      \ }
                                let host.channel = call(host.factory, [host_info])
                                let host.initialized = 1
                              endif
                              return host.channel
                            endfunction
                            
    1              0.000002 function! remote#host#IsRunning(name) abort
                              if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
                              return s:hosts[a:name].channel != 0
                            endfunction
                            
                            " Example of registering a Python plugin with two commands (one async), one
                            " autocmd (async) and one function (sync):
                            "
                            " let s:plugin_path = expand('<sfile>:p:h').'/nvim_plugin.py'
                            " call remote#host#RegisterPlugin('python', s:plugin_path, [
                            "   \ {'type': 'command', 'name': 'PyCmd', 'sync': 1, 'opts': {}},
                            "   \ {'type': 'command', 'name': 'PyAsyncCmd', 'sync': 0, 'opts': {'eval': 'cursor()'}},
                            "   \ {'type': 'autocmd', 'name': 'BufEnter', 'sync': 0, 'opts': {'eval': 'expand("<afile>")'}},
                            "   \ {'type': 'function', 'name': 'PyFunc', 'sync': 1, 'opts': {}}
                            "   \ ])
                            "
                            " The third item in a declaration is a boolean: non zero means the command,
                            " autocommand or function will be executed synchronously with rpcrequest.
    1              0.000002 function! remote#host#RegisterPlugin(host, path, specs) abort
                              let plugins = remote#host#PluginsForHost(a:host)
                            
                              for plugin in plugins
                                if plugin.path == a:path
                                  throw 'Plugin "'.a:path.'" is already registered'
                                endif
                              endfor
                            
                              if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
                                " For now we won't allow registration of plugins when the host is already
                                " running.
                                throw 'Host "'.a:host.'" is already running'
                              endif
                            
                              for spec in a:specs
                                let type = spec.type
                                let name = spec.name
                                let sync = spec.sync
                                let opts = spec.opts
                                let rpc_method = a:path
                                if type == 'command'
                                  let rpc_method .= ':command:'.name
                                  call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'autocmd'
                                  " Since multiple handlers can be attached to the same autocmd event by a
                                  " single plugin, we need a way to uniquely identify the rpc method to
                                  " call.  The solution is to append the autocmd pattern to the method
                                  " name(This still has a limit: one handler per event/pattern combo, but
                                  " there's no need to allow plugins define multiple handlers in that case)
                                  let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
                                  call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'function'
                                  let rpc_method .= ':function:'.name
                                  call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
                                else
                                  echoerr 'Invalid declaration type: '.type
                                endif
                              endfor
                            
                              call add(plugins, {'path': a:path, 'specs': a:specs})
                            endfunction
                            
    1              0.000002 function! s:RegistrationCommands(host) abort
                              " Register a temporary host clone for discovering specs
                              let host_id = a:host.'-registration-clone'
                              call remote#host#RegisterClone(host_id, a:host)
                              let pattern = s:plugin_patterns[a:host]
                              let paths = globpath(&rtp, 'rplugin/'.a:host.'/'.pattern, 0, 1)
                              let paths = map(paths, 'tr(resolve(v:val),"\\","/")') " Normalize slashes #4795
                              let paths = uniq(sort(paths))
                              if empty(paths)
                                return []
                              endif
                            
                              for path in paths
                                call remote#host#RegisterPlugin(host_id, path, [])
                              endfor
                              let channel = remote#host#Require(host_id)
                              let lines = []
                              let registered = []
                              for path in paths
                                unlet! specs
                                let specs = rpcrequest(channel, 'specs', path)
                                if type(specs) != type([])
                                  " host didn't return a spec list, indicates a failure while loading a
                                  " plugin
                                  continue
                                endif
                                call add(lines, "call remote#host#RegisterPlugin('".a:host
                                      \ ."', '".path."', [")
                                for spec in specs
                                  call add(lines, "      \\ ".string(spec).",")
                                endfor
                                call add(lines, "     \\ ])")
                                call add(registered, path)
                              endfor
                              echomsg printf("remote/host: %s host registered plugins %s",
                                    \ a:host, string(map(registered, "fnamemodify(v:val, ':t')")))
                            
                              " Delete the temporary host clone
                              call rpcstop(s:hosts[host_id].channel)
                              call remove(s:hosts, host_id)
                              call remove(s:plugins_for_host, host_id)
                              return lines
                            endfunction
                            
    1              0.000001 function! remote#host#UpdateRemotePlugins() abort
                              let commands = []
                              let hosts = keys(s:hosts)
                              for host in hosts
                                if has_key(s:plugin_patterns, host)
                                  try
                                    let commands +=
                                          \   ['" '.host.' plugins']
                                          \ + s:RegistrationCommands(host)
                                          \ + ['', '']
                                  catch
                                    echomsg v:throwpoint
                                    echomsg v:exception
                                  endtry
                                endif
                              endfor
                              call writefile(commands, g:loaded_remote_plugins)
                              echomsg printf('remote/host: generated rplugin manifest: %s',
                                    \ g:loaded_remote_plugins)
                            endfunction
                            
    1              0.000002 function! remote#host#PluginsForHost(host) abort
                              if !has_key(s:plugins_for_host, a:host)
                                let s:plugins_for_host[a:host] = []
                              end
                              return s:plugins_for_host[a:host]
                            endfunction
                            
    1              0.000002 function! remote#host#LoadErrorForHost(host, log) abort
                              return 'Failed to load '. a:host . ' host. '.
                                    \ 'You can try to see what happened by starting nvim with '.
                                    \ a:log . ' set and opening the generated log file.'.
                                    \ ' Also, the host stderr is available in messages.'
                            endfunction
                            
                            " Registration of standard hosts
                            
                            " Python/Python3
    1   0.000033   0.000018 call remote#host#Register('python', '*',
                                  \ function('provider#pythonx#Require'))
    1   0.000020   0.000009 call remote#host#Register('python3', '*',
                                  \ function('provider#pythonx#Require'))
                            
                            " Ruby
    1   0.000015   0.000005 call remote#host#Register('ruby', '*.rb',
                                  \ function('provider#ruby#Require'))
                            
                            " nodejs
    1   0.000018   0.000008 call remote#host#Register('node', '*',
                                  \ function('provider#node#Require'))

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/ultisnips/autoload/UltiSnips/map_keys.vim
Sourced 1 time
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000007 if exists("b:did_autoload_ultisnips_map_keys") || !exists("g:_uspy")
                               finish
                            endif
    1              0.000002 let b:did_autoload_ultisnips_map_keys = 1
                            
                            " The trigger used to expand a snippet.
                            " NOTE: expansion and forward jumping can, but needn't be the same trigger
    1              0.000003 if !exists("g:UltiSnipsExpandTrigger")
                                let g:UltiSnipsExpandTrigger = "<tab>"
                            endif
                            
                            " The trigger used to display all triggers that could possible
                            " match in the current position.
    1              0.000002 if !exists("g:UltiSnipsListSnippets")
    1              0.000003     let g:UltiSnipsListSnippets = "<c-tab>"
    1              0.000001 endif
                            
                            " The trigger used to jump forward to the next placeholder.
                            " NOTE: expansion and forward jumping can be the same trigger.
    1              0.000002 if !exists("g:UltiSnipsJumpForwardTrigger")
    1              0.000002     let g:UltiSnipsJumpForwardTrigger = "<c-j>"
    1              0.000001 endif
                            
                            " The trigger to jump backward inside a snippet
    1              0.000002 if !exists("g:UltiSnipsJumpBackwardTrigger")
                                let g:UltiSnipsJumpBackwardTrigger = "<c-k>"
                            endif
                            
                            " Should UltiSnips unmap select mode mappings automagically?
    1              0.000002 if !exists("g:UltiSnipsRemoveSelectModeMappings")
    1              0.000002     let g:UltiSnipsRemoveSelectModeMappings = 1
    1              0.000001 end
                            
                            " If UltiSnips should remove Mappings, which should be ignored
    1              0.000002 if !exists("g:UltiSnipsMappingsToIgnore")
    1              0.000002     let g:UltiSnipsMappingsToIgnore = []
    1              0.000001 endif
                            
                            " UltiSnipsEdit will use this variable to decide if a new window
                            " is opened when editing. default is "normal", allowed are also
                            " "tabdo", "vertical", "horizontal", and "context".
    1              0.000002 if !exists("g:UltiSnipsEditSplit")
                                let g:UltiSnipsEditSplit = 'normal'
                            endif
                            
                            " A list of directory names that are searched for snippets.
    1              0.000002 if !exists("g:UltiSnipsSnippetDirectories")
    1              0.000002     let g:UltiSnipsSnippetDirectories = [ "UltiSnips" ]
    1              0.000001 endif
                            
                            " Enable or Disable snipmate snippet expansion.
    1              0.000002 if !exists("g:UltiSnipsEnableSnipMate")
    1              0.000002     let g:UltiSnipsEnableSnipMate = 1
    1              0.000001 endif
                            
    1              0.000002 function! UltiSnips#map_keys#MapKeys()
                                if g:UltiSnipsExpandTrigger == g:UltiSnipsJumpForwardTrigger
                                    exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippetOrJump()<cr>"
                                    exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>"
                                else
                                    exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippet()<cr>"
                                    exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippet()<cr>"
                                endif
                                exec "xnoremap <silent> " . g:UltiSnipsExpandTrigger. " :call UltiSnips#SaveLastVisualSelection()<cr>gvs"
                                exec "inoremap <silent> " . g:UltiSnipsListSnippets . " <C-R>=UltiSnips#ListSnippets()<cr>"
                                exec "snoremap <silent> " . g:UltiSnipsListSnippets . " <Esc>:call UltiSnips#ListSnippets()<cr>"
                            
                                snoremap <silent> <BS> <c-g>c
                                snoremap <silent> <DEL> <c-g>c
                                snoremap <silent> <c-h> <c-g>c
                                snoremap <c-r> <c-g>"_c<c-r>
                            endf

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/vim-snippets/plugin/vimsnippets.vim
Sourced 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000005 if exists("b:done_vimsnippets")
                               finish
                            endif
    1              0.000002 let b:done_vimsnippets = 1
                            
                            " Some variables need default value
    1              0.000002 if !exists("g:snips_author")
    1              0.000003     let g:snips_author = "yourname"
    1              0.000001 endif
                            
    1              0.000002 if !exists("g:snips_email")
    1              0.000002     let g:snips_email = "yourname@email.com"
    1              0.000001 endif
                            
    1              0.000002 if !exists("g:snips_github")
    1              0.000002     let g:snips_github = "https://github.com/yourname"
    1              0.000001 endif
                            
                            " Expanding the path is not needed on Vim 7.4
    1              0.000004 if &cp || version >= 704
    1              0.000001     finish
                            endif
                            
                            " Add pythonx to the python search path if needed (i.e. <= Vim 7.3).
                            if !has("python") && !has("python3")
                               finish
                            end
                            
                            " This will fail if UltiSnips is not installed.
                            try
                               call UltiSnips#bootstrap#Bootstrap()
                            catch /E117/
                               finish
                            endtry
                            
                            
                            " This should have been set by UltiSnips, otherwise something is wrong.
                            if !exists("g:_uspy")
                               finish
                            end
                            
                            
                            " Expand our path
                            let s:SourcedFile=expand("<sfile>")
                            exec g:_uspy "import vim, os, sys"
                            exec g:_uspy "sourced_file = vim.eval('s:SourcedFile')"
                            exec g:_uspy "while not os.path.exists(os.path.join(sourced_file, 'pythonx')):
                               \ sourced_file = os.path.dirname(sourced_file)"
                            exec g:_uspy "module_path = os.path.join(sourced_file, 'pythonx')"
                            exec g:_uspy "sys.path.append(module_path)"

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/vim-surround/plugin/surround.vim
Sourced 1 time
Total time:   0.000501
 Self time:   0.000501

count  total (s)   self (s)
                            " surround.vim - Surroundings
                            " Author:       Tim Pope <http://tpo.pe/>
                            " Version:      2.1
                            " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
                            
    1              0.000007 if exists("g:loaded_surround") || &cp || v:version < 700
                              finish
                            endif
    1              0.000002 let g:loaded_surround = 1
                            
                            " Input functions {{{1
                            
    1              0.000002 function! s:getchar()
                              let c = getchar()
                              if c =~ '^\d\+$'
                                let c = nr2char(c)
                              endif
                              return c
                            endfunction
                            
    1              0.000001 function! s:inputtarget()
                              let c = s:getchar()
                              while c =~ '^\d\+$'
                                let c .= s:getchar()
                              endwhile
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>\|\<C-C>\|\0"
                                return ""
                              else
                                return c
                              endif
                            endfunction
                            
    1              0.000001 function! s:inputreplacement()
                              let c = s:getchar()
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>" || c =~ "\<C-C>"
                                return ""
                              else
                                return c
                              endif
                            endfunction
                            
    1              0.000001 function! s:beep()
                              exe "norm! \<Esc>"
                              return ""
                            endfunction
                            
    1              0.000001 function! s:redraw()
                              redraw
                              return ""
                            endfunction
                            
                            " }}}1
                            
                            " Wrapping functions {{{1
                            
    1              0.000003 function! s:extractbefore(str)
                              if a:str =~ '\r'
                                return matchstr(a:str,'.*\ze\r')
                              else
                                return matchstr(a:str,'.*\ze\n')
                              endif
                            endfunction
                            
    1              0.000001 function! s:extractafter(str)
                              if a:str =~ '\r'
                                return matchstr(a:str,'\r\zs.*')
                              else
                                return matchstr(a:str,'\n\zs.*')
                              endif
                            endfunction
                            
    1              0.000001 function! s:fixindent(str,spc)
                              let str = substitute(a:str,'\t',repeat(' ',&sw),'g')
                              let spc = substitute(a:spc,'\t',repeat(' ',&sw),'g')
                              let str = substitute(str,'\(\n\|\%^\).\@=','\1'.spc,'g')
                              if ! &et
                                let str = substitute(str,'\s\{'.&ts.'\}',"\t",'g')
                              endif
                              return str
                            endfunction
                            
    1              0.000001 function! s:process(string)
                              let i = 0
                              for i in range(7)
                                let repl_{i} = ''
                                let m = matchstr(a:string,nr2char(i).'.\{-\}\ze'.nr2char(i))
                                if m != ''
                                  let m = substitute(strpart(m,1),'\r.*','','')
                                  let repl_{i} = input(match(m,'\w\+$') >= 0 ? m.': ' : m)
                                endif
                              endfor
                              let s = ""
                              let i = 0
                              while i < strlen(a:string)
                                let char = strpart(a:string,i,1)
                                if char2nr(char) < 8
                                  let next = stridx(a:string,char,i+1)
                                  if next == -1
                                    let s .= char
                                  else
                                    let insertion = repl_{char2nr(char)}
                                    let subs = strpart(a:string,i+1,next-i-1)
                                    let subs = matchstr(subs,'\r.*')
                                    while subs =~ '^\r.*\r'
                                      let sub = matchstr(subs,"^\r\\zs[^\r]*\r[^\r]*")
                                      let subs = strpart(subs,strlen(sub)+1)
                                      let r = stridx(sub,"\r")
                                      let insertion = substitute(insertion,strpart(sub,0,r),strpart(sub,r+1),'')
                                    endwhile
                                    let s .= insertion
                                    let i = next
                                  endif
                                else
                                  let s .= char
                                endif
                                let i += 1
                              endwhile
                              return s
                            endfunction
                            
    1              0.000002 function! s:wrap(string,char,type,removed,special)
                              let keeper = a:string
                              let newchar = a:char
                              let s:input = ""
                              let type = a:type
                              let linemode = type ==# 'V' ? 1 : 0
                              let before = ""
                              let after  = ""
                              if type ==# "V"
                                let initspaces = matchstr(keeper,'\%^\s*')
                              else
                                let initspaces = matchstr(getline('.'),'\%^\s*')
                              endif
                              let pairs = "b()B{}r[]a<>"
                              let extraspace = ""
                              if newchar =~ '^ '
                                let newchar = strpart(newchar,1)
                                let extraspace = ' '
                              endif
                              let idx = stridx(pairs,newchar)
                              if newchar == ' '
                                let before = ''
                                let after  = ''
                              elseif exists("b:surround_".char2nr(newchar))
                                let all    = s:process(b:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif exists("g:surround_".char2nr(newchar))
                                let all    = s:process(g:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif newchar ==# "p"
                                let before = "\n"
                                let after  = "\n\n"
                              elseif newchar ==# 's'
                                let before = ' '
                                let after  = ''
                              elseif newchar ==# ':'
                                let before = ':'
                                let after = ''
                              elseif newchar =~# "[tT\<C-T><]"
                                let dounmapp = 0
                                let dounmapb = 0
                                if !maparg(">","c")
                                  let dounmapb = 1
                                  " Hide from AsNeeded
                                  exe "cn"."oremap > ><CR>"
                                endif
                                let default = ""
                                if newchar ==# "T"
                                  if !exists("s:lastdel")
                                    let s:lastdel = ""
                                  endif
                                  let default = matchstr(s:lastdel,'<\zs.\{-\}\ze>')
                                endif
                                let tag = input("<",default)
                                if dounmapb
                                  silent! cunmap >
                                endif
                                let s:input = tag
                                if tag != ""
                                  let keepAttributes = ( match(tag, ">$") == -1 )
                                  let tag = substitute(tag,'>*$','','')
                                  let attributes = ""
                                  if keepAttributes
                                    let attributes = matchstr(a:removed, '<[^ \t\n]\+\zs\_.\{-\}\ze>')
                                  endif
                                  let s:input = tag . '>'
                                  if tag =~ '/$'
                                    let tag = substitute(tag, '/$', '', '')
                                    let before = '<'.tag.attributes.' />'
                                    let after = ''
                                  else
                                    let before = '<'.tag.attributes.'>'
                                    let after  = '</'.substitute(tag,' .*','','').'>'
                                  endif
                                  if newchar == "\<C-T>"
                                    if type ==# "v" || type ==# "V"
                                      let before .= "\n\t"
                                    endif
                                    if type ==# "v"
                                      let after  = "\n". after
                                    endif
                                  endif
                                endif
                              elseif newchar ==# 'l' || newchar == '\'
                                " LaTeX
                                let env = input('\begin{')
                                if env != ""
                                  let s:input = env."\<CR>"
                                  let env = '{' . env
                                  let env .= s:closematch(env)
                                  echo '\begin'.env
                                  let before = '\begin'.env
                                  let after  = '\end'.matchstr(env,'[^}]*').'}'
                                endif
                              elseif newchar ==# 'f' || newchar ==# 'F'
                                let fnc = input('function: ')
                                if fnc != ""
                                  let s:input = fnc."\<CR>"
                                  let before = substitute(fnc,'($','','').'('
                                  let after  = ')'
                                  if newchar ==# 'F'
                                    let before .= ' '
                                    let after = ' ' . after
                                  endif
                                endif
                              elseif newchar ==# "\<C-F>"
                                let fnc = input('function: ')
                                let s:input = fnc."\<CR>"
                                let before = '('.fnc.' '
                                let after = ')'
                              elseif idx >= 0
                                let spc = (idx % 3) == 1 ? " " : ""
                                let idx = idx / 3 * 3
                                let before = strpart(pairs,idx+1,1) . spc
                                let after  = spc . strpart(pairs,idx+2,1)
                              elseif newchar == "\<C-[>" || newchar == "\<C-]>"
                                let before = "{\n\t"
                                let after  = "\n}"
                              elseif newchar !~ '\a'
                                let before = newchar
                                let after  = newchar
                              else
                                let before = ''
                                let after  = ''
                              endif
                              let after  = substitute(after ,'\n','\n'.initspaces,'g')
                              if type ==# 'V' || (a:special && type ==# "v")
                                let before = substitute(before,' \+$','','')
                                let after  = substitute(after ,'^ \+','','')
                                if after !~ '^\n'
                                  let after  = initspaces.after
                                endif
                                if keeper !~ '\n$' && after !~ '^\n'
                                  let keeper .= "\n"
                                elseif keeper =~ '\n$' && after =~ '^\n'
                                  let after = strpart(after,1)
                                endif
                                if keeper !~ '^\n' && before !~ '\n\s*$'
                                  let before .= "\n"
                                  if a:special
                                    let before .= "\t"
                                  endif
                                elseif keeper =~ '^\n' && before =~ '\n\s*$'
                                  let keeper = strcharpart(keeper,1)
                                endif
                                if type ==# 'V' && keeper =~ '\n\s*\n$'
                                  let keeper = strcharpart(keeper,0,strchars(keeper) - 1)
                                endif
                              endif
                              if type ==# 'V'
                                let before = initspaces.before
                              endif
                              if before =~ '\n\s*\%$'
                                if type ==# 'v'
                                  let keeper = initspaces.keeper
                                endif
                                let padding = matchstr(before,'\n\zs\s\+\%$')
                                let before  = substitute(before,'\n\s\+\%$','\n','')
                                let keeper = s:fixindent(keeper,padding)
                              endif
                              if type ==# 'V'
                                let keeper = before.keeper.after
                              elseif type =~ "^\<C-V>"
                                " Really we should be iterating over the buffer
                                let repl = substitute(before,'[\\~]','\\&','g').'\1'.substitute(after,'[\\~]','\\&','g')
                                let repl = substitute(repl,'\n',' ','g')
                                let keeper = substitute(keeper."\n",'\(.\{-\}\)\(\n\)',repl.'\n','g')
                                let keeper = substitute(keeper,'\n\%$','','')
                              else
                                let keeper = before.extraspace.keeper.extraspace.after
                              endif
                              return keeper
                            endfunction
                            
    1              0.000002 function! s:wrapreg(reg,char,removed,special)
                              let orig = getreg(a:reg)
                              let type = substitute(getregtype(a:reg),'\d\+$','','')
                              let new = s:wrap(orig,a:char,type,a:removed,a:special)
                              call setreg(a:reg,new,type)
                            endfunction
                            " }}}1
                            
    1              0.000001 function! s:insert(...) " {{{1
                              " Optional argument causes the result to appear on 3 lines, not 1
                              let linemode = a:0 ? a:1 : 0
                              let char = s:inputreplacement()
                              while char == "\<CR>" || char == "\<C-S>"
                                " TODO: use total count for additional blank lines
                                let linemode += 1
                                let char = s:inputreplacement()
                              endwhile
                              if char == ""
                                return ""
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = @@
                              call setreg('"',"\r",'v')
                              call s:wrapreg('"',char,"",linemode)
                              " If line mode is used and the surrounding consists solely of a suffix,
                              " remove the initial newline.  This fits a use case of mine but is a
                              " little inconsistent.  Is there anyone that would prefer the simpler
                              " behavior of just inserting the newline?
                              if linemode && match(getreg('"'),'^\n\s*\zs.*') == 0
                                call setreg('"',matchstr(getreg('"'),'^\n\s*\zs.*'),getregtype('"'))
                              endif
                              " This can be used to append a placeholder to the end
                              if exists("g:surround_insert_tail")
                                call setreg('"',g:surround_insert_tail,"a".getregtype('"'))
                              endif
                              if col('.') >= col('$')
                                norm! ""p
                              else
                                norm! ""P
                              endif
                              if linemode
                                call s:reindent()
                              endif
                              norm! `]
                              call search('\r','bW')
                              let @@ = reg_save
                              let &clipboard = cb_save
                              return "\<Del>"
                            endfunction " }}}1
                            
    1              0.000001 function! s:reindent() " {{{1
                              if exists("b:surround_indent") ? b:surround_indent : (!exists("g:surround_indent") || g:surround_indent)
                                silent norm! '[=']
                              endif
                            endfunction " }}}1
                            
    1              0.000001 function! s:dosurround(...) " {{{1
                              let scount = v:count1
                              let char = (a:0 ? a:1 : s:inputtarget())
                              let spc = ""
                              if char =~ '^\d\+'
                                let scount = scount * matchstr(char,'^\d\+')
                                let char = substitute(char,'^\d\+','','')
                              endif
                              if char =~ '^ '
                                let char = strpart(char,1)
                                let spc = 1
                              endif
                              if char == 'a'
                                let char = '>'
                              endif
                              if char == 'r'
                                let char = ']'
                              endif
                              let newchar = ""
                              if a:0 > 1
                                let newchar = a:2
                                if newchar == "\<Esc>" || newchar == "\<C-C>" || newchar == ""
                                  return s:beep()
                                endif
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let append = ""
                              let original = getreg('"')
                              let otype = getregtype('"')
                              call setreg('"',"")
                              let strcount = (scount == 1 ? "" : scount)
                              if char == '/'
                                exe 'norm! '.strcount.'[/d'.strcount.']/'
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>"''`]'
                                exe 'norm! T'.char
                                if getline('.')[col('.')-1] == char
                                  exe 'norm! l'
                                endif
                                exe 'norm! dt'.char
                              else
                                exe 'norm! d'.strcount.'i'.char
                              endif
                              let keeper = getreg('"')
                              let okeeper = keeper " for reindent below
                              if keeper == ""
                                call setreg('"',original,otype)
                                let &clipboard = cb_save
                                return ""
                              endif
                              let oldline = getline('.')
                              let oldlnum = line('.')
                              if char ==# "p"
                                call setreg('"','','V')
                              elseif char ==# "s" || char ==# "w" || char ==# "W"
                                " Do nothing
                                call setreg('"','')
                              elseif char =~ "[\"'`]"
                                exe "norm! i \<Esc>d2i".char
                                call setreg('"',substitute(getreg('"'),' ','',''))
                              elseif char == '/'
                                norm! "_x
                                call setreg('"','/**/',"c")
                                let keeper = substitute(substitute(keeper,'^/\*\s\=','',''),'\s\=\*$','','')
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>]'
                                exe 'norm! F'.char
                                exe 'norm! df'.char
                              else
                                " One character backwards
                                call search('\m.', 'bW')
                                exe "norm! da".char
                              endif
                              let removed = getreg('"')
                              let rem2 = substitute(removed,'\n.*','','')
                              let oldhead = strpart(oldline,0,strlen(oldline)-strlen(rem2))
                              let oldtail = strpart(oldline,  strlen(oldline)-strlen(rem2))
                              let regtype = getregtype('"')
                              if char =~# '[\[({<T]' || spc
                                let keeper = substitute(keeper,'^\s\+','','')
                                let keeper = substitute(keeper,'\s\+$','','')
                              endif
                              if col("']") == col("$") && col('.') + 1 == col('$')
                                if oldhead =~# '^\s*$' && a:0 < 2
                                  let keeper = substitute(keeper,'\%^\n'.oldhead.'\(\s*.\{-\}\)\n\s*\%$','\1','')
                                endif
                                let pcmd = "p"
                              else
                                let pcmd = "P"
                              endif
                              if line('.') + 1 < oldlnum && regtype ==# "V"
                                let pcmd = "p"
                              endif
                              call setreg('"',keeper,regtype)
                              if newchar != ""
                                let special = a:0 > 2 ? a:3 : 0
                                call s:wrapreg('"',newchar,removed,special)
                              endif
                              silent exe 'norm! ""'.pcmd.'`['
                              if removed =~ '\n' || okeeper =~ '\n' || getreg('"') =~ '\n'
                                call s:reindent()
                              endif
                              if getline('.') =~ '^\s\+$' && keeper =~ '^\s*\n'
                                silent norm! cc
                              endif
                              call setreg('"',original,otype)
                              let s:lastdel = removed
                              let &clipboard = cb_save
                              if newchar == ""
                                silent! call repeat#set("\<Plug>Dsurround".char,scount)
                              else
                                silent! call repeat#set("\<Plug>C".(a:0 > 2 && a:3 ? "S" : "s")."urround".char.newchar.s:input,scount)
                              endif
                            endfunction " }}}1
                            
    1              0.000001 function! s:changesurround(...) " {{{1
                              let a = s:inputtarget()
                              if a == ""
                                return s:beep()
                              endif
                              let b = s:inputreplacement()
                              if b == ""
                                return s:beep()
                              endif
                              call s:dosurround(a,b,a:0 && a:1)
                            endfunction " }}}1
                            
    1              0.000001 function! s:opfunc(type, ...) abort " {{{1
                              if a:type ==# 'setup'
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
                                return 'g@'
                              endif
                              let char = s:inputreplacement()
                              if char == ""
                                return s:beep()
                              endif
                              let reg = '"'
                              let sel_save = &selection
                              let &selection = "inclusive"
                              let cb_save  = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = getreg(reg)
                              let reg_type = getregtype(reg)
                              let type = a:type
                              if a:type == "char"
                                silent exe 'norm! v`[o`]"'.reg.'y'
                                let type = 'v'
                              elseif a:type == "line"
                                silent exe 'norm! `[V`]"'.reg.'y'
                                let type = 'V'
                              elseif a:type ==# "v" || a:type ==# "V" || a:type ==# "\<C-V>"
                                let &selection = sel_save
                                let ve = &virtualedit
                                if !(a:0 && a:1)
                                  set virtualedit=
                                endif
                                silent exe 'norm! gv"'.reg.'y'
                                let &virtualedit = ve
                              elseif a:type =~ '^\d\+$'
                                let type = 'v'
                                silent exe 'norm! ^v'.a:type.'$h"'.reg.'y'
                                if mode() ==# 'v'
                                  norm! v
                                  return s:beep()
                                endif
                              else
                                let &selection = sel_save
                                let &clipboard = cb_save
                                return s:beep()
                              endif
                              let keeper = getreg(reg)
                              if type ==# "v" && a:type !=# "v"
                                let append = matchstr(keeper,'\_s\@<!\s*$')
                                let keeper = substitute(keeper,'\_s\@<!\s*$','','')
                              endif
                              call setreg(reg,keeper,type)
                              call s:wrapreg(reg,char,"",a:0 && a:1)
                              if type ==# "v" && a:type !=# "v" && append != ""
                                call setreg(reg,append,"ac")
                              endif
                              silent exe 'norm! gv'.(reg == '"' ? '' : '"' . reg).'p`['
                              if type ==# 'V' || (getreg(reg) =~ '\n' && type ==# 'v')
                                call s:reindent()
                              endif
                              call setreg(reg,reg_save,reg_type)
                              let &selection = sel_save
                              let &clipboard = cb_save
                              if a:type =~ '^\d\+$'
                                silent! call repeat#set("\<Plug>Y".(a:0 && a:1 ? "S" : "s")."surround".char.s:input,a:type)
                              else
                                silent! call repeat#set("\<Plug>SurroundRepeat".char.s:input)
                              endif
                            endfunction
                            
    1              0.000001 function! s:opfunc2(...) abort
                              if !a:0 || a:1 ==# 'setup'
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
                                return 'g@'
                              endif
                              call s:opfunc(a:1, 1)
                            endfunction " }}}1
                            
    1              0.000001 function! s:closematch(str) " {{{1
                              " Close an open (, {, [, or < on the command line.
                              let tail = matchstr(a:str,'.[^\[\](){}<>]*$')
                              if tail =~ '^\[.\+'
                                return "]"
                              elseif tail =~ '^(.\+'
                                return ")"
                              elseif tail =~ '^{.\+'
                                return "}"
                              elseif tail =~ '^<.+'
                                return ">"
                              else
                                return ""
                              endif
                            endfunction " }}}1
                            
    1              0.000006 nnoremap <silent> <Plug>SurroundRepeat .
    1              0.000007 nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>
    1              0.000005 nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>
    1              0.000005 nnoremap <silent> <Plug>CSurround  :<C-U>call <SID>changesurround(1)<CR>
    1              0.000005 nnoremap <expr>   <Plug>Yssurround '^'.v:count1.<SID>opfunc('setup').'g_'
    1              0.000004 nnoremap <expr>   <Plug>YSsurround <SID>opfunc2('setup').'_'
    1              0.000004 nnoremap <expr>   <Plug>Ysurround  <SID>opfunc('setup')
    1              0.000004 nnoremap <expr>   <Plug>YSurround  <SID>opfunc2('setup')
    1              0.000006 vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>
    1              0.000006 vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>
    1              0.000004 inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>
    1              0.000004 inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>
                            
    1              0.000003 if !exists("g:surround_no_mappings") || ! g:surround_no_mappings
    1              0.000003   nmap ds  <Plug>Dsurround
    1              0.000003   nmap cs  <Plug>Csurround
    1              0.000003   nmap cS  <Plug>CSurround
    1              0.000003   nmap ys  <Plug>Ysurround
    1              0.000003   nmap yS  <Plug>YSurround
    1              0.000003   nmap yss <Plug>Yssurround
    1              0.000003   nmap ySs <Plug>YSsurround
    1              0.000003   nmap ySS <Plug>YSsurround
    1              0.000003   xmap S   <Plug>VSurround
    1              0.000006   xmap gS  <Plug>VgSurround
    1              0.000003   if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings
    1              0.000013     if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
    1              0.000004       imap    <C-S> <Plug>Isurround
    1              0.000001     endif
    1              0.000003     imap      <C-G>s <Plug>Isurround
    1              0.000005     imap      <C-G>S <Plug>ISurround
    1              0.000001   endif
    1              0.000001 endif
                            
                            " vim:set ft=vim sw=2 sts=2 et:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/ctrlp.vim/plugin/ctrlp.vim
Sourced 1 time
Total time:   0.000599
 Self time:   0.000246

count  total (s)   self (s)
                            " =============================================================================
                            " File:          plugin/ctrlp.vim
                            " Description:   Fuzzy file, buffer, mru, tag, etc finder.
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            " GetLatestVimScripts: 3736 1 :AutoInstall: ctrlp.zip
                            
    1              0.000007 if ( exists('g:loaded_ctrlp') && g:loaded_ctrlp ) || v:version < 700 || &cp
                            	fini
                            en
    1              0.000002 let g:loaded_ctrlp = 1
                            
    1              0.000010 let [g:ctrlp_lines, g:ctrlp_allfiles, g:ctrlp_alltags, g:ctrlp_alldirs,
                            	\ g:ctrlp_allmixes, g:ctrlp_buftags, g:ctrlp_ext_vars, g:ctrlp_builtins]
                            	\ = [[], [], [], [], {}, {}, [], 2]
                            
    1              0.000004 if !exists('g:ctrlp_map') | let g:ctrlp_map = '<c-p>' | en
    1              0.000003 if !exists('g:ctrlp_cmd') | let g:ctrlp_cmd = 'CtrlP' | en
                            
    1              0.000004 com! -n=? -com=dir CtrlP         cal ctrlp#init(0, { 'dir': <q-args> })
    1              0.000003 com! -n=? -com=dir CtrlPMRUFiles cal ctrlp#init(2, { 'dir': <q-args> })
                            
    1              0.000006 com! -bar CtrlPBuffer   cal ctrlp#init(1)
    1              0.000003 com! -n=? CtrlPLastMode cal ctrlp#init(-1, { 'args': <q-args> })
                            
    1              0.000002 com! -bar CtrlPClearCache     cal ctrlp#clr()
    1              0.000002 com! -bar CtrlPClearAllCaches cal ctrlp#clra()
                            
    1              0.000002 com! -bar ClearCtrlPCache     cal ctrlp#clr()
    1              0.000002 com! -bar ClearAllCtrlPCaches cal ctrlp#clra()
                            
    1              0.000002 com! -bar CtrlPCurWD   cal ctrlp#init(0, { 'mode': '' })
    1              0.000002 com! -bar CtrlPCurFile cal ctrlp#init(0, { 'mode': 'c' })
    1              0.000002 com! -bar CtrlPRoot    cal ctrlp#init(0, { 'mode': 'r' })
                            
    1              0.000009 if g:ctrlp_map != '' && !hasmapto(':<c-u>'.g:ctrlp_cmd.'<cr>', 'n')
    1              0.000008 	exe 'nn <silent>' g:ctrlp_map ':<c-u>'.g:ctrlp_cmd.'<cr>'
    1              0.000003 en
                            
    1   0.000450   0.000097 cal ctrlp#mrufiles#init()
                            
    1              0.000008 com! -bar CtrlPTag      cal ctrlp#init(ctrlp#tag#id())
    1              0.000003 com! -bar CtrlPQuickfix cal ctrlp#init(ctrlp#quickfix#id())
                            
    1              0.000004 com! -n=? -com=dir CtrlPDir
                            	\ cal ctrlp#init(ctrlp#dir#id(), { 'dir': <q-args> })
                            
    1              0.000004 com! -n=? -com=buffer CtrlPBufTag
                            	\ cal ctrlp#init(ctrlp#buffertag#cmd(0, <q-args>))
                            
    1              0.000003 com! -bar CtrlPBufTagAll cal ctrlp#init(ctrlp#buffertag#cmd(1))
    1              0.000003 com! -bar CtrlPRTS       cal ctrlp#init(ctrlp#rtscript#id())
    1              0.000002 com! -bar CtrlPUndo      cal ctrlp#init(ctrlp#undo#id())
                            
    1              0.000004 com! -n=? -com=buffer CtrlPLine
                            	\ cal ctrlp#init(ctrlp#line#cmd(1, <q-args>))
                            
    1              0.000003 com! -n=? -com=buffer CtrlPChange
                            	\ cal ctrlp#init(ctrlp#changes#cmd(0, <q-args>))
                            
    1              0.000002 com! -bar CtrlPChangeAll   cal ctrlp#init(ctrlp#changes#cmd(1))
    1              0.000002 com! -bar CtrlPMixed       cal ctrlp#init(ctrlp#mixed#id())
    1              0.000002 com! -bar CtrlPBookmarkDir cal ctrlp#init(ctrlp#bookmarkdir#id())
                            
    1              0.000004 com! -n=? -com=dir CtrlPBookmarkDirAdd
                            	\ cal ctrlp#call('ctrlp#bookmarkdir#add', <q-args>)
                            
                            " vim:ts=2:sw=2:sts=2

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim
Sourced 1 time
Total time:   0.000221
 Self time:   0.000138

count  total (s)   self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp/mrufiles.vim
                            " Description:   Most Recently Used Files extension
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            
                            " Static variables {{{1
    1              0.000004 let [s:mrbs, s:mrufs] = [[], []]
                            
    1              0.000002 fu! ctrlp#mrufiles#opts()
                            	let [pref, opts] = ['g:ctrlp_mruf_', {
                            		\ 'max': ['s:max', 250],
                            		\ 'include': ['s:in', ''],
                            		\ 'exclude': ['s:ex', ''],
                            		\ 'case_sensitive': ['s:cseno', 1],
                            		\ 'relative': ['s:re', 0],
                            		\ 'save_on_update': ['s:soup', 1],
                            		\ }]
                            	for [ke, va] in items(opts)
                            		let [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
                            	endfo
                            endf
    1   0.000096   0.000013 cal ctrlp#mrufiles#opts()
                            " Utilities {{{1
    1              0.000002 fu! s:excl(fn)
                            	retu !empty({s:ex}) && a:fn =~# {s:ex}
                            endf
                            
    1              0.000001 fu! s:mergelists()
                            	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
                            	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
                            	let mrufs = s:mrufs + diskmrufs
                            	retu s:chop(mrufs)
                            endf
                            
    1              0.000001 fu! s:chop(mrufs)
                            	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
                            	retu a:mrufs
                            endf
                            
    1              0.000001 fu! s:reformat(mrufs, ...)
                            	let cwd = getcwd()
                            	let cwd .= cwd !~ '[\/]$' ? ctrlp#utils#lash() : ''
                            	if {s:re}
                            		let cwd = exists('+ssl') ? tr(cwd, '/', '\') : cwd
                            		cal filter(a:mrufs, '!stridx(v:val, cwd)')
                            	en
                            	if a:0 && a:1 == 'raw' | retu a:mrufs | en
                            	let idx = strlen(cwd)
                            	if exists('+ssl') && &ssl
                            		let cwd = tr(cwd, '\', '/')
                            		cal map(a:mrufs, 'tr(v:val, "\\", "/")')
                            	en
                            	retu map(a:mrufs, '!stridx(v:val, cwd) ? strpart(v:val, idx) : v:val')
                            endf
                            
    1              0.000001 fu! s:record(bufnr)
                            	if s:locked | retu | en
                            	let bufnr = a:bufnr + 0
                            	let bufname = bufname(bufnr)
                            	if bufnr > 0 && !empty(bufname)
                            		cal filter(s:mrbs, 'v:val != bufnr')
                            		cal insert(s:mrbs, bufnr)
                            		cal s:addtomrufs(bufname)
                            	en
                            endf
                            
    1              0.000001 fu! s:addtomrufs(fname)
                            	let fn = fnamemodify(a:fname, ':p')
                            	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
                            	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} )
                            		\ || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
                            	let idx = index(s:mrufs, fn, 0, !{s:cseno})
                            	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
                            	en
                            endf
                            
    1              0.000001 fu! s:savetofile(mrufs)
                            	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)
                            endf
                            " Public {{{1
    1              0.000002 fu! ctrlp#mrufiles#refresh(...)
                            	let mrufs = s:mergelists()
                            	cal filter(mrufs, '!empty(ctrlp#utils#glob(v:val, 1)) && !s:excl(v:val)')
                            	if exists('+ssl')
                            		cal map(mrufs, 'tr(v:val, "/", "\\")')
                            		cal map(s:mrufs, 'tr(v:val, "/", "\\")')
                            		let cond = 'count(mrufs, v:val, !{s:cseno}) == 1'
                            		cal filter(mrufs, cond)
                            		cal filter(s:mrufs, cond)
                            	en
                            	cal s:savetofile(mrufs)
                            	retu a:0 && a:1 == 'raw' ? [] : s:reformat(mrufs)
                            endf
                            
    1              0.000002 fu! ctrlp#mrufiles#remove(files)
                            	let mrufs = []
                            	if a:files != []
                            		let mrufs = s:mergelists()
                            		let cond = 'index(a:files, v:val, 0, !{s:cseno}) < 0'
                            		cal filter(mrufs, cond)
                            		cal filter(s:mrufs, cond)
                            	en
                            	cal s:savetofile(mrufs)
                            	retu s:reformat(mrufs)
                            endf
                            
    1              0.000001 fu! ctrlp#mrufiles#add(fn)
                            	if !empty(a:fn)
                            		cal s:addtomrufs(a:fn)
                            	en
                            endf
                            
    1              0.000001 fu! ctrlp#mrufiles#list(...)
                            	retu a:0 ? a:1 == 'raw' ? s:reformat(s:mergelists(), a:1) : 0
                            		\ : s:reformat(s:mergelists())
                            endf
                            
    1              0.000001 fu! ctrlp#mrufiles#bufs()
                            	retu s:mrbs
                            endf
                            
    1              0.000001 fu! ctrlp#mrufiles#tgrel()
                            	let {s:re} = !{s:re}
                            endf
                            
    1              0.000001 fu! ctrlp#mrufiles#cachefile()
                            	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
                            	retu s:cafile
                            endf
                            
    1              0.000001 fu! ctrlp#mrufiles#init()
                            	if !has('autocmd') | retu | en
                            	let s:locked = 0
                            	aug CtrlPMRUF
                            		au!
                            		au BufAdd,BufEnter,BufLeave,BufWritePost * cal s:record(expand('<abuf>', 1))
                            		au QuickFixCmdPre  *vimgrep* let s:locked = 1
                            		au QuickFixCmdPost *vimgrep* let s:locked = 0
                            		au VimLeavePre * cal s:savetofile(s:mergelists())
                            	aug END
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/vim-transpose/plugin/transpose.vim
Sourced 1 time
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                            " Vim transposition plugin.
                            " Plugin author: Benoit Mortgat
                            " Main git repository: http://github.com/salsifis/vim-transpose
                            
    1              0.000004 if exists('s:transpose_plugin_loaded')
                              finish
                            endif
    1              0.000002 let s:transpose_plugin_loaded = 1
                            
    1              0.000002 if !exists('g:transpose_keepindent')
    1              0.000002   let g:transpose_keepindent = 1
    1              0.000001 endif
                            
    1              0.000006 command -range=% -nargs=0 -bar Transpose
                                  \ call transpose#block  (<line1>, <line2>)
                            
    1              0.000005 command -range=% -nargs=? -bar TransposeWords
                                  \ call transpose#words  (<line1>, <line2>, <f-args>)
                            
    1              0.000005 command -range=% -nargs=0 -bar TransposeTab
                                  \ call transpose#tab    (<line1>, <line2>)
                            
    1              0.000005 command -range=% -nargs=* -bar TransposeCSV
                                  \ call transpose#csv    (<line1>, <line2>, <f-args>)
                            
    1              0.000004 command -range=% -nargs=0 -bar TransposeInteractive
                                  \ call transpose#interactive(<line1>, <line2>)
                            
    1              0.000008 command -nargs=0 -bar TransposeIndentToggle
                                  \ let g:transpose_keepindent = 1 - g:transpose_keepindent
                            
                            " vim: ts=2 sw=2 et tw=80 colorcolumn=+1

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/auto-pairs/plugin/auto-pairs.vim
Sourced 1 time
Total time:   0.000476
 Self time:   0.000476

count  total (s)   self (s)
                            " Insert or delete brackets, parens, quotes in pairs.
                            " Maintainer:	JiangMiao <jiangfriend@gmail.com>
                            " Contributor: camthompson
                            " Last Change:  2017-06-17
                            " Version: 1.3.3
                            " Homepage: http://www.vim.org/scripts/script.php?script_id=3599
                            " Repository: https://github.com/jiangmiao/auto-pairs
                            " License: MIT
                            
    1              0.000006 if exists('g:AutoPairsLoaded') || &cp
                              finish
                            end
    1              0.000002 let g:AutoPairsLoaded = 1
                            
    1              0.000002 if !exists('g:AutoPairs')
    1              0.000005   let g:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`'}
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsParens')
    1              0.000003   let g:AutoPairsParens = {'(':')', '[':']', '{':'}'}
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsMapBS')
    1              0.000001   let g:AutoPairsMapBS = 1
    1              0.000001 end
                            
                            " Map <C-h> as the same BS
    1              0.000002 if !exists('g:AutoPairsMapCh')
    1              0.000001   let g:AutoPairsMapCh = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsMapCR')
    1              0.000001   let g:AutoPairsMapCR = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsMapSpace')
    1              0.000001   let g:AutoPairsMapSpace = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsCenterLine')
    1              0.000001   let g:AutoPairsCenterLine = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsShortcutToggle')
    1              0.000002   let g:AutoPairsShortcutToggle = '<M-p>'
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsShortcutFastWrap')
    1              0.000002   let g:AutoPairsShortcutFastWrap = '<M-e>'
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsMoveCharacter')
    1              0.000002   let g:AutoPairsMoveCharacter = "()[]{}\"'"
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsShortcutJump')
    1              0.000001   let g:AutoPairsShortcutJump = '<M-n>'
    1              0.000001 endif
                            
                            " Fly mode will for closed pair to jump to closed pair instead of insert.
                            " also support AutoPairsBackInsert to insert pairs where jumped.
    1              0.000002 if !exists('g:AutoPairsFlyMode')
    1              0.000001   let g:AutoPairsFlyMode = 0
    1              0.000001 endif
                            
                            " When skipping the closed pair, look at the current and
                            " next line as well.
    1              0.000002 if !exists('g:AutoPairsMultilineClose')
    1              0.000001   let g:AutoPairsMultilineClose = 1
    1              0.000001 endif
                            
                            " Work with Fly Mode, insert pair where jumped
    1              0.000002 if !exists('g:AutoPairsShortcutBackInsert')
    1              0.000002   let g:AutoPairsShortcutBackInsert = '<M-b>'
    1              0.000001 endif
                            
    1              0.000002 if !exists('g:AutoPairsSmartQuotes')
    1              0.000001   let g:AutoPairsSmartQuotes = 1
    1              0.000001 endif
                            
                            " 7.4.849 support <C-G>U to avoid breaking '.'
                            " Issue talk: https://github.com/jiangmiao/auto-pairs/issues/3
                            " Vim note: https://github.com/vim/vim/releases/tag/v7.4.849
    1              0.000003 if v:version > 704 || v:version == 704 && has("patch849")
    1              0.000002   let s:Go = "\<C-G>U"
    1              0.000001 else
                              let s:Go = ""
                            endif
                            
    1              0.000003 let s:Left = s:Go."\<LEFT>"
    1              0.000002 let s:Right = s:Go."\<RIGHT>"
                            
                            
                            " Will auto generated {']' => '[', ..., '}' => '{'}in initialize.
    1              0.000002 let g:AutoPairsClosedPairs = {}
                            
                            
    1              0.000002 function! AutoPairsInsert(key)
                              if !b:autopairs_enabled
                                return a:key
                              end
                            
                              let line = getline('.')
                              let pos = col('.') - 1
                              let before = strpart(line, 0, pos)
                              let after = strpart(line, pos)
                              let next_chars = split(after, '\zs')
                              let current_char = get(next_chars, 0, '')
                              let next_char = get(next_chars, 1, '')
                              let prev_chars = split(before, '\zs')
                              let prev_char = get(prev_chars, -1, '')
                            
                              let eol = 0
                              if col('$') -  col('.') <= 1
                                let eol = 1
                              end
                            
                              " Ignore auto close if prev character is \
                              if prev_char == '\'
                                return a:key
                              end
                            
                              " The key is difference open-pair, then it means only for ) ] } by default
                              if !has_key(b:AutoPairs, a:key)
                                let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                                " Skip the character if current character is the same as input
                                if current_char == a:key
                                  return s:Right
                                end
                            
                                if !g:AutoPairsFlyMode
                                  " Skip the character if next character is space
                                  if current_char == ' ' && next_char == a:key
                                    return s:Right.s:Right
                                  end
                            
                                  " Skip the character if closed pair is next character
                                  if current_char == ''
                                    if g:AutoPairsMultilineClose
                                      let next_lineno = line('.')+1
                                      let next_line = getline(nextnonblank(next_lineno))
                                      let next_char = matchstr(next_line, '\s*\zs.')
                                    else
                                      let next_char = matchstr(line, '\s*\zs.')
                                    end
                                    if next_char == a:key
                                      return "\<ESC>e^a"
                                    endif
                                  endif
                                endif
                            
                                " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                                if g:AutoPairsFlyMode && has_key(b:AutoPairsClosedPairs, a:key)
                                  let n = stridx(after, a:key)
                                  if n != -1
                                    return repeat(s:Right, n+1)
                                  end
                                  if search(a:key, 'W')
                                    " force break the '.' when jump to different line
                                    return "\<Right>"
                                  endif
                                endif
                            
                                " Insert directly if the key is not an open key
                                return a:key
                              end
                            
                              let open = a:key
                              let close = b:AutoPairs[open]
                            
                              if current_char == close && open == close
                                return s:Right
                              end
                            
                              " Ignore auto close ' if follows a word
                              " MUST after closed check. 'hello|'
                              if a:key == "'" && prev_char =~ '\v\w'
                                return a:key
                              end
                            
                              " support for ''' ``` and """
                              if open == close
                                " The key must be ' " `
                                let pprev_char = line[col('.')-3]
                                if pprev_char == open && prev_char == open
                                  " Double pair found
                                  return repeat(a:key, 4) . repeat(s:Left, 3)
                                end
                              end
                            
                              let quotes_num = 0
                              " Ignore comment line for vim file
                              if &filetype == 'vim' && a:key == '"'
                                if before =~ '^\s*$'
                                  return a:key
                                end
                                if before =~ '^\s*"'
                                  let quotes_num = -1
                                end
                              end
                            
                              " Keep quote number is odd.
                              " Because quotes should be matched in the same line in most of situation
                              if g:AutoPairsSmartQuotes && open == close
                                " Remove \\ \" \'
                                let cleaned_line = substitute(line, '\v(\\.)', '', 'g')
                                let n = quotes_num
                                let pos = 0
                                while 1
                                  let pos = stridx(cleaned_line, open, pos)
                                  if pos == -1
                                    break
                                  end
                                  let n = n + 1
                                  let pos = pos + 1
                                endwhile
                                if n % 2 == 1
                                  return a:key
                                endif
                              endif
                            
                              return open.close.s:Left
                            endfunction
                            
    1              0.000001 function! AutoPairsDelete()
                              if !b:autopairs_enabled
                                return "\<BS>"
                              end
                            
                              let line = getline('.')
                              let pos = col('.') - 1
                              let current_char = get(split(strpart(line, pos), '\zs'), 0, '')
                              let prev_chars = split(strpart(line, 0, pos), '\zs')
                              let prev_char = get(prev_chars, -1, '')
                              let pprev_char = get(prev_chars, -2, '')
                            
                              if pprev_char == '\'
                                return "\<BS>"
                              end
                            
                              " Delete last two spaces in parens, work with MapSpace
                              if has_key(b:AutoPairs, pprev_char) && prev_char == ' ' && current_char == ' '
                                return "\<BS>\<DEL>"
                              endif
                            
                              " Delete Repeated Pair eg: '''|''' [[|]] {{|}}
                              if has_key(b:AutoPairs, prev_char)
                                let times = 0
                                let p = -1
                                while get(prev_chars, p, '') == prev_char
                                  let p = p - 1
                                  let times = times + 1
                                endwhile
                            
                                let close = b:AutoPairs[prev_char]
                                let left = repeat(prev_char, times)
                                let right = repeat(close, times)
                            
                                let before = strpart(line, pos-times, times)
                                let after  = strpart(line, pos, times)
                                if left == before && right == after
                                  return repeat("\<BS>\<DEL>", times)
                                end
                              end
                            
                            
                              if has_key(b:AutoPairs, prev_char)
                                let close = b:AutoPairs[prev_char]
                                if match(line,'^\s*'.close, col('.')-1) != -1
                                  " Delete (|___)
                                  let space = matchstr(line, '^\s*', col('.')-1)
                                  return "\<BS>". repeat("\<DEL>", len(space)+1)
                                elseif match(line, '^\s*$', col('.')-1) != -1
                                  " Delete (|__\n___)
                                  let nline = getline(line('.')+1)
                                  if nline =~ '^\s*'.close
                                    if &filetype == 'vim' && prev_char == '"'
                                      " Keep next line's comment
                                      return "\<BS>"
                                    end
                            
                                    let space = matchstr(nline, '^\s*')
                                    return "\<BS>\<DEL>". repeat("\<DEL>", len(space)+1)
                                  end
                                end
                              end
                            
                              return "\<BS>"
                            endfunction
                            
    1              0.000001 function! AutoPairsJump()
                              call search('["\]'')}]','W')
                            endfunction
                            " string_chunk cannot use standalone
    1              0.000002 let s:string_chunk = '\v%(\\\_.|[^\1]|[\r\n]){-}'
    1              0.000003 let s:ss_pattern = '\v''' . s:string_chunk . ''''
    1              0.000002 let s:ds_pattern = '\v"'  . s:string_chunk . '"'
                            
    1              0.000002 func! s:RegexpQuote(str)
                              return substitute(a:str, '\v[\[\{\(\<\>\)\}\]]', '\\&', 'g')
                            endf
                            
    1              0.000001 func! s:RegexpQuoteInSquare(str)
                              return substitute(a:str, '\v[\[\]]', '\\&', 'g')
                            endf
                            
                            " Search next open or close pair
    1              0.000002 func! s:FormatChunk(open, close)
                              let open = s:RegexpQuote(a:open)
                              let close = s:RegexpQuote(a:close)
                              let open2 = s:RegexpQuoteInSquare(a:open)
                              let close2 = s:RegexpQuoteInSquare(a:close)
                              if open == close
                                return '\v'.open.s:string_chunk.close
                              else
                                return '\v%(' . s:ss_pattern . '|' . s:ds_pattern . '|' . '[^'.open2.close2.']|[\r\n]' . '){-}(['.open2.close2.'])'
                              end
                            endf
                            
                            " Fast wrap the word in brackets
    1              0.000001 function! AutoPairsFastWrap()
                              let line = getline('.')
                              let current_char = line[col('.')-1]
                              let next_char = line[col('.')]
                              let open_pair_pattern = '\v[({\[''"]'
                              let at_end = col('.') >= col('$') - 1
                              normal! x
                              " Skip blank
                              if next_char =~ '\v\s' || at_end
                                call search('\v\S', 'W')
                                let line = getline('.')
                                let next_char = line[col('.')-1]
                              end
                            
                              if has_key(b:AutoPairs, next_char)
                                let followed_open_pair = next_char
                                let inputed_close_pair = current_char
                                let followed_close_pair = b:AutoPairs[next_char]
                                if followed_close_pair != followed_open_pair
                                  " TODO replace system searchpair to skip string and nested pair.
                                  " eg: (|){"hello}world"} will transform to ({"hello})world"}
                                  call searchpair('\V'.followed_open_pair, '', '\V'.followed_close_pair, 'W')
                                else
                                  call search(s:FormatChunk(followed_open_pair, followed_close_pair), 'We')
                                end
                                return s:Right.inputed_close_pair.s:Left
                              else
                                normal! he
                                return s:Right.current_char.s:Left
                              end
                            endfunction
                            
    1              0.000001 function! AutoPairsMap(key)
                              " | is special key which separate map command from text
                              let key = a:key
                              if key == '|'
                                let key = '<BAR>'
                              end
                              let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
                              execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
                            
                            endfunction
                            
    1              0.000001 function! AutoPairsToggle()
                              if b:autopairs_enabled
                                let b:autopairs_enabled = 0
                                echo 'AutoPairs Disabled.'
                              else
                                let b:autopairs_enabled = 1
                                echo 'AutoPairs Enabled.'
                              end
                              return ''
                            endfunction
                            
    1              0.000001 function! AutoPairsMoveCharacter(key)
                              let c = getline(".")[col(".")-1]
                              let escaped_key = substitute(a:key, "'", "''", 'g')
                              return "\<DEL>\<ESC>:call search("."'".escaped_key."'".")\<CR>a".c."\<LEFT>"
                            endfunction
                            
    1              0.000001 function! AutoPairsReturn()
                              if b:autopairs_enabled == 0
                                return ''
                              end
                              let line = getline('.')
                              let pline = getline(line('.')-1)
                              let prev_char = pline[strlen(pline)-1]
                              let cmd = ''
                              let cur_char = line[col('.')-1]
                              if has_key(b:AutoPairs, prev_char) && b:AutoPairs[prev_char] == cur_char
                                if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                  " Recenter before adding new line to avoid replacing line content
                                  let cmd = "zz"
                                end
                            
                                " If equalprg has been set, then avoid call =
                                " https://github.com/jiangmiao/auto-pairs/issues/24
                                if &equalprg != ''
                                  return "\<ESC>".cmd."O"
                                endif
                            
                                " conflict with javascript and coffee
                                " javascript   need   indent new line
                                " coffeescript forbid indent new line
                                if &filetype == 'coffeescript' || &filetype == 'coffee'
                                  return "\<ESC>".cmd."k==o"
                                else
                                  return "\<ESC>".cmd."=ko"
                                endif
                              end
                              return ''
                            endfunction
                            
    1              0.000001 function! AutoPairsSpace()
                              let line = getline('.')
                              let prev_char = line[col('.')-2]
                              let cmd = ''
                              let cur_char =line[col('.')-1]
                              if has_key(g:AutoPairsParens, prev_char) && g:AutoPairsParens[prev_char] == cur_char
                                let cmd = "\<SPACE>".s:Left
                              endif
                              return "\<SPACE>".cmd
                            endfunction
                            
    1              0.000001 function! AutoPairsBackInsert()
                              if exists('b:autopairs_saved_pair')
                                let pair = b:autopairs_saved_pair[0]
                                let pos  = b:autopairs_saved_pair[1]
                                call setpos('.', pos)
                                return pair
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! AutoPairsInit()
                              let b:autopairs_loaded  = 1
                              if !exists('b:autopairs_enabled')
                                let b:autopairs_enabled = 1
                              end
                              let b:AutoPairsClosedPairs = {}
                            
                              if !exists('b:AutoPairs')
                                let b:AutoPairs = g:AutoPairs
                              end
                            
                              if !exists('b:AutoPairsMoveCharacter')
                                let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
                              end
                            
                              " buffer level map pairs keys
                              for [open, close] in items(b:AutoPairs)
                                call AutoPairsMap(open)
                                if open != close
                                  call AutoPairsMap(close)
                                end
                                let b:AutoPairsClosedPairs[close] = open
                              endfor
                            
                              for key in split(b:AutoPairsMoveCharacter, '\s*')
                                let escaped_key = substitute(key, "'", "''", 'g')
                                execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
                              endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
                              if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
                                execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
                              end
                            
                              if g:AutoPairsMapCh
                                execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
                              endif
                            
                              if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
                                let do_abbrev = ""
                                if v:version == 703 && has("patch489") || v:version > 703
                                  let do_abbrev = "<C-]>"
                                endif
                                execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
                              end
                            
                              if g:AutoPairsShortcutFastWrap != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
                              end
                            
                              if g:AutoPairsShortcutBackInsert != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
                              end
                            
                              if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
                                execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
                                execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
                              end
                            
                              if g:AutoPairsShortcutJump != ''
                                execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
                                execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
                              end
                            
                            endfunction
                            
    1              0.000001 function! s:ExpandMap(map)
                              let map = a:map
                              let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
                              return map
                            endfunction
                            
    1              0.000001 function! AutoPairsTryInit()
                              if exists('b:autopairs_loaded')
                                return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
                              if g:AutoPairsMapCR
                                if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
                                  let info = maparg('<CR>', 'i', 0, 1)
                                  if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
                                if old_cr !~ 'AutoPairsReturn'
                                  if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
                                  execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
                                end
                              endif
                              call AutoPairsInit()
                            endfunction
                            
                            " Always silent the command
    1              0.000007 inoremap <silent> <SID>AutoPairsReturn <C-R>=AutoPairsReturn()<CR>
    1              0.000007 imap <script> <Plug>AutoPairsReturn <SID>AutoPairsReturn
                            
                            
    1              0.000007 au BufEnter * :call AutoPairsTryInit()

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/supertab/plugin/supertab.vim
Sourced 1 time
Total time:   0.001015
 Self time:   0.000970

count  total (s)   self (s)
                            " Author: Eric Van Dewoestine <ervandew@gmail.com>
                            "         Original concept and versions up to 0.32 written by
                            "         Gergely Kontra <kgergely@mcl.hu>
                            " Version: 2.1
                            " GetLatestVimScripts: 1643 1 :AutoInstall: supertab.vim
                            "
                            " Description: {{{
                            "   Use your tab key to do all your completion in insert mode!
                            "   You can cycle forward and backward with the <Tab> and <S-Tab> keys
                            "   Note: you must press <Tab> once to be able to cycle back
                            "
                            "   http://www.vim.org/scripts/script.php?script_id=1643
                            " }}}
                            "
                            " License: {{{
                            "   Copyright (c) 2002 - 2016
                            "   All rights reserved.
                            "
                            "   Redistribution and use of this software in source and binary forms, with
                            "   or without modification, are permitted provided that the following
                            "   conditions are met:
                            "
                            "   * Redistributions of source code must retain the above
                            "     copyright notice, this list of conditions and the
                            "     following disclaimer.
                            "
                            "   * Redistributions in binary form must reproduce the above
                            "     copyright notice, this list of conditions and the
                            "     following disclaimer in the documentation and/or other
                            "     materials provided with the distribution.
                            "
                            "   * Neither the name of Gergely Kontra or Eric Van Dewoestine nor the names
                            "   of its contributors may be used to endorse or promote products derived
                            "   from this software without specific prior written permission of Gergely
                            "   Kontra or Eric Van Dewoestine.
                            "
                            "   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
                            "   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
                            "   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
                            "   PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
                            "   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                            "   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
                            "   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
                            "   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                            "   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                            "   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                            "   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            " }}}
                            "
                            " Testing Info: {{{
                            "   Running vim + supertab with the absolute bare minimum settings:
                            "     $ vim -u NONE -U NONE -c "set nocp | runtime plugin/supertab.vim"
                            " }}}
                            
    1              0.000003 if v:version < 700
                              finish
                            endif
                            
    1              0.000003 if exists('complType') " Integration with other completion functions.
                              finish
                            endif
                            
    1              0.000002 if exists("loaded_supertab")
                              finish
                            endif
    1              0.000004 let loaded_supertab = 1
                            
    1              0.000004 let s:save_cpo=&cpo
    1              0.000004 set cpo&vim
                            
                            " Global Variables {{{
                            
    1              0.000003   if !exists("g:SuperTabDefaultCompletionType")
                                let g:SuperTabDefaultCompletionType = "<c-p>"
                              endif
                            
    1              0.000002   if !exists("g:SuperTabContextDefaultCompletionType")
    1              0.000002     let g:SuperTabContextDefaultCompletionType = "<c-p>"
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabContextTextMemberPatterns")
    1              0.000003     let g:SuperTabContextTextMemberPatterns = ['\.', '>\?::', '->']
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabCompletionContexts")
    1              0.000002     let g:SuperTabCompletionContexts = ['s:ContextText']
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabRetainCompletionDuration")
    1              0.000002     let g:SuperTabRetainCompletionDuration = 'insert'
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabNoCompleteBefore")
                                " retain backwards compatability
    1              0.000003     if exists("g:SuperTabMidWordCompletion") && !g:SuperTabMidWordCompletion
                                  let g:SuperTabNoCompleteBefore = ['\k']
                                else
    1              0.000004       let g:SuperTabNoCompleteBefore = []
    1              0.000001     endif
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabNoCompleteAfter")
                                " retain backwards compatability
    1              0.000002     if exists("g:SuperTabLeadingSpaceCompletion") && g:SuperTabLeadingSpaceCompletion
                                  let g:SuperTabNoCompleteAfter = []
                                else
    1              0.000002       let g:SuperTabNoCompleteAfter = ['^', '\s']
    1              0.000001     endif
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabMappingForward")
    1              0.000002     let g:SuperTabMappingForward = '<tab>'
    1              0.000001   endif
    1              0.000002   if !exists("g:SuperTabMappingBackward")
    1              0.000001     let g:SuperTabMappingBackward = '<s-tab>'
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabMappingTabLiteral")
    1              0.000001     let g:SuperTabMappingTabLiteral = '<c-tab>'
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabLongestEnhanced")
    1              0.000001     let g:SuperTabLongestEnhanced = 0
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabLongestHighlight")
    1              0.000001     let g:SuperTabLongestHighlight = 0
    1              0.000001   endif
                            
    1              0.000003   if !exists("g:SuperTabCrMapping")
    1              0.000001     let g:SuperTabCrMapping = 0
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabClosePreviewOnPopupClose")
    1              0.000001     let g:SuperTabClosePreviewOnPopupClose = 0
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabUndoBreak")
    1              0.000001     let g:SuperTabUndoBreak = 0
    1              0.000001   endif
                            
    1              0.000002   if !exists("g:SuperTabCompleteCase")
    1              0.000001     let g:SuperTabCompleteCase = 'inherit'
    1              0.000001   endif
                            
                            " }}}
                            
                            " Script Variables {{{
                            
                              " construct the help text.
    1              0.000027   let s:tabHelp =
                                \ "Hit <CR> or CTRL-] on the completion type you wish to switch to.\n" .
                                \ "Use :help ins-completion for more information.\n" .
                                \ "\n" .
                                \ "|<c-n>|      - Keywords in 'complete' searching down.\n" .
                                \ "|<c-p>|      - Keywords in 'complete' searching up (SuperTab default).\n" .
                                \ "|<c-x><c-l>| - Whole lines.\n" .
                                \ "|<c-x><c-n>| - Keywords in current file.\n" .
                                \ "|<c-x><c-k>| - Keywords in 'dictionary'.\n" .
                                \ "|<c-x><c-t>| - Keywords in 'thesaurus', thesaurus-style.\n" .
                                \ "|<c-x><c-i>| - Keywords in the current and included files.\n" .
                                \ "|<c-x><c-]>| - Tags.\n" .
                                \ "|<c-x><c-f>| - File names.\n" .
                                \ "|<c-x><c-d>| - Definitions or macros.\n" .
                                \ "|<c-x><c-v>| - Vim command-line.\n" .
                                \ "|<c-x><c-u>| - User defined completion.\n" .
                                \ "|<c-x><c-o>| - Omni completion.\n" .
                                \ "|<c-x>s|     - Spelling suggestions."
                            
                              " set the available completion types and modes.
    1              0.000006   let s:types =
                                \ "\<c-e>\<c-y>\<c-l>\<c-n>\<c-k>\<c-t>\<c-i>\<c-]>" .
                                \ "\<c-f>\<c-d>\<c-v>\<c-n>\<c-p>\<c-u>\<c-o>\<c-n>\<c-p>s"
    1              0.000002   let s:modes = '/^E/^Y/^L/^N/^K/^T/^I/^]/^F/^D/^V/^P/^U/^O/s'
    1              0.000002   let s:types = s:types . "np"
    1              0.000002   let s:modes = s:modes . '/n/p'
                            
                            " }}}
                            
    1              0.000002 function! SuperTabSetDefaultCompletionType(type) " {{{
                              " Globally available function that users can use to set the default
                              " completion type for the current buffer, like in an ftplugin.
                            
                              " don't allow overriding what SuperTabChain has set, otherwise chaining may
                              " not work.
                              if exists('b:SuperTabChain')
                                return
                              endif
                            
                              " init hack for <c-x><c-v> workaround.
                              let b:complCommandLine = 0
                            
                              let b:SuperTabDefaultCompletionType = a:type
                            
                              " set the current completion type to the default
                              call SuperTabSetCompletionType(b:SuperTabDefaultCompletionType)
                            endfunction " }}}
                            
    1              0.000002 function! SuperTabSetCompletionType(type) " {{{
                              " Globally available function that users can use to create mappings to quickly
                              " switch completion modes.  Useful when a user wants to restore the default or
                              " switch to another mode without having to kick off a completion of that type
                              " or use SuperTabHelp.  Note, this function only changes the current
                              " completion type, not the default, meaning that the default will still be
                              " restored once the configured retension duration has been met (see
                              " g:SuperTabRetainCompletionDuration).  To change the default for the current
                              " buffer, use SuperTabDefaultCompletionType(type) instead.  Example mapping to
                              " restore SuperTab default:
                              "   nmap <F6> :call SetSuperTabCompletionType("<c-p>")<cr>
                            
                              " don't allow overriding what SuperTabChain has set, otherwise chaining may
                              " not work.
                              if exists('b:SuperTabChain')
                                return
                              endif
                            
                              call s:InitBuffer()
                              exec "let b:complType = \"" . escape(a:type, '<') . "\""
                            endfunction " }}}
                            
    1              0.000001 function! SuperTabAlternateCompletion(type) " {{{
                              " Function which can be mapped to a key to kick off an alternate completion
                              " other than the default.  For instance, if you have 'context' as the default
                              " and want to map ctrl+space to issue keyword completion.
                              " Note: due to the way vim expands ctrl characters in mappings, you cannot
                              " create the alternate mapping like so:
                              "    imap <c-space> <c-r>=SuperTabAlternateCompletion("<c-p>")<cr>
                              " instead, you have to use \<lt> to prevent vim from expanding the key
                              " when creating the mapping.
                              "    gvim:
                              "      imap <c-space> <c-r>=SuperTabAlternateCompletion("\<lt>c-p>")<cr>
                              "    console:
                              "      imap <nul> <c-r>=SuperTabAlternateCompletion("\<lt>c-p>")<cr>
                            
                              call SuperTabSetCompletionType(a:type)
                              " end any current completion before attempting to start the new one.
                              " use feedkeys to prevent possible remapping of <c-e> from causing issues.
                              "call feedkeys("\<c-e>", 'n')
                              " ^ since we can't detect completion mode vs regular insert mode, we force
                              " vim into keyword completion mode and end that mode to prevent the regular
                              " insert behavior of <c-e> from occurring.
                              call feedkeys("\<c-x>\<c-p>\<c-e>", 'n')
                              call feedkeys(b:complType, 'n')
                              return ''
                            endfunction " }}}
                            
    1              0.000001 function! SuperTabLongestHighlight(dir) " {{{
                              " When longest highlight is enabled, this function is used to do the actual
                              " selection of the completion popup entry.
                            
                              if !pumvisible()
                                return ''
                              endif
                              return a:dir == -1 ? "\<up>" : "\<down>"
                            endfunction " }}}
                            
    1              0.000002 function! s:Init() " {{{
                              " Setup mechanism to restore original completion type upon leaving insert
                              " mode if configured to do so
                              if g:SuperTabRetainCompletionDuration == 'insert'
                                augroup supertab_retain
                                  autocmd!
                                  autocmd InsertLeave * call s:SetDefaultCompletionType()
                                augroup END
                              endif
                            endfunction " }}}
                            
    1              0.000001 function! s:InitBuffer() " {{{
                              if exists('b:SuperTabNoCompleteBefore')
                                return
                              endif
                            
                              let b:complReset = 0
                              let b:complTypeManual = !exists('b:complTypeManual') ? '' : b:complTypeManual
                              let b:complTypeContext = ''
                            
                              " init hack for <c-x><c-v> workaround.
                              let b:complCommandLine = 0
                            
                              if !exists('b:SuperTabNoCompleteBefore')
                                let b:SuperTabNoCompleteBefore = g:SuperTabNoCompleteBefore
                              endif
                              if !exists('b:SuperTabNoCompleteAfter')
                                let b:SuperTabNoCompleteAfter = g:SuperTabNoCompleteAfter
                              endif
                            
                              if !exists('b:SuperTabDefaultCompletionType')
                                let b:SuperTabDefaultCompletionType = g:SuperTabDefaultCompletionType
                              endif
                            
                              if !exists('b:SuperTabContextDefaultCompletionType')
                                let b:SuperTabContextDefaultCompletionType =
                                  \ g:SuperTabContextDefaultCompletionType
                              endif
                            
                              " set the current completion type to the default
                              call SuperTabSetCompletionType(b:SuperTabDefaultCompletionType)
                            
                              " hack to programatically revert a change to snipmate that breaks supertab
                              " but which the new maintainers don't care about:
                              " http://github.com/garbas/vim-snipmate/issues/37
                              let snipmate = maparg('<tab>', 'i')
                              if snipmate =~ '<C-G>u' && g:SuperTabMappingForward =~? '<tab>'
                                let snipmate = substitute(snipmate, '<C-G>u', '', '')
                                iunmap <tab>
                                exec "inoremap <silent> <tab> " . snipmate
                              endif
                            endfunction " }}}
                            
    1              0.000001 function! s:ManualCompletionEnter() " {{{
                              " Handles manual entrance into completion mode.
                            
                              if &smd
                                echo '' | echohl ModeMsg | echo '-- ^X++ mode (' . s:modes . ')' | echohl None
                              endif
                              let complType = nr2char(getchar())
                              if stridx(s:types, complType) != -1
                                if !exists('b:supertab_close_preview')
                                  let b:supertab_close_preview = !s:IsPreviewOpen()
                                endif
                            
                                if stridx("\<c-e>\<c-y>", complType) != -1 " no memory, just scroll...
                                  return "\<c-x>" . complType
                                elseif stridx('np', complType) != -1
                                  let complType = nr2char(char2nr(complType) - 96)
                                else
                                  let complType = "\<c-x>" . complType
                                endif
                            
                                let b:complTypeManual = complType
                            
                                if index(['insert', 'session'], g:SuperTabRetainCompletionDuration) != -1
                                  let b:complType = complType
                                endif
                            
                                " Hack to workaround bug when invoking command line completion via <c-r>=
                                if complType == "\<c-x>\<c-v>"
                                  return s:CommandLineCompletion()
                                endif
                            
                                call s:InitBuffer()
                            
                                " optionally enable enhanced longest completion
                                if g:SuperTabLongestEnhanced && &completeopt =~ 'longest'
                                  call s:EnableLongestEnhancement()
                                " handle backspacing which triggers g:SuperTabNoCompleteAfter match
                                elseif s:IsNoCompleteAfterReset()
                                  call s:EnableNoCompleteAfterReset()
                                endif
                            
                                if g:SuperTabLongestHighlight &&
                                 \ &completeopt =~ 'longest' &&
                                 \ &completeopt =~ 'menu' &&
                                 \ !s:CompletionMode()
                                  let dir = (complType == "\<c-x>\<c-p>") ? -1 : 1
                                  call feedkeys("\<c-r>=SuperTabLongestHighlight(" . dir . ")\<cr>", 'n')
                                endif
                            
                                call s:StartCompletionMode()
                                return complType
                              endif
                            
                              echohl "Unknown mode"
                              return complType
                            endfunction " }}}
                            
    1              0.000001 function! s:SetCompletionType() " {{{
                              " Sets the completion type based on what the user has chosen from the help
                              " buffer.
                            
                              let chosen = substitute(getline('.'), '.*|\(.*\)|.*', '\1', '')
                              if chosen != getline('.')
                                let winnr = b:winnr
                                close
                                exec winnr . 'winc w'
                                call SuperTabSetCompletionType(chosen)
                              endif
                            endfunction " }}}
                            
    1              0.000001 function! s:SetDefaultCompletionType() " {{{
                              if exists('b:SuperTabDefaultCompletionType') &&
                              \ (!exists('b:complCommandLine') || !b:complCommandLine)
                                call SuperTabSetCompletionType(b:SuperTabDefaultCompletionType)
                              endif
                            endfunction " }}}
                            
    1              0.000001 function! SuperTab(command) " {{{
                              " Used to perform proper cycle navigation as the user requests the next or
                              " previous entry in a completion list, and determines whether or not to simply
                              " retain the normal usage of <tab> based on the cursor position.
                            
                              if exists('b:SuperTabDisabled') && b:SuperTabDisabled
                                if exists('s:Tab')
                                  return s:Tab()
                                endif
                                return (
                                    \ g:SuperTabMappingForward ==? '<tab>' ||
                                    \ g:SuperTabMappingBackward ==? '<tab>'
                                  \ ) ? "\<tab>" : ''
                              endif
                            
                              call s:InitBuffer()
                            
                              if s:WillComplete()
                                if !exists('b:supertab_close_preview')
                                  let b:supertab_close_preview = !s:IsPreviewOpen()
                                endif
                            
                                " optionally enable enhanced longest completion
                                if g:SuperTabLongestEnhanced && &completeopt =~ 'longest'
                                  call s:EnableLongestEnhancement()
                                " handle backspacing which triggers g:SuperTabNoCompleteAfter match
                                elseif s:IsNoCompleteAfterReset()
                                  call s:EnableNoCompleteAfterReset()
                                endif
                            
                                if !s:CompletionMode()
                                  let b:complTypeManual = ''
                                endif
                            
                                " exception: if in <c-p> mode, then <c-n> should move up the list, and
                                " <c-p> down the list.
                                if a:command == 'p' && !b:complReset &&
                                  \ (b:complType == "\<c-p>" ||
                                  \   (b:complType == 'context' &&
                                  \    b:complTypeManual == '' &&
                                  \    b:complTypeContext == "\<c-p>"))
                                  return "\<c-n>"
                            
                                elseif a:command == 'p' && !b:complReset &&
                                  \ (b:complType == "\<c-n>" ||
                                  \   (b:complType == 'context' &&
                                  \    b:complTypeManual == '' &&
                                  \    b:complTypeContext == "\<c-n>"))
                                  return "\<c-p>"
                            
                                " already in completion mode and not resetting for longest enhancement, so
                                " just scroll to next/previous
                                elseif s:CompletionMode() && !b:complReset
                                  let type = b:complType == 'context' ? b:complTypeContext : b:complType
                                  if a:command == 'n'
                                    return type == "\<c-p>" || type == "\<c-x>\<c-p>" ? "\<c-p>" : "\<c-n>"
                                  endif
                                  return type == "\<c-p>" || type == "\<c-x>\<c-p>" ? "\<c-n>" : "\<c-p>"
                                endif
                            
                                " handle 'context' completion.
                                if b:complType == 'context'
                                  let complType = s:ContextCompletion()
                                  if complType == ''
                                    exec "let complType = \"" .
                                      \ escape(b:SuperTabContextDefaultCompletionType, '<') . "\""
                                  endif
                                  let b:complTypeContext = complType
                            
                                " Hack to workaround bug when invoking command line completion via <c-r>=
                                elseif b:complType == "\<c-x>\<c-v>"
                                  let complType = s:CommandLineCompletion()
                                else
                                  let complType = b:complType
                                endif
                            
                                " switch <c-x><c-p> / <c-x><c-n> completion in <c-p> mode
                                if a:command == 'p'
                                  if complType == "\<c-x>\<c-p>"
                                    let complType = "\<c-x>\<c-n>"
                                  elseif complType == "\<c-x>\<c-n>"
                                    let complType = "\<c-x>\<c-p>"
                                  endif
                                endif
                            
                                " highlight first result if longest enabled
                                if g:SuperTabLongestHighlight &&
                                 \ &completeopt =~ 'longest' &&
                                 \ &completeopt =~ 'menu' &&
                                 \ (!s:CompletionMode() || b:complReset)
                                  let dir = (complType == "\<c-p>") ? -1 : 1
                                  call feedkeys("\<c-r>=SuperTabLongestHighlight(" . dir . ")\<cr>", 'n')
                                endif
                            
                                if b:complReset
                                  let b:complReset = 0
                                  " not an accurate condition for everyone, but better than sending <c-e>
                                  " at the wrong time.
                                  if s:CompletionMode()
                                    return "\<c-e>" . complType
                                  endif
                                endif
                            
                                if g:SuperTabUndoBreak && !s:CompletionMode()
                                  call s:StartCompletionMode()
                                  return "\<c-g>u" . complType
                                endif
                            
                                if g:SuperTabCompleteCase == 'ignore' ||
                                 \ g:SuperTabCompleteCase == 'match'
                                  if exists('##CompleteDone')
                                    let ignorecase = g:SuperTabCompleteCase == 'ignore' ? 1 : 0
                                    if &ignorecase != ignorecase
                                      let b:supertab_ignorecase_save = &ignorecase
                                      let &ignorecase = ignorecase
                                      augroup supertab_ignorecase
                                        autocmd CompleteDone <buffer>
                                          \ let &ignorecase = b:supertab_ignorecase_save |
                                          \ unlet b:supertab_ignorecase_save |
                                          \ autocmd! supertab_ignorecase
                                      augroup END
                                    endif
                                  endif
                                endif
                            
                                call s:StartCompletionMode()
                                return complType
                              endif
                            
                              if (a:command == 'n' && g:SuperTabMappingForward ==? '<tab>') ||
                               \ (a:command == 'p' && g:SuperTabMappingBackward ==? '<tab>')
                            
                                " trigger our func ref to the smart tabs plugin if present.
                                if exists('s:Tab')
                                  return s:Tab()
                                endif
                            
                                return "\<tab>"
                              endif
                            
                              if (a:command == 'n' && g:SuperTabMappingForward ==? '<s-tab>') ||
                               \ (a:command == 'p' && g:SuperTabMappingBackward ==? '<s-tab>')
                                " support triggering <s-tab> mappings users might have.
                                if exists('s:ShiftTab')
                                  if type(s:ShiftTab) == 2
                                    return s:ShiftTab()
                                  else
                                    call feedkeys(s:ShiftTab, 'n')
                                  endif
                                endif
                              endif
                            
                              return ''
                            endfunction " }}}
                            
    1              0.000001 function! s:SuperTabHelp() " {{{
                              " Opens a help window where the user can choose a completion type to enter.
                            
                              let winnr = winnr()
                              if bufwinnr("SuperTabHelp") == -1
                                keepalt botright split SuperTabHelp
                            
                                setlocal noswapfile
                                setlocal buftype=nowrite
                                setlocal bufhidden=wipe
                            
                                silent put =s:tabHelp
                                call cursor(1, 1)
                                silent 1,delete _
                                call cursor(4, 1)
                                exec "resize " . line('$')
                            
                                syntax match Special "|.\{-}|"
                            
                                setlocal readonly
                                setlocal nomodifiable
                            
                                nmap <silent> <buffer> <cr> :call <SID>SetCompletionType()<cr>
                                nmap <silent> <buffer> <c-]> :call <SID>SetCompletionType()<cr>
                              else
                                exec bufwinnr("SuperTabHelp") . "winc w"
                              endif
                              let b:winnr = winnr
                            endfunction " }}}
                            
    1              0.000001 function! s:CompletionMode() " {{{
                              return pumvisible() || exists('b:supertab_completion_mode')
                            endfunction " }}}
                            
    1              0.000001 function! s:StartCompletionMode() " {{{
                              if exists('##CompleteDone')
                                let b:supertab_completion_mode = 1
                                augroup supertab_completion_mode
                                  autocmd CompleteDone <buffer>
                                    \ if exists('b:supertab_completion_mode') |
                                      \ unlet b:supertab_completion_mode |
                                    \ endif |
                                    \ autocmd! supertab_completion_mode
                                augroup END
                              endif
                            endfunction " }}}
                            
    1              0.000001 function! s:WillComplete(...) " {{{
                              " Determines if completion should be kicked off at the current location.
                              " Optional arg:
                              "   col: The column to check at, otherwise use the current column.
                            
                              " if an arg was supplied, then we will re-check even if already in
                              " completion mode.
                              if s:CompletionMode() && !a:0
                                return 1
                              endif
                            
                              let line = getline('.')
                              let cnum = a:0 ? a:1 : col('.')
                            
                              " honor SuperTabNoCompleteAfter
                              let pre = cnum >= 2 ? line[:cnum - 2] : ''
                              let complAfterType = type(b:SuperTabNoCompleteAfter)
                              if complAfterType == 3
                                " the option was provided as a list of patterns
                                for pattern in b:SuperTabNoCompleteAfter
                                  if pre =~ pattern . '$'
                                    return 0
                                  endif
                                endfor
                              elseif complAfterType == 2
                                " the option was provided as a funcref
                                return !b:SuperTabNoCompleteAfter(pre)
                              endif
                            
                              " honor SuperTabNoCompleteBefore
                              " Within a word, but user does not have mid word completion enabled.
                              let post = line[cnum - 1:]
                              let complBeforeType = type(b:SuperTabNoCompleteBefore)
                              if complBeforeType == 3
                                " a list of patterns
                                for pattern in b:SuperTabNoCompleteBefore
                                  if post =~ '^' . pattern
                                    return 0
                                  endif
                                endfor
                              elseif complBeforeType == 2
                                " the option was provided as a funcref
                                return !b:SuperTabNoCompleteBefore(post)
                              endif
                            
                              return 1
                            endfunction " }}}
                            
    1              0.000001 function! s:EnableLongestEnhancement() " {{{
                              augroup supertab_reset
                                autocmd!
                                autocmd InsertLeave,CursorMovedI <buffer>
                                  \ call s:ReleaseKeyPresses() | autocmd! supertab_reset
                              augroup END
                              call s:CaptureKeyPresses()
                            endfunction " }}}
                            
    1              0.000001 function! s:IsNoCompleteAfterReset() " {{{
                              " if the user has g:SuperTabNoCompleteAfter set, then re-map <bs> so that
                              " backspacing to a point where one of the g:SuperTabNoCompleteAfter
                              " entries matches will cause completion mode to exit.
                              let complAfterType = type(b:SuperTabNoCompleteAfter)
                              if complAfterType == 2
                                return 1
                              endif
                              return len(g:SuperTabNoCompleteAfter) && g:SuperTabNoCompleteAfter != ['^', '\s']
                            endfunction " }}}
                            
    1              0.000001 function! s:EnableNoCompleteAfterReset() " {{{
                              augroup supertab_reset
                                autocmd!
                                autocmd InsertLeave,CursorMovedI <buffer>
                                  \ call s:ReleaseKeyPresses() | autocmd! supertab_reset
                              augroup END
                            
                              " short version of s:CaptureKeyPresses
                              if !exists('b:capturing') || !b:capturing
                                let b:capturing = 1
                                let b:capturing_start = col('.')
                                let b:captured = {
                                    \ '<bs>': s:CaptureKeyMap('<bs>'),
                                    \ '<c-h>': s:CaptureKeyMap('<c-h>'),
                                  \ }
                                imap <buffer> <bs> <c-r>=<SID>CompletionReset("\<lt>bs>")<cr>
                                imap <buffer> <c-h> <c-r>=<SID>CompletionReset("\<lt>c-h>")<cr>
                              endif
                            endfunction " }}}
                            
    1              0.000002 function! s:CompletionReset(char) " {{{
                              let b:complReset = 1
                            
                              " handle exiting completion mode if user has g:SuperTabNoCompleteAfter set
                              " and they are about to backspace to a point where that maches one of the
                              " entries in that var.
                              if (a:char == "\<bs>" || a:char == "\<c-h>") && s:IsNoCompleteAfterReset()
                                if !s:WillComplete(col('.') - 1)
                                  " Exit from completion mode then issue the currently requested
                                  " backspace (mapped).
                                  call feedkeys("\<space>\<bs>", 'n')
                                  call s:ReleaseKeyPresses()
                                  call feedkeys("\<bs>", 'mt')
                                  return ''
                                endif
                              endif
                            
                              return a:char
                            endfunction " }}}
                            
    1              0.000001 function! s:CaptureKeyPresses() " {{{
                              if !exists('b:capturing') || !b:capturing
                                let b:capturing = 1
                                let b:capturing_start = col('.')
                                " save any previous mappings
                                let b:captured = {
                                    \ '<bs>': s:CaptureKeyMap('<bs>'),
                                    \ '<c-h>': s:CaptureKeyMap('<c-h>'),
                                  \ }
                                " TODO: use &keyword to get an accurate list of chars to map
                                for c in split('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_', '.\zs')
                                  let existing = s:CaptureKeyMap(c)
                                  let b:captured[c] = existing
                                  exec 'imap <buffer> ' . c . ' <c-r>=<SID>CompletionReset("' . c . '")<cr>'
                                endfor
                                imap <buffer> <bs> <c-r>=<SID>CompletionReset("\<lt>bs>")<cr>
                                imap <buffer> <c-h> <c-r>=<SID>CompletionReset("\<lt>c-h>")<cr>
                              endif
                            endfunction " }}}
                            
    1              0.000001 function! s:CaptureKeyMap(key) " {{{
                              " as of 7.3.032 maparg supports obtaining extended information about the
                              " mapping.
                              if s:has_dict_maparg
                                return maparg(a:key, 'i', 0, 1)
                              endif
                              return maparg(a:key, 'i')
                            endfunction " }}}
                            
    1              0.000001 function! s:IsPreviewOpen() " {{{
                              let wins = tabpagewinnr(tabpagenr(), '$')
                              let winnr = 1
                              while winnr <= wins
                                if getwinvar(winnr, '&previewwindow') == 1
                                  return 1
                                endif
                                let winnr += 1
                              endwhile
                              return 0
                            endfunction " }}}
                            
    1              0.000003 function! s:ClosePreview() " {{{
                              if exists('b:supertab_close_preview') && b:supertab_close_preview
                                let preview = 0
                                for bufnum in tabpagebuflist()
                                  if getwinvar(bufwinnr(bufnum), '&previewwindow')
                                    let preview = 1
                                    break
                                  endif
                                endfor
                                if preview
                                  pclose
                                  try
                                    doautocmd <nomodeline> supertab_preview_closed User <supertab>
                                  catch /E216/
                                    " ignore: no autocmds defined
                                  endtry
                                endif
                              endif
                              silent! unlet b:supertab_close_preview
                            endfunction " }}}
                            
    1              0.000001 function! s:ReleaseKeyPresses() " {{{
                              if exists('b:capturing') && b:capturing
                                let b:capturing = 0
                                for c in keys(b:captured)
                                  exec 'iunmap <buffer> ' . c
                                endfor
                            
                                " restore any previous mappings
                                for [key, mapping] in items(b:captured)
                                  if !len(mapping)
                                    continue
                                  endif
                            
                                  if type(mapping) == 4
                                    let restore = mapping.noremap ? "inoremap" : "imap"
                                    let restore .= " <buffer>"
                                    if mapping.silent
                                      let restore .= " <silent>"
                                    endif
                                    if mapping.expr
                                      let restore .= " <expr>"
                                    endif
                                    let rhs = substitute(mapping.rhs, '<SID>\c', '<SNR>' . mapping.sid . '_', 'g')
                                    let restore .= ' ' . key . ' ' . rhs
                                    exec restore
                                  elseif type(c) == 1
                                    let args = substitute(mapping, '.*\(".\{-}"\).*', '\1', '')
                                    if args != mapping
                                      let args = substitute(args, '<', '<lt>', 'g')
                                      let expr = substitute(mapping, '\(.*\)".\{-}"\(.*\)', '\1%s\2', '')
                                      let mapping = printf(expr, args)
                                    endif
                                    exec printf("imap <silent> <buffer> %s %s", key, mapping)
                                  endif
                                endfor
                                unlet b:captured
                            
                                if mode() == 'i' && &completeopt =~ 'menu' && b:capturing_start != col('.')
                                  " force full exit from completion mode (don't exit insert mode since
                                  " that will break repeating with '.')
                                  call feedkeys("\<space>\<bs>", 'n')
                                endif
                                unlet b:capturing_start
                              endif
                            endfunction " }}}
                            
    1              0.000001 function! s:CommandLineCompletion() " {{{
                              " Hack needed to account for apparent bug in vim command line mode completion
                              " when invoked via <c-r>=
                            
                              " This hack will trigger InsertLeave which will then invoke
                              " s:SetDefaultCompletionType.  To prevent default completion from being
                              " restored prematurely, set an internal flag for s:SetDefaultCompletionType
                              " to check for.
                              let b:complCommandLine = 1
                              return "\<c-\>\<c-o>:call feedkeys('\<c-x>\<c-v>\<c-v>', 'n') | " .
                                \ "let b:complCommandLine = 0\<cr>"
                            endfunction " }}}
                            
    1              0.000001 function! s:ContextCompletion() " {{{
                              let contexts = exists('b:SuperTabCompletionContexts') ?
                                \ b:SuperTabCompletionContexts : g:SuperTabCompletionContexts
                            
                              for context in contexts
                                try
                                  let Context = function(context)
                                  let complType = Context()
                                  unlet Context
                                  if type(complType) == 1 && complType != ''
                                    return complType
                                  endif
                                catch /E700/
                                  echohl Error
                                  echom 'supertab: no context function "' . context . '" found.'
                                  echohl None
                                endtry
                              endfor
                              return ''
                            endfunction " }}}
                            
    1              0.000001 function! s:ContextDiscover() " {{{
                              let discovery = exists('g:SuperTabContextDiscoverDiscovery') ?
                                \ g:SuperTabContextDiscoverDiscovery : []
                            
                              " loop through discovery list to find the default
                              if !empty(discovery)
                                for pair in discovery
                                  let var = substitute(pair, '\(.*\):.*', '\1', '')
                                  let type = substitute(pair, '.*:\(.*\)', '\1', '')
                                  exec 'let value = ' . var
                                  if value !~ '^\s*$' && value != '0'
                                    exec "let complType = \"" . escape(type, '<') . "\""
                                    return complType
                                  endif
                                endfor
                              endif
                            endfunction " }}}
                            
    1              0.000001 function! s:ContextText() " {{{
                              let exclusions = exists('g:SuperTabContextTextFileTypeExclusions') ?
                                \ g:SuperTabContextTextFileTypeExclusions : []
                            
                              if index(exclusions, &ft) == -1
                                let curline = getline('.')
                                let cnum = col('.')
                                let synname = synIDattr(synID(line('.'), cnum - 1, 1), 'name')
                            
                                let member_patterns = exists('b:SuperTabContextTextMemberPatterns') ?
                                  \ b:SuperTabContextTextMemberPatterns : g:SuperTabContextTextMemberPatterns
                                let member_pattern = join(member_patterns, '\|')
                            
                                " don't kick off file completion if the pattern is '</' (to account for
                                " sgml languanges), that's what the following <\@<! pattern is doing.
                                if curline =~ '<\@<!/\.\?\w*\%' . cnum . 'c' ||
                                  \ ((has('win32') || has('win64')) && curline =~ '\\\w*\%' . cnum . 'c')
                            
                                  return "\<c-x>\<c-f>"
                            
                                elseif curline =~ '\(' . member_pattern . '\)\w*\%' . cnum . 'c' &&
                                  \ synname !~ '\(String\|Comment\)'
                                  let omniPrecedence = exists('g:SuperTabContextTextOmniPrecedence') ?
                                    \ g:SuperTabContextTextOmniPrecedence : ['&completefunc', '&omnifunc']
                                  let omniPrecedence = exists('b:SuperTabContextTextOmniPrecedence') ?
                                    \ b:SuperTabContextTextOmniPrecedence : omniPrecedence
                            
                                  for omniFunc in omniPrecedence
                                    if omniFunc !~ '^&'
                                      let omniFunc = '&' . omniFunc
                                    endif
                                    if getbufvar(bufnr('%'), omniFunc) != ''
                                      return omniFunc == '&omnifunc' ? "\<c-x>\<c-o>" : "\<c-x>\<c-u>"
                                    endif
                                  endfor
                                endif
                              endif
                            endfunction " }}}
                            
    1              0.000001 function! s:ExpandMap(map) " {{{
                              let map = a:map
                              if map =~ '<Plug>'
                                let plug = substitute(map, '.\{-}\(<Plug>\w\+\).*', '\1', '')
                                let plug_map = maparg(plug, 'i')
                                let map = substitute(map, '.\{-}\(<Plug>\w\+\).*', plug_map, '')
                              endif
                              return map
                            endfunction " }}}
                            
    1              0.000002 function! SuperTabChain(completefunc, completekeys, ...) " {{{
                              if a:completefunc != 'SuperTabCodeComplete'
                                call s:InitBuffer()
                                if (a:0 && a:1) || (!a:0 && b:SuperTabDefaultCompletionType == 'context')
                                  let b:SuperTabContextTextOmniPrecedence = ['&completefunc', '&omnifunc']
                                  call SuperTabSetDefaultCompletionType("context")
                                else
                                  call SuperTabSetDefaultCompletionType("<c-x><c-u>")
                                endif
                            
                                let b:SuperTabChain = [a:completefunc, a:completekeys]
                                setlocal completefunc=SuperTabCodeComplete
                              endif
                            endfunction " }}}
                            
    1              0.000002 function! SuperTabCodeComplete(findstart, base) " {{{
                              if !exists('b:SuperTabChain')
                                echoe 'No completion chain has been set.'
                                return -2
                              endif
                            
                              if len(b:SuperTabChain) != 2
                                echoe 'Completion chain can only be used with 1 completion function ' .
                                    \ 'and 1 fallback completion key binding.'
                                return -2
                              endif
                            
                              let Func = function(b:SuperTabChain[0])
                            
                              if a:findstart
                                let start = Func(a:findstart, a:base)
                                if start >= 0
                                  return start
                                endif
                            
                                return col('.') - 1
                              endif
                            
                              let results = Func(a:findstart, a:base)
                              " Handle dict case, with 'words' and 'refresh' (optional).
                              " This is used by YouCompleteMe. (See complete-functions).
                              if type(results) == type({}) && has_key(results, 'words')
                                if len(results.words)
                                  return results
                                endif
                              elseif len(results)
                                return results
                              endif
                            
                              exec 'let keys = "' . escape(b:SuperTabChain[1], '<') . '"'
                              " <c-e>: stop completion and go back to the originally typed text.
                              call feedkeys("\<c-e>" . keys, 'nt')
                              return []
                            endfunction " }}}
                            
                            " Autocmds {{{
    1              0.000003   if g:SuperTabClosePreviewOnPopupClose
                                augroup supertab_close_preview
                                  autocmd!
                                  autocmd InsertLeave,CursorMovedI * call s:ClosePreview()
                                augroup END
                              endif
                            " }}}
                            
                            " Key Mappings {{{
                              " map a regular tab to ctrl-tab (note: doesn't work in console vim)
    1              0.000008   exec 'inoremap ' . g:SuperTabMappingTabLiteral . ' <tab>'
                            
    1              0.000005   inoremap <silent> <c-x> <c-r>=<SID>ManualCompletionEnter()<cr>
                            
    1              0.000005   imap <script> <Plug>SuperTabForward <c-r>=SuperTab('n')<cr>
    1              0.000005   imap <script> <Plug>SuperTabBackward <c-r>=SuperTab('p')<cr>
                            
    1              0.000004   let s:has_dict_maparg = v:version > 703 || (v:version == 703 && has('patch32'))
                            
                              " support delegating to smart tabs plugin
    1              0.000003   if g:SuperTabMappingForward ==? '<tab>' || g:SuperTabMappingBackward ==? '<tab>'
    1              0.000012     let existing_tab = maparg('<tab>', 'i')
    1              0.000014     if existing_tab =~ '\d\+_InsertSmartTab()$'
                                  let s:Tab = function(substitute(existing_tab, '()$', '', ''))
                                endif
    1              0.000001   endif
                            
                              " save user's existing <s-tab> mapping if they have one.
                              " Note: this could cause more problems than it solves if it picks up <s-tab>
                              " mappings from other plugins and misinterprets them, etc, so this block is
                              " experimental and could be removed later.
    1              0.000003   if g:SuperTabMappingForward ==? '<s-tab>' || g:SuperTabMappingBackward ==? '<s-tab>'
    1              0.000005     let stab = maparg('<s-tab>', 'i')
    1              0.000001     if s:has_dict_maparg
    1              0.000005       let existing_stab = maparg('<s-tab>', 'i', 0, 1)
    1              0.000003       if len(existing_stab) && existing_stab.expr
                                    let stab = substitute(stab, '<SID>\c', '<SNR>' . existing_stab.sid . '_', '')
                                    let stab = substitute(stab, '()$', '', '')
                                    let s:ShiftTab = function(stab)
                                    let stab = ''
                                  endif
    1              0.000001     endif
    1              0.000001     if stab != ''
                                  let stab = substitute(stab, '\(<[-a-zA-Z0-9]\+>\)', '\\\1', 'g')
                                  exec "let stab = \"" . stab . "\""
                                  let s:ShiftTab = stab
                                endif
    1              0.000001   endif
                            
    1              0.000007   exec 'imap ' . g:SuperTabMappingForward . ' <Plug>SuperTabForward'
    1              0.000007   exec 'imap ' . g:SuperTabMappingBackward . ' <Plug>SuperTabBackward'
                            
    1              0.000001   if g:SuperTabCrMapping
                                let expr_map = 0
                                if s:has_dict_maparg
                                  let map_dict = maparg('<cr>', 'i', 0, 1)
                                  let expr_map = has_key(map_dict, 'expr') && map_dict.expr
                                else
                                  let expr_map = maparg('<cr>', 'i') =~? '\<cr>'
                                endif
                            
                                redir => iabbrevs
                                silent iabbrev
                                redir END
                                let iabbrev_map = iabbrevs =~? '\<cr>'
                            
                                if expr_map
                                  " Not compatible w/ expr mappings. This is most likely a user mapping,
                                  " typically with the same functionality anyways.
                                  let g:SuperTabCrMapping = 0
                                elseif iabbrev_map
                                  " Not compatible w/ insert abbreviations containing <cr>
                                  let g:SuperTabCrMapping = 0
                                elseif maparg('<CR>', 'i') =~ '<Plug>delimitMateCR'
                                  " Not compatible w/ delimitMate since it doesn't play well with others
                                  " and will always return a <cr> which we don't want when selecting a
                                  " completion.
                                  let g:SuperTabCrMapping = 0
                                elseif maparg('<CR>', 'i') =~ '<CR>'
                                  let map = maparg('<cr>', 'i')
                                  let cr = !(map =~? '\(^\|[^)]\)<cr>' || map =~ 'ExpandCr')
                                  let map = s:ExpandMap(map)
                                  exec "inoremap <script> <cr> <c-r>=<SID>SelectCompletion(" . cr . ")<cr>" . map
                                else
                                  inoremap <silent> <cr> <c-r>=<SID>SelectCompletion(1)<cr>
                                endif
                                function! s:SelectCompletion(cr)
                                  " selecting a completion
                                  if s:CompletionMode()
                                    " ugly hack to let other <cr> mappings for other plugins cooperate
                                    " with supertab
                                    let b:supertab_pumwasvisible = 1
                            
                                    " close the preview window if configured to do so
                                    if &completeopt =~ 'preview' && g:SuperTabClosePreviewOnPopupClose
                                      if !exists('b:supertab_close_preview')
                                        let b:supertab_close_preview = !s:IsPreviewOpen()
                                      endif
                                      call s:ClosePreview()
                                    endif
                            
                                    return "\<c-y>"
                                  endif
                            
                                  " only needed when chained with other mappings and one of them will
                                  " issue a <cr>.
                                  if exists('b:supertab_pumwasvisible') && !a:cr
                                    unlet b:supertab_pumwasvisible
                                    return ''
                                  endif
                            
                                  " not so pleasant hack to keep <cr> working for abbreviations
                                  let word = substitute(getline('.'), '^.*\s\+\(.*\%' . col('.') . 'c\).*', '\1', '')
                                  let result = maparg(word, 'i', 1)
                                  if result != ''
                                    let bs = ""
                                    let i = 0
                                    while i < len(word)
                                      let bs .= "\<bs>"
                                      let i += 1
                                    endwhile
                                    " escape keys
                                    let result = substitute(result, '\(<[a-zA-Z][-a-zA-Z]*>\)', '\\\1', 'g')
                                    " ensure escaped keys are properly recognized
                                    exec 'let result = "' . escape(result, '"') . '"'
                                    return bs . result . (a:cr ? "\<cr>" : "")
                                  endif
                            
                                  " only return a cr if nothing else is mapped to it since we don't want
                                  " to duplicate a cr returned by another mapping.
                                  return a:cr ? "\<cr>" : ""
                                endfunction
                              endif
                            " }}}
                            
                            " Command Mappings {{{
    1              0.000003   if !exists(":SuperTabHelp")
    1              0.000003     command SuperTabHelp :call <SID>SuperTabHelp()
    1              0.000001   endif
                            " }}}
                            
    1   0.000052   0.000007 call s:Init()
                            
    1              0.000002 function! TestSuperTabCodeComplete(findstart, base) " {{{
                              " Test supertab completion chaining w/ a minimal vim environment:
                              " $ vim -u NONE -U NONE \
                              "   --cmd "set nocp | sy on" \
                              "   -c "so ~/.vim/plugin/supertab.vim" \
                              "   -c "let g:SuperTabDefaultCompletionType = '<c-x><c-u>'" \
                              "   -c "set completefunc=TestSuperTabCodeComplete" \
                              "   -c "call SuperTabChain(&completefunc, '<c-p>')"
                              if a:findstart
                                let line = getline('.')
                                let start = col('.') - 1
                                if line[start] =~ '\.'
                                  let start -= 1
                                endif
                                while start > 0 && line[start - 1] =~ '\w'
                                  let start -= 1
                                endwhile
                                return start
                              else
                                let completions = []
                                if getline('.') =~ 'TestC'
                                  call add(completions, {
                                      \ 'word': 'test1(',
                                      \ 'kind': 'm',
                                      \ 'menu': 'test1(...)',
                                    \ })
                                  call add(completions, {
                                      \ 'word': 'testing2(',
                                      \ 'kind': 'm',
                                      \ 'menu': 'testing2(...)',
                                    \ })
                                endif
                            
                                return completions
                              endif
                            endfunction " }}}
                            
    1              0.000005 let &cpo = s:save_cpo
                            
                            " vim:ft=vim:fdm=marker

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/tabular/plugin/Tabular.vim
Sourced 1 time
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
                            " Tabular:     Align columnar data using regex-designated column boundaries
                            " Maintainer:  Matthew Wozniski (godlygeek@gmail.com)
                            " Date:        Thu, 03 May 2012 20:49:32 -0400
                            " Version:     1.0
                            "
                            " Long Description:
                            " Sometimes, it's useful to line up text.  Naturally, it's nicer to have the
                            " computer do this for you, since aligning things by hand quickly becomes
                            " unpleasant.  While there are other plugins for aligning text, the ones I've
                            " tried are either impossibly difficult to understand and use, or too simplistic
                            " to handle complicated tasks.  This plugin aims to make the easy things easy
                            " and the hard things possible, without providing an unnecessarily obtuse
                            " interface.  It's still a work in progress, and criticisms are welcome.
                            "
                            " License:
                            " Copyright (c) 2012, Matthew J. Wozniski
                            " All rights reserved.
                            "
                            " Redistribution and use in source and binary forms, with or without
                            " modification, are permitted provided that the following conditions are met:
                            "     * Redistributions of source code must retain the above copyright notice,
                            "       this list of conditions and the following disclaimer.
                            "     * Redistributions in binary form must reproduce the above copyright
                            "       notice, this list of conditions and the following disclaimer in the
                            "       documentation and/or other materials provided with the distribution.
                            "     * The names of the contributors may not be used to endorse or promote
                            "       products derived from this software without specific prior written
                            "       permission.
                            "
                            " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
                            " OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
                            " OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
                            " NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
                            " INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
                            " LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
                            " OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                            " LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                            " NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
                            " EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            
                            " Abort if running in vi-compatible mode or the user doesn't want us.
    1              0.000006 if &cp || exists('g:tabular_loaded')
                              if &cp && &verbose
                                echo "Not loading Tabular in compatible mode."
                              endif
                              finish
                            endif
                            
    1              0.000002 let g:tabular_loaded = 1
                            
                            " Stupid vimscript crap                                                   {{{1
    1              0.000003 let s:savecpo = &cpo
    1              0.000004 set cpo&vim
                            
                            " Private Things                                                          {{{1
                            
                            " Dictionary of command name to command
    1              0.000002 let s:TabularCommands = {}
                            
                            " Generate tab completion list for :Tabularize                            {{{2
                            " Return a list of commands that match the command line typed so far.
                            " NOTE: Tries to handle commands with spaces in the name, but Vim doesn't seem
                            "       to handle that terribly well... maybe I should give up on that.
    1              0.000005 function! s:CompleteTabularizeCommand(argstart, cmdline, cursorpos)
                              let names = keys(s:TabularCommands)
                              if exists("b:TabularCommands")
                                let names += keys(b:TabularCommands)
                              endif
                            
                              let cmdstart = substitute(a:cmdline, '^\s*\S\+\s*', '', '')
                            
                              return filter(names, 'v:val =~# ''^\V'' . escape(cmdstart, ''\'')')
                            endfunction
                            
                            " Choose the proper command map from the given command line               {{{2
                            " Returns [ command map, command line with leading <buffer> removed ]
    1              0.000002 function! s:ChooseCommandMap(commandline)
                              let map = s:TabularCommands
                              let cmd = a:commandline
                            
                              if cmd =~# '^<buffer>\s\+'
                                if !exists('b:TabularCommands')
                                  let b:TabularCommands = {}
                                endif
                                let map = b:TabularCommands
                                let cmd = substitute(cmd, '^<buffer>\s\+', '', '')
                              endif
                            
                              return [ map, cmd ]
                            endfunction
                            
                            " Parse '/pattern/format' into separate pattern and format parts.         {{{2
                            " If parsing fails, return [ '', '' ]
    1              0.000001 function! s:ParsePattern(string)
                              if a:string[0] != '/'
                                return ['','']
                              endif
                            
                              let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'
                              let format = matchstr(a:string[1:-1], pat)
                              if !empty(format)
                                let format = format[1 : -1]
                                let pattern = a:string[1 : -len(format) - 2]
                              else
                                let pattern = a:string[1 : -1]
                              endif
                            
                              return [pattern, format]
                            endfunction
                            
                            " Split apart a list of | separated expressions.                          {{{2
    1              0.000001 function! s:SplitCommands(string)
                              if a:string =~ '^\s*$'
                                return []
                              endif
                            
                              let end = match(a:string, "[\"'|]")
                            
                              " Loop until we find a delimiting | or end-of-string
                              while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')
                                if a:string[end] == "'"
                                  let end = match(a:string, "'", end+1) + 1
                                  if end == 0
                                    throw "No matching end single quote"
                                  endif
                                elseif a:string[end] == '"'
                                  " Find a " preceded by an even number of \ (or 0)
                                  let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'
                                  let end = matchend(a:string, pattern, end+1) + 1
                                  if end == 0
                                    throw "No matching end double quote"
                                  endif
                                else " Found ||
                                  let end += 2
                                endif
                            
                                let end = match(a:string, "[\"'|]", end)
                              endwhile
                            
                              if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'
                                throw "Empty element"
                              endif
                            
                              if end == -1
                                let rv = [ a:string ]
                              else
                                let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])
                              endif
                            
                              return rv
                            endfunction
                            
                            " Public Things                                                           {{{1
                            
                            " Command associating a command name with a simple pattern command        {{{2
                            " AddTabularPattern[!] [<buffer>] name /pattern[/format]
                            "
                            " If <buffer> is provided, the command will only be available in the current
                            " buffer, and will be used instead of any global command with the same name.
                            "
                            " If a command with the same name and scope already exists, it is an error,
                            " unless the ! is provided, in which case the existing command will be
                            " replaced.
                            "
                            " pattern is a regex describing the delimiter to be used.
                            "
                            " format describes the format pattern to be used.  The default will be used if
                            " none is provided.
    1              0.000005 com! -nargs=+ -bang AddTabularPattern
                               \ call AddTabularPattern(<q-args>, <bang>0)
                            
    1              0.000002 function! AddTabularPattern(command, force)
                              try
                                let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
                            
                                let name = matchstr(rest, '.\{-}\ze\s*/')
                                let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
                            
                                let [ pattern, format ] = s:ParsePattern(pattern)
                            
                                if empty(name) || empty(pattern)
                                  throw "Invalid arguments!"
                                endif
                            
                                if !a:force && has_key(commandmap, name)
                                  throw string(name) . " is already defined, use ! to overwrite."
                                endif
                            
                                let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)
                            
                                if !empty(format)
                                  let command .=  ", " . string(format)
                                endif
                            
                                let command .= ")"
                            
                                let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }
                              catch
                                echohl ErrorMsg
                                echomsg "AddTabularPattern: " . v:exception
                                echohl None
                              endtry
                            endfunction
                            
                            " Command associating a command name with a pipeline of functions         {{{2
                            " AddTabularPipeline[!] [<buffer>] name /pattern/ func [ | func2 [ | func3 ] ]
                            "
                            " If <buffer> is provided, the command will only be available in the current
                            " buffer, and will be used instead of any global command with the same name.
                            "
                            " If a command with the same name and scope already exists, it is an error,
                            " unless the ! is provided, in which case the existing command will be
                            " replaced.
                            "
                            " pattern is a regex that will be used to determine which lines will be
                            " filtered.  If the cursor line doesn't match the pattern, using the command
                            " will be a no-op, otherwise the cursor and all contiguous lines matching the
                            " pattern will be filtered.
                            "
                            " Each 'func' argument represents a function to be called.  This function
                            " will have access to a:lines, a List containing one String per line being
                            " filtered.
    1              0.000008 com! -nargs=+ -bang AddTabularPipeline
                               \ call AddTabularPipeline(<q-args>, <bang>0)
                            
    1              0.000002 function! AddTabularPipeline(command, force)
                              try
                                let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
                            
                                let name = matchstr(rest, '.\{-}\ze\s*/')
                                let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
                            
                                let commands = matchstr(pattern, '^/.\{-}\\\@<!\%(\\\\\)\{-}/\zs.*')
                                let pattern = matchstr(pattern, '/\zs.\{-}\\\@<!\%(\\\\\)\{-}\ze/')
                            
                                if empty(name) || empty(pattern)
                                  throw "Invalid arguments!"
                                endif
                            
                                if !a:force && has_key(commandmap, name)
                                  throw string(name) . " is already defined, use ! to overwrite."
                                endif
                            
                                let commandlist = s:SplitCommands(commands)
                            
                                if empty(commandlist)
                                  throw "Must provide a list of functions!"
                                endif
                            
                                let commandmap[name] = { 'pattern' : pattern, 'commands' : commandlist }
                              catch
                                echohl ErrorMsg
                                echomsg "AddTabularPipeline: " . v:exception
                                echohl None
                              endtry
                            endfunction
                            
                            " Tabularize /pattern[/format]                                            {{{2
                            " Tabularize name
                            "
                            " Align text, either using the given pattern, or the command associated with
                            " the given name.
    1              0.000006 com! -nargs=* -range -complete=customlist,<SID>CompleteTabularizeCommand
                               \ Tabularize <line1>,<line2>call Tabularize(<q-args>)
                            
    1              0.000001 function! Tabularize(command, ...) range
                              let piperange_opt = {}
                              if a:0
                                let piperange_opt = a:1
                              endif
                            
                              if empty(a:command)
                                if !exists("s:last_tabularize_command")
                                  echohl ErrorMsg
                                  echomsg "Tabularize hasn't been called yet; no pattern/command to reuse!"
                                  echohl None
                                  return
                                endif
                              else
                                let s:last_tabularize_command = a:command
                              endif
                            
                              let command = s:last_tabularize_command
                            
                              let range = a:firstline . ',' . a:lastline
                            
                              try
                                let [ pattern, format ] = s:ParsePattern(command)
                            
                                if !empty(pattern)
                                  let cmd  = "tabular#TabularizeStrings(a:lines, " . string(pattern)
                            
                                  if !empty(format)
                                    let cmd .= "," . string(format)
                                  endif
                            
                                  let cmd .= ")"
                            
                                  exe range . 'call tabular#PipeRangeWithOptions(pattern, [ cmd ], '
                                                  \ . 'piperange_opt)'
                                else
                                  if exists('b:TabularCommands') && has_key(b:TabularCommands, command)
                                    let usercmd = b:TabularCommands[command]
                                  elseif has_key(s:TabularCommands, command)
                                    let usercmd = s:TabularCommands[command]
                                  else
                                    throw "Unrecognized command " . string(command)
                                  endif
                            
                                  exe range . 'call tabular#PipeRangeWithOptions(usercmd["pattern"], '
                                                  \ . 'usercmd["commands"], piperange_opt)'
                                endif
                              catch
                                echohl ErrorMsg
                                echomsg "Tabularize: " . v:exception
                                echohl None
                                return
                              endtry
                            endfunction
                            
                            " GTabularize /pattern[/format]                                           {{{2
                            " GTabularize name
                            "
                            " Align text on only matching lines, either using the given pattern, or the
                            " command associated with the given name.  Mnemonically, this is similar to
                            " the :global command, which takes some action on all rows matching a pattern
                            " in a range.  This command is different from normal :Tabularize in 3 ways:
                            "   1) If a line in the range does not match the pattern, it will be left
                            "      unchanged, and not in any way affect the outcome of other lines in the
                            "      range (at least, normally - but Pipelines can and will still look at
                            "      non-matching rows unless they are specifically written to be aware of
                            "      tabular#DoGTabularize() and handle it appropriately).
                            "   2) No automatic range determination - :Tabularize automatically expands
                            "      a single-line range (or a call with no range) to include all adjacent
                            "      matching lines.  That behavior does not make sense for this command.
                            "   3) If called without a range, it will act on all lines in the buffer (like
                            "      :global) rather than only a single line
    1              0.000007 com! -nargs=* -range=% -complete=customlist,<SID>CompleteTabularizeCommand
                               \ GTabularize <line1>,<line2>
                               \ call Tabularize(<q-args>, { 'mode': 'GTabularize' } )
                            
                            " Stupid vimscript crap, part 2                                           {{{1
    1              0.000004 let &cpo = s:savecpo
    1              0.000002 unlet s:savecpo
                            
                            " vim:set sw=2 sts=2 fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/tagbar/plugin/tagbar.vim
Sourced 1 time
Total time:   0.000892
 Self time:   0.000218

count  total (s)   self (s)
                            " ============================================================================
                            " File:        tagbar.vim
                            " Description: List the current file's tags in a sidebar, ordered by class etc
                            " Author:      Jan Larres <jan@majutsushi.net>
                            " Licence:     Vim licence
                            " Website:     http://majutsushi.github.com/tagbar/
                            " Version:     2.7
                            " Note:        This plugin was heavily inspired by the 'Taglist' plugin by
                            "              Yegappan Lakshmanan and uses a small amount of code from it.
                            "
                            " Original taglist copyright notice:
                            "              Permission is hereby granted to use and distribute this code,
                            "              with or without modifications, provided that this copyright
                            "              notice is copied with it. Like anything else that's free,
                            "              taglist.vim is provided *as is* and comes with no warranty of
                            "              any kind, either expressed or implied. In no event will the
                            "              copyright holder be liable for any damamges resulting from the
                            "              use of this software.
                            " ============================================================================
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000006 if &cp || exists('g:loaded_tagbar')
                                finish
                            endif
                            
                            " Basic init {{{1
                            
    1              0.000001 if v:version < 700
                                echohl WarningMsg
                                echomsg 'Tagbar: Vim version is too old, Tagbar requires at least 7.0'
                                echohl None
                                finish
                            endif
                            
    1              0.000002 if v:version == 700 && !has('patch167')
                                echohl WarningMsg
                                echomsg 'Tagbar: Vim versions lower than 7.0.167 have a bug'
                                      \ 'that prevents this version of Tagbar from working.'
                                      \ 'Please use the alternate version posted on the website.'
                                echohl None
                                finish
                            endif
                            
    1              0.000003 function! s:init_var(var, value) abort
                                if !exists('g:tagbar_' . a:var)
                                    execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)
                                endif
                            endfunction
                            
    1              0.000002 function! s:setup_options() abort
                                if !exists('g:tagbar_vertical') || g:tagbar_vertical == 0
                                    let previewwin_pos = 'topleft'
                                else
                                    let previewwin_pos = 'rightbelow vertical'
                                endif
                                let options = [
                                    \ ['autoclose', 0],
                                    \ ['autofocus', 0],
                                    \ ['autopreview', 0],
                                    \ ['autoshowtag', 0],
                                    \ ['case_insensitive', 0],
                                    \ ['compact', 0],
                                    \ ['expand', 0],
                                    \ ['foldlevel', 99],
                                    \ ['hide_nonpublic', 0],
                                    \ ['indent', 2],
                                    \ ['left', 0],
                                    \ ['previewwin_pos', previewwin_pos],
                                    \ ['show_visibility', 1],
                                    \ ['show_linenumbers', 0],
                                    \ ['singleclick', 0],
                                    \ ['sort', 1],
                                    \ ['systemenc', &encoding],
                                    \ ['vertical', 0],
                                    \ ['width', 40],
                                    \ ['zoomwidth', 1],
                                    \ ['silent', 0],
                                \ ]
                            
                                for [opt, val] in options
                                    call s:init_var(opt, val)
                                endfor
                            endfunction
    1   0.000358   0.000017 call s:setup_options()
                            
    1              0.000002 if !exists('g:tagbar_iconchars')
    1              0.000007     if has('multi_byte') && has('unix') && &encoding == 'utf-8' &&
                                 \ (empty(&termencoding) || &termencoding == 'utf-8')
    1              0.000002         let g:tagbar_iconchars = ['▶', '▼']
    1              0.000001     else
                                    let g:tagbar_iconchars = ['+', '-']
                                endif
    1              0.000001 endif
                            
    1              0.000002 function! s:setup_keymaps() abort
                                let keymaps = [
                                    \ ['jump',          '<CR>'],
                                    \ ['preview',       'p'],
                                    \ ['previewwin',    'P'],
                                    \ ['nexttag',       '<C-N>'],
                                    \ ['prevtag',       '<C-P>'],
                                    \ ['showproto',     '<Space>'],
                                    \ ['hidenonpublic', 'v'],
                                    \
                                    \ ['openfold',      ['+', '<kPlus>', 'zo']],
                                    \ ['closefold',     ['-', '<kMinus>', 'zc']],
                                    \ ['togglefold',    ['o', 'za']],
                                    \ ['openallfolds',  ['*', '<kMultiply>', 'zR']],
                                    \ ['closeallfolds', ['=', 'zM']],
                                    \ ['incrementfolds',  ['zr']],
                                    \ ['decrementfolds',  ['zm']],
                                    \ ['nextfold',      'zj'],
                                    \ ['prevfold',      'zk'],
                                    \
                                    \ ['togglesort',            's'],
                                    \ ['togglecaseinsensitive', 'i'],
                                    \ ['toggleautoclose',       'c'],
                                    \ ['zoomwin',               'x'],
                                    \ ['close',                 'q'],
                                    \ ['help',                  ['<F1>', '?']],
                                \ ]
                            
                                for [map, key] in keymaps
                                    call s:init_var('map_' . map, key)
                                    unlet key
                                endfor
                            endfunction
    1   0.000354   0.000021 call s:setup_keymaps()
                            
    1              0.000001 augroup TagbarSession
    1              0.000033     autocmd!
    1              0.000005     autocmd SessionLoadPost * nested call tagbar#RestoreSession()
    1              0.000001 augroup END
                            
                            " Commands {{{1
    1              0.000003 command! -nargs=0 Tagbar              call tagbar#ToggleWindow()
    1              0.000003 command! -nargs=0 TagbarToggle        call tagbar#ToggleWindow()
    1              0.000003 command! -nargs=? TagbarOpen          call tagbar#OpenWindow(<f-args>)
    1              0.000003 command! -nargs=0 TagbarOpenAutoClose call tagbar#OpenWindow('fcj')
    1              0.000002 command! -nargs=0 TagbarClose         call tagbar#CloseWindow()
    1              0.000004 command! -nargs=1 -bang TagbarSetFoldlevel  call tagbar#SetFoldLevel(<args>, <bang>0)
    1              0.000003 command! -nargs=0 TagbarShowTag       call tagbar#highlighttag(1, 1)
    1              0.000004 command! -nargs=? TagbarCurrentTag    echo tagbar#currenttag('%s', 'No current tag', <f-args>)
    1              0.000003 command! -nargs=1 TagbarGetTypeConfig call tagbar#gettypeconfig(<f-args>)
    1              0.000003 command! -nargs=? TagbarDebug         call tagbar#debug#start_debug(<f-args>)
    1              0.000002 command! -nargs=0 TagbarDebugEnd      call tagbar#debug#stop_debug()
    1              0.000002 command! -nargs=0 TagbarTogglePause   call tagbar#toggle_pause()
                            
                            " Modeline {{{1
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/lightline.vim/plugin/lightline.vim
Sourced 1 time
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: plugin/lightline.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2018/06/22 08:49:00.
                            " =============================================================================
                            
    1              0.000005 if exists('g:loaded_lightline') || v:version < 700
                              finish
                            endif
    1              0.000002 let g:loaded_lightline = 1
                            
    1              0.000004 let s:save_cpo = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000001 augroup lightline
    1              0.000033   autocmd!
    1              0.000013   autocmd WinEnter,BufWinEnter,FileType,SessionLoadPost * call lightline#update()
    1              0.000002   autocmd SessionLoadPost * call lightline#highlight()
    1              0.000004   autocmd ColorScheme * if !has('vim_starting') || expand('<amatch>') !=# 'macvim'
                                    \ | call lightline#update() | call lightline#highlight() | endif
    1              0.000004   autocmd CursorMoved,BufUnload * call lightline#update_once()
    1              0.000001 augroup END
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/plugin/NERD_tree.vim
Sourced 1 time
Total time:   0.010682
 Self time:   0.000698

count  total (s)   self (s)
                            " ============================================================================
                            " File:        NERD_tree.vim
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
                            "
                            " SECTION: Script init stuff {{{1
                            "============================================================
    1              0.000004 if exists("loaded_nerd_tree")
                                finish
                            endif
    1              0.000001 if v:version < 700
                                echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
                                finish
                            endif
    1              0.000002 let loaded_nerd_tree = 1
                            
                            "for line continuation - i.e dont want C in &cpo
    1              0.000003 let s:old_cpo = &cpo
    1              0.000004 set cpo&vim
                            
                            "Function: s:initVariable() function {{{2
                            "This function is used to initialise a given variable to a given value. The
                            "variable is only initialised if it does not exist prior
                            "
                            "Args:
                            "var: the name of the var to be initialised
                            "value: the value to initialise var to
                            "
                            "Returns:
                            "1 if the var is set, 0 otherwise
    1              0.000003 function! s:initVariable(var, value)
                                if !exists(a:var)
                                    exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
                                    return 1
                                endif
                                return 0
                            endfunction
                            
                            "SECTION: Init variable calls and other random constants {{{2
    1   0.000022   0.000008 call s:initVariable("g:NERDTreeAutoCenter", 1)
    1   0.000015   0.000004 call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)
    1   0.000013   0.000003 call s:initVariable("g:NERDTreeNaturalSort", 0)
    1   0.000013   0.000003 call s:initVariable("g:NERDTreeSortHiddenFirst", 1)
    1   0.000012   0.000005 call s:initVariable("g:NERDTreeChDirMode", 0)
    1   0.000013   0.000003 call s:initVariable("g:NERDTreeCreatePrefix", "silent")
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMinimalUI", 0)
    1              0.000002 if !exists("g:NERDTreeIgnore")
                                let g:NERDTreeIgnore = ['\~$']
                            endif
    1   0.000034   0.000023 call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')
    1   0.000013   0.000003 call s:initVariable("g:NERDTreeBookmarksSort", 1)
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeHighlightCursorline", 1)
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeHijackNetrw", 1)
    1   0.000012   0.000003 call s:initVariable('g:NERDTreeMarkBookmarks', 1)
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMouseMode", 1)
    1   0.000013   0.000003 call s:initVariable("g:NERDTreeNotificationThreshold", 100)
    1   0.000009   0.000003 call s:initVariable("g:NERDTreeQuitOnOpen", 0)
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeRespectWildIgnore", 0)
    1   0.000008   0.000002 call s:initVariable("g:NERDTreeShowBookmarks", 0)
    1   0.000024   0.000003 call s:initVariable("g:NERDTreeShowFiles", 1)
    1   0.000011   0.000005 call s:initVariable("g:NERDTreeShowHidden", 0)
    1   0.000023   0.000003 call s:initVariable("g:NERDTreeShowLineNumbers", 0)
    1   0.000016   0.000003 call s:initVariable("g:NERDTreeSortDirs", 1)
                            
    1   0.000321   0.000133 if !nerdtree#runningWindows() && !nerdtree#runningCygwin()
    1   0.000021   0.000004     call s:initVariable("g:NERDTreeDirArrowExpandable", "▸")
    1   0.000017   0.000003     call s:initVariable("g:NERDTreeDirArrowCollapsible", "▾")
    1              0.000001 else
                                call s:initVariable("g:NERDTreeDirArrowExpandable", "+")
                                call s:initVariable("g:NERDTreeDirArrowCollapsible", "~")
                            endif
    1   0.000016   0.000003 call s:initVariable("g:NERDTreeCascadeOpenSingleChildDir", 1)
    1   0.000015   0.000003 call s:initVariable("g:NERDTreeCascadeSingleChildDir", 1)
                            
    1              0.000002 if !exists("g:NERDTreeSortOrder")
    1              0.000005     let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
    1              0.000001 endif
    1              0.000003 let g:NERDTreeOldSortOrder = []
                            
    1   0.000016   0.000003 call s:initVariable("g:NERDTreeGlyphReadOnly", "RO")
                            
    1              0.000004 if !exists('g:NERDTreeStatusline')
                            
                                "the exists() crap here is a hack to stop vim spazzing out when
                                "loading a session that was created with an open nerd tree. It spazzes
                                "because it doesnt store b:NERDTree(its a b: var, and its a hash)
    1              0.000004     let g:NERDTreeStatusline = "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}"
                            
    1              0.000001 endif
    1   0.000016   0.000003 call s:initVariable("g:NERDTreeWinPos", "left")
    1   0.000009   0.000003 call s:initVariable("g:NERDTreeWinSize", 31)
                            
                            "init the shell commands that will be used to copy nodes, and remove dir trees
                            "
                            "Note: the space after the command is important
    1   0.000009   0.000003 if nerdtree#runningWindows()
                                call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')
                                call s:initVariable("g:NERDTreeCopyDirCmd", 'xcopy /s /e /i /y /q ')
                                call s:initVariable("g:NERDTreeCopyFileCmd", 'copy /y ')
                            else
    1   0.000015   0.000003     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')
    1   0.000015   0.000003     call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')
    1              0.000001 endif
                            
                            
                            "SECTION: Init variable calls for key mappings {{{2
    1   0.000015   0.000003 call s:initVariable("g:NERDTreeMapActivateNode", "o")
    1   0.000017   0.000005 call s:initVariable("g:NERDTreeMapChangeRoot", "C")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapChdir", "cd")
    1   0.000015   0.000003 call s:initVariable("g:NERDTreeMapCloseChildren", "X")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapCloseDir", "x")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapMenu", "m")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapHelp", "?")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapJumpLastChild", "J")
    1   0.000015   0.000003 call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapJumpParent", "p")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapJumpRoot", "P")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapOpenExpl", "e")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapOpenInTab", "t")
    1   0.000015   0.000003 call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")
    1   0.000017   0.000005 call s:initVariable("g:NERDTreeMapOpenRecursively", "O")
    1   0.000014   0.000003 call s:initVariable("g:NERDTreeMapOpenSplit", "i")
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMapOpenVSplit", "s")
    1   0.000013   0.000004 call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)
    1   0.000013   0.000004 call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)
    1   0.000013   0.000004 call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMapQuit", "q")
    1   0.000016   0.000003 call s:initVariable("g:NERDTreeMapRefresh", "r")
    1   0.000013   0.000003 call s:initVariable("g:NERDTreeMapRefreshRoot", "R")
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMapToggleFiles", "F")
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMapToggleFilters", "f")
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMapToggleHidden", "I")
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMapToggleZoom", "A")
    1   0.000011   0.000003 call s:initVariable("g:NERDTreeMapUpdir", "u")
    1   0.000012   0.000003 call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")
    1   0.000015   0.000005 call s:initVariable("g:NERDTreeMapCWD", "CD")
                            
                            "SECTION: Load class files{{{2
    1   0.004949   0.000007 call nerdtree#loadClassFiles()
                            
                            " SECTION: Commands {{{1
                            "============================================================
    1   0.000655   0.000138 call nerdtree#ui_glue#setupCommands()
                            
                            " SECTION: Auto commands {{{1
                            "============================================================
    1              0.000002 augroup NERDTree
                                "Save the cursor position whenever we close the nerd tree
    1   0.000015   0.000014     exec "autocmd BufLeave ". g:NERDTreeCreator.BufNamePrefix() ."* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif"
                            
                                "disallow insert mode in the NERDTree
    1   0.000009   0.000008     exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"
    1              0.000001 augroup END
                            
    1              0.000001 if g:NERDTreeHijackNetrw
    1              0.000001     augroup NERDTreeHijackNetrw
    1              0.000004         autocmd VimEnter * silent! autocmd! FileExplorer
    1              0.000004         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))
    1              0.000001     augroup END
    1              0.000003 endif
                            
                            " SECTION: Public API {{{1
                            "============================================================
    1              0.000002 function! NERDTreeAddMenuItem(options)
                                call g:NERDTreeMenuItem.Create(a:options)
                            endfunction
                            
    1              0.000001 function! NERDTreeAddMenuSeparator(...)
                                let opts = a:0 ? a:1 : {}
                                call g:NERDTreeMenuItem.CreateSeparator(opts)
                            endfunction
                            
    1              0.000001 function! NERDTreeAddSubmenu(options)
                                return g:NERDTreeMenuItem.Create(a:options)
                            endfunction
                            
    1              0.000001 function! NERDTreeAddKeyMap(options)
                                call g:NERDTreeKeyMap.Create(a:options)
                            endfunction
                            
    1              0.000001 function! NERDTreeRender()
                                call nerdtree#renderView()
                            endfunction
                            
    1              0.000001 function! NERDTreeFocus()
                                if g:NERDTree.IsOpen()
                                    call g:NERDTree.CursorToTreeWin()
                                else
                                    call g:NERDTreeCreator.ToggleTabTree("")
                                endif
                            endfunction
                            
    1              0.000001 function! NERDTreeCWD()
                                call NERDTreeFocus()
                                call nerdtree#ui_glue#chRootCwd()
                            endfunction
                            
    1              0.000001 function! NERDTreeAddPathFilter(callback)
                                call g:NERDTree.AddPathFilter(a:callback)
                            endfunction
                            
                            " SECTION: Post Source Actions {{{1
    1   0.003632   0.000009 call nerdtree#postSourceActions()
                            
                            "reset &cpo back to users setting
    1              0.000006 let &cpo = s:old_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/autoload/nerdtree.vim
Sourced 1 time
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
    1              0.000005 if exists("g:loaded_nerdtree_autoload")
                                finish
                            endif
    1              0.000005 let g:loaded_nerdtree_autoload = 1
                            
    1              0.000002 function! nerdtree#version()
                                return '5.0.0'
                            endfunction
                            
                            " SECTION: General Functions {{{1
                            "============================================================
                            
                            "FUNCTION: nerdtree#checkForBrowse(dir) {{{2
                            "inits a window tree in the current buffer if appropriate
    1              0.000002 function! nerdtree#checkForBrowse(dir)
                                if !isdirectory(a:dir)
                                    return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)
                            endfunction
                            
                            "FUNCTION: s:reuseWin(dir) {{{2
                            "finds a NERDTree buffer with root of dir, and opens it.
    1              0.000002 function! s:reuseWin(dir) abort
                                let path = g:NERDTreePath.New(fnamemodify(a:dir, ":p"))
                            
                                for i in range(1, bufnr("$"))
                                    unlet! nt
                                    let nt = getbufvar(i, "NERDTree")
                                    if empty(nt)
                                        continue
                                    endif
                            
                                    if nt.isWinTree() && nt.root.path.equals(path)
                                        call nt.setPreviousBuf(bufnr("#"))
                                        exec "buffer " . i
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction
                            
                            " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2
                            " completion function for the bookmark commands
    1              0.000002 function! nerdtree#completeBookmarks(A,L,P)
                                return filter(g:NERDTreeBookmark.BookmarkNames(), 'v:val =~# "^' . a:A . '"')
                            endfunction
                            
                            "FUNCTION: nerdtree#compareNodes(dir) {{{2
    1              0.000002 function! nerdtree#compareNodes(n1, n2)
                                return a:n1.path.compareTo(a:n2.path)
                            endfunction
                            
                            "FUNCTION: nerdtree#compareNodesBySortKey(n1, n2) {{{2
    1              0.000002 function! nerdtree#compareNodesBySortKey(n1, n2)
                                let sortKey1 = a:n1.path.getSortKey()
                                let sortKey2 = a:n2.path.getSortKey()
                                let i = 0
                                while i < min([len(sortKey1), len(sortKey2)])
                                    " Compare chunks upto common length.
                                    " If chunks have different type, the one which has
                                    " integer type is the lesser.
                                    if type(sortKey1[i]) == type(sortKey2[i])
                                        if sortKey1[i] <# sortKey2[i]
                                            return - 1
                                        elseif sortKey1[i] ># sortKey2[i]
                                            return 1
                                        endif
                                    elseif type(sortKey1[i]) == v:t_number
                                        return -1
                                    elseif type(sortKey2[i]) == v:t_number
                                        return 1
                                    endif
                                    let i = i + 1
                                endwhile
                            
                                " Keys are identical upto common length.
                                " The key which has smaller chunks is the lesser one.
                                if len(sortKey1) < len(sortKey2)
                                    return -1
                                elseif len(sortKey1) > len(sortKey2)
                                    return 1
                                else
                                    return 0
                                endif
                            endfunction
                            
                            " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2
                            " Issue a deprecation warning for a:func. If a second arg is given, use this
                            " as the deprecation message
    1              0.000002 function! nerdtree#deprecated(func, ...)
                                let msg = a:0 ? a:func . ' ' . a:1 : a:func . ' is deprecated'
                            
                                if !exists('s:deprecationWarnings')
                                    let s:deprecationWarnings = {}
                                endif
                                if !has_key(s:deprecationWarnings, a:func)
                                    let s:deprecationWarnings[a:func] = 1
                                    echomsg msg
                                endif
                            endfunction
                            
                            " FUNCTION: nerdtree#exec(cmd) {{{2
                            " Same as :exec cmd but with eventignore set for the duration
                            " to disable the autocommands used by NERDTree (BufEnter,
                            " BufLeave and VimEnter)
    1              0.000002 function! nerdtree#exec(cmd)
                                let old_ei = &ei
                                set ei=BufEnter,BufLeave,VimEnter
                                exec a:cmd
                                let &ei = old_ei
                            endfunction
                            
                            " FUNCTION: nerdtree#has_opt(options, name) {{{2
    1              0.000002 function! nerdtree#has_opt(options, name)
                                return has_key(a:options, a:name) && a:options[a:name] == 1
                            endfunction
                            
                            " FUNCTION: nerdtree#loadClassFiles() {{{2
    1              0.000001 function! nerdtree#loadClassFiles()
                                runtime lib/nerdtree/path.vim
                                runtime lib/nerdtree/menu_controller.vim
                                runtime lib/nerdtree/menu_item.vim
                                runtime lib/nerdtree/key_map.vim
                                runtime lib/nerdtree/bookmark.vim
                                runtime lib/nerdtree/tree_file_node.vim
                                runtime lib/nerdtree/tree_dir_node.vim
                                runtime lib/nerdtree/opener.vim
                                runtime lib/nerdtree/creator.vim
                                runtime lib/nerdtree/flag_set.vim
                                runtime lib/nerdtree/nerdtree.vim
                                runtime lib/nerdtree/ui.vim
                                runtime lib/nerdtree/event.vim
                                runtime lib/nerdtree/notifier.vim
                            endfunction
                            
                            " FUNCTION: nerdtree#postSourceActions() {{{2
    1              0.000001 function! nerdtree#postSourceActions()
                                call g:NERDTreeBookmark.CacheBookmarks(1)
                                call nerdtree#ui_glue#createDefaultBindings()
                            
                                "load all nerdtree plugins
                                runtime! nerdtree_plugin/**/*.vim
                            endfunction
                            
                            "FUNCTION: nerdtree#runningWindows(dir) {{{2
    1              0.000001 function! nerdtree#runningWindows()
                                return has("win16") || has("win32") || has("win64")
                            endfunction
                            
                            "FUNCTION: nerdtree#runningCygwin(dir) {{{2
    1              0.000001 function! nerdtree#runningCygwin()
                                return has("win32unix")
                            endfunction
                            
                            " SECTION: View Functions {{{1
                            "============================================================
                            
                            "FUNCTION: nerdtree#echo  {{{2
                            "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages
                            "
                            "Args:
                            "msg: the message to echo
    1              0.000001 function! nerdtree#echo(msg)
                                redraw
                                echomsg "NERDTree: " . a:msg
                            endfunction
                            
                            "FUNCTION: nerdtree#echoError {{{2
                            "Wrapper for nerdtree#echo, sets the message type to errormsg for this message
                            "Args:
                            "msg: the message to echo
    1              0.000002 function! nerdtree#echoError(msg)
                                echohl errormsg
                                call nerdtree#echo(a:msg)
                                echohl normal
                            endfunction
                            
                            "FUNCTION: nerdtree#echoWarning {{{2
                            "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message
                            "Args:
                            "msg: the message to echo
    1              0.000001 function! nerdtree#echoWarning(msg)
                                echohl warningmsg
                                call nerdtree#echo(a:msg)
                                echohl normal
                            endfunction
                            
                            "FUNCTION: nerdtree#renderView {{{2
    1              0.000001 function! nerdtree#renderView()
                                call b:NERDTree.render()
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/path.vim
Sourced 1 time
Total time:   0.000659
 Self time:   0.000659

count  total (s)   self (s)
                            " ============================================================================
                            " CLASS: Path
                            "
                            " The Path class provides an abstracted representation of a file system
                            " pathname.  Various operations on pathnames are provided and a number of
                            " representations of a given path name can be accessed here.
                            " ============================================================================
                            
                            
    1              0.000003 let s:Path = {}
    1              0.000002 let g:NERDTreePath = s:Path
                            
                            " FUNCTION: Path.AbsolutePathFor(pathStr) {{{1
    1              0.000002 function! s:Path.AbsolutePathFor(pathStr)
                                let l:prependWorkingDir = 0
                            
                                if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)' && a:pathStr !~# '^\(\\\\\|\/\/\)'
                                else
                                    let l:prependWorkingDir = a:pathStr !~# '^/'
                                endif
                            
                                let l:result = a:pathStr
                            
                                if l:prependWorkingDir
                                    let l:result = getcwd() . s:Path.Slash() . a:pathStr
                                endif
                            
                                return l:result
                            endfunction
                            
                            " FUNCTION: Path.bookmarkNames() {{{1
    1              0.000001 function! s:Path.bookmarkNames()
                                if !exists("self._bookmarkNames")
                                    call self.cacheDisplayString()
                                endif
                                return self._bookmarkNames
                            endfunction
                            
                            " FUNCTION: Path.cacheDisplayString() {{{1
    1              0.000001 function! s:Path.cacheDisplayString() abort
                                let self.cachedDisplayString = self.getLastPathComponent(1)
                            
                                if self.isExecutable
                                    let self.cachedDisplayString = self.cachedDisplayString . '*'
                                endif
                            
                                let self._bookmarkNames = []
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
                                if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
                                if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
                                if self.isReadOnly
                                    let self.cachedDisplayString .=  ' ['.g:NERDTreeGlyphReadOnly.']'
                                endif
                            endfunction
                            
                            " FUNCTION: Path.changeToDir() {{{1
    1              0.000001 function! s:Path.changeToDir()
                                let dir = self.str({'format': 'Cd'})
                                if self.isDirectory ==# 0
                                    let dir = self.getParent().str({'format': 'Cd'})
                                endif
                            
                                try
                                    execute "cd " . dir
                                    call nerdtree#echo("CWD is now: " . getcwd())
                                catch
                                    throw "NERDTree.PathChangeError: cannot change CWD to " . dir
                                endtry
                            endfunction
                            
                            " FUNCTION: Path.compareTo() {{{1
                            "
                            " Compares this Path to the given path and returns 0 if they are equal, -1 if
                            " this Path is "less than" the given path, or 1 if it is "greater".
                            "
                            " Args:
                            " path: the path object to compare this to
                            "
                            " Return:
                            " 1, -1 or 0
    1              0.000001 function! s:Path.compareTo(path)
                                let thisPath = self.getLastPathComponent(1)
                                let thatPath = a:path.getLastPathComponent(1)
                            
                                "if the paths are the same then clearly we return 0
                                if thisPath ==# thatPath
                                    return 0
                                endif
                            
                                let thisSS = self.getSortOrderIndex()
                                let thatSS = a:path.getSortOrderIndex()
                            
                                "compare the sort sequences, if they are different then the return
                                "value is easy
                                if thisSS < thatSS
                                    return -1
                                elseif thisSS > thatSS
                                    return 1
                                else
                                    if !g:NERDTreeSortHiddenFirst
                                        let thisPath = substitute(thisPath, '^[._]', '', '')
                                        let thatPath = substitute(thatPath, '^[._]', '', '')
                                    endif
                                    "if the sort sequences are the same then compare the paths
                                    "alphabetically
                                    let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
                                    if pathCompare
                                        return -1
                                    else
                                        return 1
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: Path.Create(fullpath) {{{1
                            "
                            " Factory method.
                            "
                            " Creates a path object with the given path. The path is also created on the
                            " filesystem. If the path already exists, a NERDTree.Path.Exists exception is
                            " thrown. If any other errors occur, a NERDTree.Path exception is thrown.
                            "
                            " Args:
                            " fullpath: the full filesystem path to the file/dir to create
    1              0.000001 function! s:Path.Create(fullpath)
                                "bail if the a:fullpath already exists
                                if isdirectory(a:fullpath) || filereadable(a:fullpath)
                                    throw "NERDTree.CreatePathError: Directory Exists: '" . a:fullpath . "'"
                                endif
                            
                                try
                            
                                    "if it ends with a slash, assume its a dir create it
                                    if a:fullpath =~# '\(\\\|\/\)$'
                                        "whack the trailing slash off the end if it exists
                                        let fullpath = substitute(a:fullpath, '\(\\\|\/\)$', '', '')
                            
                                        call mkdir(fullpath, 'p')
                            
                                    "assume its a file and create
                                    else
                                        call s:Path.createParentDirectories(a:fullpath)
                                        call writefile([], a:fullpath)
                                    endif
                                catch
                                    throw "NERDTree.CreatePathError: Could not create path: '" . a:fullpath . "'"
                                endtry
                            
                                return s:Path.New(a:fullpath)
                            endfunction
                            
                            " FUNCTION: Path.copy(dest) {{{1
                            "
                            " Copies the file/dir represented by this Path to the given location
                            "
                            " Args:
                            " dest: the location to copy this dir/file to
    1              0.000001 function! s:Path.copy(dest)
                                if !s:Path.CopyingSupported()
                                    throw "NERDTree.CopyingNotSupportedError: Copying is not supported on this OS"
                                endif
                            
                                call s:Path.createParentDirectories(a:dest)
                            
                                if exists('g:NERDTreeCopyCmd')
                                    let cmd_prefix = g:NERDTreeCopyCmd
                                else
                                    let cmd_prefix = (self.isDirectory ? g:NERDTreeCopyDirCmd : g:NERDTreeCopyFileCmd)
                                endif
                            
                                let cmd = cmd_prefix . " " . escape(self.str(), self._escChars()) . " " . escape(a:dest, self._escChars())
                                let success = system(cmd)
                                if v:shell_error != 0
                                    throw "NERDTree.CopyError: Could not copy ''". self.str() ."'' to: '" . a:dest . "'"
                                endif
                            endfunction
                            
                            " FUNCTION: Path.CopyingSupported() {{{1
                            "
                            " returns 1 if copying is supported for this OS
    1              0.000001 function! s:Path.CopyingSupported()
                                return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))
                            endfunction
                            
                            " FUNCTION: Path.copyingWillOverwrite(dest) {{{1
                            "
                            " returns 1 if copy this path to the given location will cause files to
                            " overwritten
                            "
                            " Args:
                            " dest: the location this path will be copied to
    1              0.000001 function! s:Path.copyingWillOverwrite(dest)
                                if filereadable(a:dest)
                                    return 1
                                endif
                            
                                if isdirectory(a:dest)
                                    let path = s:Path.JoinPathStrings(a:dest, self.getLastPathComponent(0))
                                    if filereadable(path)
                                        return 1
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: Path.createParentDirectories(path) {{{1
                            "
                            " create parent directories for this path if needed
                            " without throwing any errors if those directories already exist
                            "
                            " Args:
                            " path: full path of the node whose parent directories may need to be created
    1              0.000001 function! s:Path.createParentDirectories(path)
                                let dir_path = fnamemodify(a:path, ':h')
                                if !isdirectory(dir_path)
                                    call mkdir(dir_path, 'p')
                                endif
                            endfunction
                            
                            " FUNCTION: Path.delete() {{{1
                            "
                            " Deletes the file or directory represented by this path.
                            "
                            " Throws NERDTree.Path.Deletion exceptions
    1              0.000001 function! s:Path.delete()
                                if self.isDirectory
                            
                                    let cmd = g:NERDTreeRemoveDirCmd . self.str({'escape': 1})
                                    let success = system(cmd)
                            
                                    if v:shell_error != 0
                                        throw "NERDTree.PathDeletionError: Could not delete directory: '" . self.str() . "'"
                                    endif
                                else
                                    if exists('g:NERDTreeRemoveFileCmd')
                                        let cmd = g:NERDTreeRemoveFileCmd . self.str({'escape': 1})
                                        let success = system(cmd)
                                    else
                                        let success = delete(self.str())
                                    endif
                            
                                    if success != 0
                                        throw "NERDTree.PathDeletionError: Could not delete file: '" . self.str() . "'"
                                    endif
                                endif
                            
                                "delete all bookmarks for this path
                                for i in self.bookmarkNames()
                                    let bookmark = g:NERDTreeBookmark.BookmarkFor(i)
                                    call bookmark.delete()
                                endfor
                            endfunction
                            
                            " FUNCTION: Path.displayString() {{{1
                            "
                            " Returns a string that specifies how the path should be represented as a
                            " string
    1              0.000003 function! s:Path.displayString()
                                if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
                                endif
                            
                                return self.cachedDisplayString
                            endfunction
                            
                            " FUNCTION: Path.edit() {{{1
    1              0.000001 function! s:Path.edit()
                                exec "edit " . self.str({'format': 'Edit'})
                            endfunction
                            
                            " FUNCTION: Path.extractDriveLetter(fullpath) {{{1
                            "
                            " If running windows, cache the drive letter for this path
    1              0.000002 function! s:Path.extractDriveLetter(fullpath)
                                if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
                                    let self.drive = ''
                                endif
                            
                            endfunction
                            
                            " FUNCTION: Path.exists() {{{1
                            " return 1 if this path points to a location that is readable or is a directory
    1              0.000001 function! s:Path.exists()
                                let p = self.str()
                                return filereadable(p) || isdirectory(p)
                            endfunction
                            
                            " FUNCTION: Path._escChars() {{{1
    1              0.000001 function! s:Path._escChars()
                                if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>$"
                                endif
                            
                                return " \\`\|\"#%&,?()\*^<>[]$"
                            endfunction
                            
                            " FUNCTION: Path.getDir() {{{1
                            "
                            " Returns this path if it is a directory, else this paths parent.
                            "
                            " Return:
                            " a Path object
    1              0.000001 function! s:Path.getDir()
                                if self.isDirectory
                                    return self
                                else
                                    return self.getParent()
                                endif
                            endfunction
                            
                            " FUNCTION: Path.getParent() {{{1
                            "
                            " Returns a new path object for this paths parent
                            "
                            " Return:
                            " a new Path object
    1              0.000001 function! s:Path.getParent()
                                if nerdtree#runningWindows()
                                    let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
                                else
                                    let path = '/'. join(self.pathSegments[0:-2], '/')
                                endif
                            
                                return s:Path.New(path)
                            endfunction
                            
                            " FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
                            "
                            " Gets the last part of this path.
                            "
                            " Args:
                            " dirSlash: if 1 then a trailing slash will be added to the returned value for
                            " directory nodes.
    1              0.000001 function! s:Path.getLastPathComponent(dirSlash)
                                if empty(self.pathSegments)
                                    return ''
                                endif
                                let toReturn = self.pathSegments[-1]
                                if a:dirSlash && self.isDirectory
                                    let toReturn = toReturn . '/'
                                endif
                                return toReturn
                            endfunction
                            
                            " FUNCTION: Path.getSortOrderIndex() {{{1
                            " returns the index of the pattern in g:NERDTreeSortOrder that this path matches
    1              0.000001 function! s:Path.getSortOrderIndex()
                                let i = 0
                                while i < len(g:NERDTreeSortOrder)
                                    if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
                                        return i
                                    endif
                                    let i = i + 1
                                endwhile
                            
                                return index(g:NERDTreeSortOrder, '*')
                            endfunction
                            
                            " FUNCTION: Path._splitChunks(path) {{{1
                            " returns a list of path chunks
    1              0.000001 function! s:Path._splitChunks(path)
                                let chunks = split(a:path, '\(\D\+\|\d\+\)\zs')
                                let i = 0
                                while i < len(chunks)
                                    "convert number literals to numbers
                                    if match(chunks[i], '^\d\+$') == 0
                                        let chunks[i] = str2nr(chunks[i])
                                    endif
                                    let i = i + 1
                                endwhile
                                return chunks
                            endfunction
                            
                            " FUNCTION: Path.getSortKey() {{{1
                            " returns a key used in compare function for sorting
    1              0.000001 function! s:Path.getSortKey()
                                if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
                                    let path = self.getLastPathComponent(1)
                                    if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
                                    endif
                                    if !g:NERDTreeCaseSensitiveSort
                                        let path = tolower(path)
                                    endif
                                    if !g:NERDTreeNaturalSort
                                        let self._sortKey = [self.getSortOrderIndex(), path]
                                    else
                                        let self._sortKey = [self.getSortOrderIndex()] + self._splitChunks(path)
                                    endif
                                endif
                            
                                return self._sortKey
                            endfunction
                            
                            " FUNCTION: Path.isHiddenUnder(path) {{{1
    1              0.000001 function! s:Path.isHiddenUnder(path)
                            
                                if !self.isUnder(a:path)
                                    return 0
                                endif
                            
                                let l:startIndex = len(a:path.pathSegments)
                                let l:segments = self.pathSegments[l:startIndex : ]
                            
                                for l:segment in l:segments
                            
                                    if l:segment =~# '^\.'
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction
                            
                            " FUNCTION: Path.isUnixHiddenFile() {{{1
                            " check for unix hidden files
    1              0.000001 function! s:Path.isUnixHiddenFile()
                                return self.getLastPathComponent(0) =~# '^\.'
                            endfunction
                            
                            " FUNCTION: Path.isUnixHiddenPath() {{{1
                            " check for unix path with hidden components
    1              0.000001 function! s:Path.isUnixHiddenPath()
                                if self.getLastPathComponent(0) =~# '^\.'
                                    return 1
                                else
                                    for segment in self.pathSegments
                                        if segment =~# '^\.'
                                            return 1
                                        endif
                                    endfor
                                    return 0
                                endif
                            endfunction
                            
                            " FUNCTION: Path.ignore(nerdtree) {{{1
                            " returns true if this path should be ignored
    1              0.000001 function! s:Path.ignore(nerdtree)
                                "filter out the user specified paths to ignore
                                if a:nerdtree.ui.isIgnoreFilterEnabled()
                                    for i in g:NERDTreeIgnore
                                        if self._ignorePatternMatches(i)
                                            return 1
                                        endif
                                    endfor
                            
                                    for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
                                    endfor
                                endif
                            
                                "dont show hidden files unless instructed to
                                if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
                                endif
                            
                                if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " FUNCTION: Path._ignorePatternMatches(pattern) {{{1
                            " returns true if this path matches the given ignore pattern
    1              0.000001 function! s:Path._ignorePatternMatches(pattern)
                                let pat = a:pattern
                                if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
                                return self.getLastPathComponent(0) =~# pat
                            endfunction
                            
                            " FUNCTION: Path.isAncestor(path) {{{1
                            " return 1 if this path is somewhere above the given path in the filesystem.
                            "
                            " a:path should be a dir
    1              0.000001 function! s:Path.isAncestor(path)
                                if !self.isDirectory
                                    return 0
                                endif
                            
                                let this = self.str()
                                let that = a:path.str()
                                return stridx(that, this) == 0
                            endfunction
                            
                            " FUNCTION: Path.isUnder(path) {{{1
                            " return 1 if this path is somewhere under the given path in the filesystem.
    1              0.000001 function! s:Path.isUnder(path)
                                if a:path.isDirectory == 0
                                    return 0
                                endif
                            
                                let this = self.str()
                                let that = a:path.str()
                                return stridx(this, that . s:Path.Slash()) == 0
                            endfunction
                            
                            " FUNCTION: Path.JoinPathStrings(...) {{{1
    1              0.000001 function! s:Path.JoinPathStrings(...)
                                let components = []
                                for i in a:000
                                    let components = extend(components, split(i, '/'))
                                endfor
                                return '/' . join(components, '/')
                            endfunction
                            
                            " FUNCTION: Path.equals() {{{1
                            "
                            " Determines whether 2 path objects are "equal".
                            " They are equal if the paths they represent are the same
                            "
                            " Args:
                            " path: the other path obj to compare this with
    1              0.000001 function! s:Path.equals(path)
                                return self.str() ==# a:path.str()
                            endfunction
                            
                            " FUNCTION: Path.New(pathStr) {{{1
    1              0.000001 function! s:Path.New(pathStr)
                                let l:newPath = copy(self)
                            
                                call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
                                let l:newPath.cachedDisplayString = ''
                                let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
                                return l:newPath
                            endfunction
                            
                            " FUNCTION: Path.Slash() {{{1
                            " Return the path separator used by the underlying file system.  Special
                            " consideration is taken for the use of the 'shellslash' option on Windows
                            " systems.
    1              0.000001 function! s:Path.Slash()
                            
                                if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
                                endif
                            
                                return '/'
                            endfunction
                            
                            " FUNCTION: Path.Resolve() {{{1
                            " Invoke the vim resolve() function and return the result
                            " This is necessary because in some versions of vim resolve() removes trailing
                            " slashes while in other versions it doesn't.  This always removes the trailing
                            " slash
    1              0.000001 function! s:Path.Resolve(path)
                                let tmp = resolve(a:path)
                                return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp
                            endfunction
                            
                            " FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
                            "
                            "
                            " Throws NERDTree.Path.InvalidArguments exception.
    1              0.000001 function! s:Path.readInfoFromDisk(fullpath)
                                call self.extractDriveLetter(a:fullpath)
                            
                                let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
                                if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
                                let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
                                let self.isReadOnly = 0
                                if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
                                elseif filereadable(a:fullpath)
                                    let self.isDirectory = 0
                                    let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
                                let self.isExecutable = 0
                                if !self.isDirectory
                                    let self.isExecutable = getfperm(a:fullpath) =~# 'x'
                                endif
                            
                                "grab the last part of the path (minus the trailing slash)
                                let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
                                let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
                                let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
                                if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: Path.refresh(nerdtree) {{{1
    1              0.000001 function! s:Path.refresh(nerdtree)
                                call self.readInfoFromDisk(self.str())
                                call g:NERDTreePathNotifier.NotifyListeners('refresh', self, a:nerdtree, {})
                                call self.cacheDisplayString()
                            endfunction
                            
                            " FUNCTION: Path.refreshFlags(nerdtree) {{{1
    1              0.000001 function! s:Path.refreshFlags(nerdtree)
                                call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
                                call self.cacheDisplayString()
                            endfunction
                            
                            " FUNCTION: Path.rename() {{{1
                            "
                            " Renames this node on the filesystem
    1              0.000001 function! s:Path.rename(newPath)
                                if a:newPath ==# ''
                                    throw "NERDTree.InvalidArgumentsError: Invalid newPath for renaming = ". a:newPath
                                endif
                            
                                call s:Path.createParentDirectories(a:newPath)
                            
                                let success =  rename(self.str(), a:newPath)
                                if success != 0
                                    throw "NERDTree.PathRenameError: Could not rename: '" . self.str() . "'" . 'to:' . a:newPath
                                endif
                                call self.readInfoFromDisk(a:newPath)
                            
                                for i in self.bookmarkNames()
                                    let b = g:NERDTreeBookmark.BookmarkFor(i)
                                    call b.setPath(copy(self))
                                endfor
                                call g:NERDTreeBookmark.Write()
                            endfunction
                            
                            " FUNCTION: Path.str() {{{1
                            " Return a string representation of this Path object.
                            "
                            " Args:
                            " This function takes a single dictionary (optional) with keys and values that
                            " specify how the returned pathname should be formatted.
                            "
                            " The dictionary may have the following keys:
                            "  'format'
                            "  'escape'
                            "  'truncateTo'
                            "
                            " The 'format' key may have a value of:
                            "  'Cd' - a string to be used with ":cd" and similar commands
                            "  'Edit' - a string to be used with ":edit" and similar commands
                            "  'UI' - a string to be displayed in the NERDTree user interface
                            "
                            " The 'escape' key, if specified, will cause the output to be escaped with
                            " Vim's internal "shellescape()" function.
                            "
                            " The 'truncateTo' key shortens the length of the path to that given by the
                            " value associated with 'truncateTo'. A '<' is prepended.
    1              0.000001 function! s:Path.str(...)
                                let options = a:0 ? a:1 : {}
                                let toReturn = ""
                            
                                if has_key(options, 'format')
                                    let format = options['format']
                                    if has_key(self, '_strFor' . format)
                                        exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
                                else
                                    let toReturn = self._str()
                                endif
                            
                                if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
                                if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if strdisplaywidth(toReturn) > limit-1
                                        while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
                                            let toReturn = substitute(toReturn, '^.', '', '')
                                        endwhile
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
                                endif
                            
                                return toReturn
                            endfunction
                            
                            " FUNCTION: Path._strForUI() {{{1
    1              0.000001 function! s:Path._strForUI()
                                let toReturn = '/' . join(self.pathSegments, '/')
                                if self.isDirectory && toReturn != '/'
                                    let toReturn  = toReturn . '/'
                                endif
                                return toReturn
                            endfunction
                            
                            " FUNCTION: Path._strForCd() {{{1
                            " Return a string representation of this Path that is suitable for use as an
                            " argument to Vim's internal ":cd" command.
    1              0.000001 function! s:Path._strForCd()
                                return fnameescape(self.str())
                            endfunction
                            
                            " FUNCTION: Path._strForEdit() {{{1
                            " Return a string representation of this Path that is suitable for use as an
                            " argument to Vim's internal ":edit" command.
    1              0.000001 function! s:Path._strForEdit()
                            
                                " Make the path relative to the current working directory, if possible.
                                let l:result = fnamemodify(self.str(), ':.')
                            
                                " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
                                " back, if necessary.
                                if nerdtree#runningWindows() && l:result[0] == s:Path.Slash()
                                    let l:result = self.drive . l:result
                                endif
                            
                                let l:result = fnameescape(l:result)
                            
                                if empty(l:result)
                                    let l:result = '.'
                                endif
                            
                                return l:result
                            endfunction
                            
                            " FUNCTION: Path._strForGlob() {{{1
    1              0.000001 function! s:Path._strForGlob()
                                let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
                                if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
                                let toReturn = lead . join(self.pathSegments, s:Path.Slash())
                            
                                if !nerdtree#runningWindows()
                                    let toReturn = escape(toReturn, self._escChars())
                                endif
                                return toReturn
                            endfunction
                            
                            " FUNCTION: Path._str() {{{1
                            " Return the absolute pathname associated with this Path object.  The pathname
                            " returned is appropriate for the underlying file system.
    1              0.000001 function! s:Path._str()
                                let l:separator = s:Path.Slash()
                                let l:leader = l:separator
                            
                                if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
                                endif
                            
                                return l:leader . join(self.pathSegments, l:separator)
                            endfunction
                            
                            " FUNCTION: Path.strTrunk() {{{1
                            " Gets the path without the last segment on the end.
    1              0.000001 function! s:Path.strTrunk()
                                return self.drive . '/' . join(self.pathSegments[0:-2], '/')
                            endfunction
                            
                            " FUNCTION: Path.tabnr() {{{1
                            " return the number of the first tab that is displaying this file
                            "
                            " return 0 if no tab was found
    1              0.000001 function! s:Path.tabnr()
                                let str = self.str()
                                for t in range(tabpagenr('$'))
                                    for b in tabpagebuflist(t+1)
                                        if str ==# expand('#' . b . ':p')
                                            return t+1
                                        endif
                                    endfor
                                endfor
                                return 0
                            endfunction
                            
                            " FUNCTION: Path.WinToUnixPath(pathstr){{{1
                            " Takes in a windows path and returns the unix equiv
                            "
                            " A class level method
                            "
                            " Args:
                            " pathstr: the windows path to convert
    1              0.000001 function! s:Path.WinToUnixPath(pathstr)
                                if !nerdtree#runningWindows()
                                    return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/menu_controller.vim
Sourced 1 time
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
                            "CLASS: MenuController
                            "============================================================
    1              0.000004 let s:MenuController = {}
    1              0.000002 let g:NERDTreeMenuController = s:MenuController
                            
                            "FUNCTION: MenuController.New(menuItems) {{{1
                            "create a new menu controller that operates on the given menu items
    1              0.000002 function! s:MenuController.New(menuItems)
                                let newMenuController =  copy(self)
                                if a:menuItems[0].isSeparator()
                                    let newMenuController.menuItems = a:menuItems[1:-1]
                                else
                                    let newMenuController.menuItems = a:menuItems
                                endif
                                return newMenuController
                            endfunction
                            
                            " FUNCTION: MenuController.showMenu() {{{1
                            " Enter the main loop of the NERDTree menu, prompting the user to select
                            " a menu item.
    1              0.000001 function! s:MenuController.showMenu()
                                call self._saveOptions()
                            
                                try
                                    let self.selection = 0
                                    let l:done = 0
                            
                                    while !l:done
                                        redraw!
                                        call self._echoPrompt()
                            
                                        let l:key = nr2char(getchar())
                                        let l:done = self._handleKeypress(l:key)
                                    endwhile
                                finally
                                    call self._restoreOptions()
                            
                                    " Redraw when "Ctrl-C" or "Esc" is received.
                                    if !l:done || self.selection == -1
                                        redraw!
                                    endif
                                endtry
                            
                                if self.selection != -1
                                    let l:m = self._current()
                                    call l:m.execute()
                                endif
                            endfunction
                            
                            "FUNCTION: MenuController._echoPrompt() {{{1
    1              0.000001 function! s:MenuController._echoPrompt()
                                echo "NERDTree Menu. Use j/k/enter and the shortcuts indicated"
                                echo "=========================================================="
                            
                                for i in range(0, len(self.menuItems)-1)
                                    if self.selection == i
                                        echo "> " . self.menuItems[i].text
                                    else
                                        echo "  " . self.menuItems[i].text
                                    endif
                                endfor
                            endfunction
                            
                            "FUNCTION: MenuController._current(key) {{{1
                            "get the MenuItem that is currently selected
    1              0.000001 function! s:MenuController._current()
                                return self.menuItems[self.selection]
                            endfunction
                            
                            "FUNCTION: MenuController._handleKeypress(key) {{{1
                            "change the selection (if appropriate) and return 1 if the user has made
                            "their choice, 0 otherwise
    1              0.000001 function! s:MenuController._handleKeypress(key)
                                if a:key == 'j'
                                    call self._cursorDown()
                                elseif a:key == 'k'
                                    call self._cursorUp()
                                elseif a:key == nr2char(27) "escape
                                    let self.selection = -1
                                    return 1
                                elseif a:key == "\r" || a:key == "\n" "enter and ctrl-j
                                    return 1
                                else
                                    let index = self._nextIndexFor(a:key)
                                    if index != -1
                                        let self.selection = index
                                        if len(self._allIndexesFor(a:key)) == 1
                                            return 1
                                        endif
                                    endif
                                endif
                            
                                return 0
                            endfunction
                            
                            "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
                            "get indexes to all menu items with the given shortcut
    1              0.000001 function! s:MenuController._allIndexesFor(shortcut)
                                let toReturn = []
                            
                                for i in range(0, len(self.menuItems)-1)
                                    if self.menuItems[i].shortcut == a:shortcut
                                        call add(toReturn, i)
                                    endif
                                endfor
                            
                                return toReturn
                            endfunction
                            
                            "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
                            "get the index to the next menu item with the given shortcut, starts from the
                            "current cursor location and wraps around to the top again if need be
    1              0.000001 function! s:MenuController._nextIndexFor(shortcut)
                                for i in range(self.selection+1, len(self.menuItems)-1)
                                    if self.menuItems[i].shortcut == a:shortcut
                                        return i
                                    endif
                                endfor
                            
                                for i in range(0, self.selection)
                                    if self.menuItems[i].shortcut == a:shortcut
                                        return i
                                    endif
                                endfor
                            
                                return -1
                            endfunction
                            
                            "FUNCTION: MenuController._setCmdheight() {{{1
                            "sets &cmdheight to whatever is needed to display the menu
    1              0.000001 function! s:MenuController._setCmdheight()
                                let &cmdheight = len(self.menuItems) + 3
                            endfunction
                            
                            "FUNCTION: MenuController._saveOptions() {{{1
                            "set any vim options that are required to make the menu work (saving their old
                            "values)
    1              0.000001 function! s:MenuController._saveOptions()
                                let self._oldLazyredraw = &lazyredraw
                                let self._oldCmdheight = &cmdheight
                                set nolazyredraw
                                call self._setCmdheight()
                            endfunction
                            
                            "FUNCTION: MenuController._restoreOptions() {{{1
                            "restore the options we saved in _saveOptions()
    1              0.000001 function! s:MenuController._restoreOptions()
                                let &cmdheight = self._oldCmdheight
                                let &lazyredraw = self._oldLazyredraw
                            endfunction
                            
                            "FUNCTION: MenuController._cursorDown() {{{1
                            "move the cursor to the next menu item, skipping separators
    1              0.000001 function! s:MenuController._cursorDown()
                                let done = 0
                                while !done
                                    if self.selection < len(self.menuItems)-1
                                        let self.selection += 1
                                    else
                                        let self.selection = 0
                                    endif
                            
                                    if !self._current().isSeparator()
                                        let done = 1
                                    endif
                                endwhile
                            endfunction
                            
                            "FUNCTION: MenuController._cursorUp() {{{1
                            "move the cursor to the previous menu item, skipping separators
    1              0.000003 function! s:MenuController._cursorUp()
                                let done = 0
                                while !done
                                    if self.selection > 0
                                        let self.selection -= 1
                                    else
                                        let self.selection = len(self.menuItems)-1
                                    endif
                            
                                    if !self._current().isSeparator()
                                        let done = 1
                                    endif
                                endwhile
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/menu_item.vim
Sourced 1 time
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
                            "CLASS: MenuItem
                            "============================================================
    1              0.000003 let s:MenuItem = {}
    1              0.000002 let g:NERDTreeMenuItem = s:MenuItem
                            
                            "FUNCTION: MenuItem.All() {{{1
                            "get all top level menu items
    1              0.000001 function! s:MenuItem.All()
                                if !exists("s:menuItems")
                                    let s:menuItems = []
                                endif
                                return s:menuItems
                            endfunction
                            
                            "FUNCTION: MenuItem.AllEnabled() {{{1
                            "get all top level menu items that are currently enabled
    1              0.000001 function! s:MenuItem.AllEnabled()
                                let toReturn = []
                                for i in s:MenuItem.All()
                                    if i.enabled()
                                        call add(toReturn, i)
                                    endif
                                endfor
                                return toReturn
                            endfunction
                            
                            "FUNCTION: MenuItem.Create(options) {{{1
                            "make a new menu item and add it to the global list
    1              0.000001 function! s:MenuItem.Create(options)
                                let newMenuItem = copy(self)
                            
                                let newMenuItem.text = a:options['text']
                                let newMenuItem.shortcut = a:options['shortcut']
                                let newMenuItem.children = []
                            
                                let newMenuItem.isActiveCallback = -1
                                if has_key(a:options, 'isActiveCallback')
                                    let newMenuItem.isActiveCallback = a:options['isActiveCallback']
                                endif
                            
                                let newMenuItem.callback = -1
                                if has_key(a:options, 'callback')
                                    let newMenuItem.callback = a:options['callback']
                                endif
                            
                                if has_key(a:options, 'parent')
                                    call add(a:options['parent'].children, newMenuItem)
                                else
                                    call add(s:MenuItem.All(), newMenuItem)
                                endif
                            
                                return newMenuItem
                            endfunction
                            
                            "FUNCTION: MenuItem.CreateSeparator(options) {{{1
                            "make a new separator menu item and add it to the global list
    1              0.000001 function! s:MenuItem.CreateSeparator(options)
                                let standard_options = { 'text': '--------------------',
                                            \ 'shortcut': -1,
                                            \ 'callback': -1 }
                                let options = extend(a:options, standard_options, "force")
                            
                                return s:MenuItem.Create(options)
                            endfunction
                            
                            "FUNCTION: MenuItem.CreateSubmenu(options) {{{1
                            "make a new submenu and add it to global list
    1              0.000001 function! s:MenuItem.CreateSubmenu(options)
                                let standard_options = { 'callback': -1 }
                                let options = extend(a:options, standard_options, "force")
                            
                                return s:MenuItem.Create(options)
                            endfunction
                            
                            "FUNCTION: MenuItem.enabled() {{{1
                            "return 1 if this menu item should be displayed
                            "
                            "delegates off to the isActiveCallback, and defaults to 1 if no callback was
                            "specified
    1              0.000001 function! s:MenuItem.enabled()
                                if self.isActiveCallback != -1
                                    return {self.isActiveCallback}()
                                endif
                                return 1
                            endfunction
                            
                            "FUNCTION: MenuItem.execute() {{{1
                            "perform the action behind this menu item, if this menuitem has children then
                            "display a new menu for them, otherwise deletegate off to the menuitem's
                            "callback
    1              0.000001 function! s:MenuItem.execute()
                                if len(self.children)
                                    let mc = g:NERDTreeMenuController.New(self.children)
                                    call mc.showMenu()
                                else
                                    if self.callback != -1
                                        call {self.callback}()
                                    endif
                                endif
                            endfunction
                            
                            "FUNCTION: MenuItem.isSeparator() {{{1
                            "return 1 if this menuitem is a separator
    1              0.000001 function! s:MenuItem.isSeparator()
                                return self.callback == -1 && self.children == []
                            endfunction
                            
                            "FUNCTION: MenuItem.isSubmenu() {{{1
                            "return 1 if this menuitem is a submenu
    1              0.000001 function! s:MenuItem.isSubmenu()
                                return self.callback == -1 && !empty(self.children)
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/key_map.vim
Sourced 1 time
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
                            "CLASS: KeyMap
                            "============================================================
    1              0.000005 let s:KeyMap = {}
    1              0.000002 let g:NERDTreeKeyMap = s:KeyMap
    1              0.000001 let s:keyMaps = {}
                            
                            "FUNCTION: KeyMap.All() {{{1
    1              0.000001 function! s:KeyMap.All()
                                let sortedKeyMaps = values(s:keyMaps)
                                call sort(sortedKeyMaps, s:KeyMap.Compare, s:KeyMap)
                            
                                return sortedKeyMaps
                            endfunction
                            
                            "FUNCTION: KeyMap.Compare(keyMap1, keyMap2) {{{1
    1              0.000001 function! s:KeyMap.Compare(keyMap1, keyMap2)
                            
                                if a:keyMap1.key >? a:keyMap2.key
                                    return 1
                                endif
                            
                                if a:keyMap1.key <? a:keyMap2.key
                                    return -1
                                endif
                            
                                return 0
                            endfunction
                            
                            "FUNCTION: KeyMap.FindFor(key, scope) {{{1
    1              0.000001 function! s:KeyMap.FindFor(key, scope)
                                return get(s:keyMaps, a:key . a:scope, {})
                            endfunction
                            
                            "FUNCTION: KeyMap.BindAll() {{{1
    1              0.000001 function! s:KeyMap.BindAll()
                                for i in values(s:keyMaps)
                                    call i.bind()
                                endfor
                            endfunction
                            
                            "FUNCTION: KeyMap.bind() {{{1
    1              0.000001 function! s:KeyMap.bind()
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
                                let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
                                if self.key =~# specialNotationRegex
                                    let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
                                else
                                    let keymapInvokeString = self.key
                                endif
                            
                                let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
                            
                                exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'
                            endfunction
                            
                            "FUNCTION: KeyMap.Remove(key, scope) {{{1
    1              0.000001 function! s:KeyMap.Remove(key, scope)
                                return remove(s:keyMaps, a:key . a:scope)
                            endfunction
                            
                            "FUNCTION: KeyMap.invoke() {{{1
                            "Call the KeyMaps callback function
    1              0.000001 function! s:KeyMap.invoke(...)
                                let Callback = function(self.callback)
                                if a:0
                                    call Callback(a:1)
                                else
                                    call Callback()
                                endif
                            endfunction
                            
                            "FUNCTION: KeyMap.Invoke() {{{1
                            "Find a keymapping for a:key and the current scope invoke it.
                            "
                            "Scope is determined as follows:
                            "   * if the cursor is on a dir node then "DirNode"
                            "   * if the cursor is on a file node then "FileNode"
                            "   * if the cursor is on a bookmark then "Bookmark"
                            "
                            "If a keymap has the scope of "all" then it will be called if no other keymap
                            "is found for a:key and the scope.
    1              0.000001 function! s:KeyMap.Invoke(key)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
                                if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
                                let node = g:NERDTreeFileNode.GetSelected()
                                if !empty(node)
                            
                                    "try file node
                                    if !node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "FileNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
                                    if node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "DirNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, "Node")
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, "all")
                                if !empty(km)
                                    return km.invoke()
                                endif
                            endfunction
                            
                            "FUNCTION: KeyMap.Create(options) {{{1
    1              0.000001 function! s:KeyMap.Create(options)
                                let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
                            
                                "dont override other mappings unless the 'override' option is given
                                if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
                                    return
                                end
                            
                                let newKeyMap = copy(self)
                                let newKeyMap.key = opts['key']
                                let newKeyMap.quickhelpText = opts['quickhelpText']
                                let newKeyMap.callback = opts['callback']
                                let newKeyMap.scope = opts['scope']
                            
                                call s:KeyMap.Add(newKeyMap)
                            endfunction
                            
                            "FUNCTION: KeyMap.Add(keymap) {{{1
    1              0.000001 function! s:KeyMap.Add(keymap)
                                let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/bookmark.vim
Sourced 1 time
Total time:   0.000243
 Self time:   0.000243

count  total (s)   self (s)
                            " ============================================================================
                            " CLASS: Bookmark
                            "
                            " The Bookmark class serves two purposes:
                            "   (1) It is the top-level prototype for new, concrete Bookmark objects.
                            "   (2) It provides an interface for client code to query and manipulate the
                            "       global list of Bookmark objects within the current Vim session.
                            " ============================================================================
                            
                            
    1              0.000002 let s:Bookmark = {}
    1              0.000002 let g:NERDTreeBookmark = s:Bookmark
                            
                            " FUNCTION: Bookmark.activate(nerdtree) {{{1
    1              0.000003 function! s:Bookmark.activate(nerdtree, ...)
                                call self.open(a:nerdtree, a:0 ? a:1 : {})
                            endfunction
                            
                            " FUNCTION: Bookmark.AddBookmark(name, path) {{{1
                            " Class method to add a new bookmark to the list, if a previous bookmark exists
                            " with the same name, just update the path for that bookmark
    1              0.000001 function! s:Bookmark.AddBookmark(name, path)
                                for i in s:Bookmark.Bookmarks()
                                    if i.name ==# a:name
                                        let i.path = a:path
                                        return
                                    endif
                                endfor
                                call add(s:Bookmark.Bookmarks(), s:Bookmark.New(a:name, a:path))
                            endfunction
                            
                            " FUNCTION: Bookmark.Bookmarks() {{{1
                            " Class method to get all bookmarks. Lazily initializes the bookmarks global
                            " variable
    1              0.000001 function! s:Bookmark.Bookmarks()
                                if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
                                return g:NERDTreeBookmarks
                            endfunction
                            
                            " FUNCTION: Bookmark.BookmarkExistsFor(name) {{{1
                            " class method that returns 1 if a bookmark with the given name is found, 0
                            " otherwise
    1              0.000001 function! s:Bookmark.BookmarkExistsFor(name)
                                try
                                    call s:Bookmark.BookmarkFor(a:name)
                                    return 1
                                catch /^NERDTree.BookmarkNotFoundError/
                                    return 0
                                endtry
                            endfunction
                            
                            " FUNCTION: Bookmark.BookmarkFor(name) {{{1
                            " Class method that returns the Bookmark object having the specified name.
                            " Throws "NERDTree.BookmarkNotFoundError" if no Bookmark is found.
    1              0.000001 function! s:Bookmark.BookmarkFor(name)
                                let l:result = {}
                                for l:bookmark in s:Bookmark.Bookmarks()
                                    if l:bookmark.name ==# a:name
                                        let l:result = l:bookmark
                                        break
                                    endif
                                endfor
                                if empty(l:result)
                                    throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
                                endif
                                return l:result
                            endfunction
                            
                            " FUNCTION: Bookmark.BookmarkNames() {{{1
                            " Class method to return an array of all bookmark names
    1              0.000001 function! s:Bookmark.BookmarkNames()
                                let names = []
                                for i in s:Bookmark.Bookmarks()
                                    call add(names, i.name)
                                endfor
                                return names
                            endfunction
                            
                            " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
                            " Class method to read all bookmarks from the bookmarks file initialize
                            " bookmark objects for each one.
                            "
                            " Args:
                            " silent - dont echo an error msg if invalid bookmarks are found
    1              0.000001 function! s:Bookmark.CacheBookmarks(silent)
                                if filereadable(g:NERDTreeBookmarksFile)
                                    let g:NERDTreeBookmarks = []
                                    let g:NERDTreeInvalidBookmarks = []
                                    let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
                                    let invalidBookmarksFound = 0
                                    for i in bookmarkStrings
                            
                                        "ignore blank lines
                                        if i != ''
                            
                                            let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
                                            let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
                                            let path = fnamemodify(path, ':p')
                            
                                            try
                                                let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
                                                call add(g:NERDTreeBookmarks, bookmark)
                                            catch /^NERDTree.InvalidArgumentsError/
                                                call add(g:NERDTreeInvalidBookmarks, i)
                                                let invalidBookmarksFound += 1
                                            endtry
                                        endif
                                    endfor
                                    if invalidBookmarksFound
                                        call s:Bookmark.Write()
                                        if !a:silent
                                            call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark) {{{1
                            " Class method that indicates the relative position of two bookmarks when
                            " placed in alphabetical order by name. Case-sensitivity is determined by an
                            " option. Supports the "s:Bookmark.SortBookmarksList()" method.
    1              0.000001 function! s:Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark)
                                let l:result = 0
                                if g:NERDTreeBookmarksSort == 1
                                    if a:firstBookmark.name <? a:secondBookmark.name
                                        let l:result = -1
                                    elseif a:firstBookmark.name >? a:secondBookmark.name
                                        let l:result = 1
                                    endif
                                elseif g:NERDTreeBookmarksSort == 2
                                    if a:firstBookmark.name <# a:secondBookmark.name
                                        let l:result = -1
                                    elseif a:firstBookmark.name ># a:secondBookmark.name
                                        let l:result = 1
                                    endif
                                endif
                                return l:result
                            endfunction
                            
                            " FUNCTION: Bookmark.ClearAll() {{{1
                            " Class method to delete all bookmarks.
    1              0.000001 function! s:Bookmark.ClearAll()
                                for i in s:Bookmark.Bookmarks()
                                    call i.delete()
                                endfor
                                call s:Bookmark.Write()
                            endfunction
                            
                            " FUNCTION: Bookmark.delete() {{{1
                            " Delete this bookmark. If the node for this bookmark is under the current
                            " root, then recache bookmarks for its Path object
    1              0.000001 function! s:Bookmark.delete()
                                call remove(s:Bookmark.Bookmarks(), index(s:Bookmark.Bookmarks(), self))
                                call s:Bookmark.Write()
                            endfunction
                            
                            " FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1
                            " Returns the tree node object associated with this Bookmark.
                            " Throws "NERDTree.BookmarkedNodeNotFoundError" if the node is not found.
                            "
                            " Args:
                            " searchFromAbsoluteRoot: boolean flag, search from the highest cached node
                            "   if true and from the current tree root if false
    1              0.000001 function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)
                                if a:searchFromAbsoluteRoot
                                    let l:searchRoot = a:nerdtree.root.AbsoluteTreeRoot()
                                else
                                    let l:searchRoot = a:nerdtree.root
                                endif
                                let l:targetNode = l:searchRoot.findNode(self.path)
                                if empty(l:targetNode)
                                    throw 'NERDTree.BookmarkedNodeNotFoundError: node for bookmark "' . self.name . '" not found'
                                endif
                                return l:targetNode
                            endfunction
                            
                            " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1
                            " Class method that returns the tree node object for the Bookmark with the
                            " given name. Throws "NERDTree.BookmarkNotFoundError" if a Bookmark with the
                            " name does not exist. Throws "NERDTree.BookmarkedNodeNotFoundError" if a
                            " tree node for the named Bookmark could not be found.
    1              0.000002 function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)
                                let l:bookmark = s:Bookmark.BookmarkFor(a:name)
                                return l:bookmark.getNode(a:nerdtree, a:searchFromAbsoluteRoot)
                            endfunction
                            
                            " FUNCTION: Bookmark.GetSelected() {{{1
                            " returns the Bookmark the cursor is over, or {}
    1              0.000001 function! s:Bookmark.GetSelected()
                                let line = getline(".")
                                let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
                                if name != line
                                    try
                                        return s:Bookmark.BookmarkFor(name)
                                    catch /^NERDTree.BookmarkNotFoundError/
                                        return {}
                                    endtry
                                endif
                                return {}
                            endfunction
                            
                            " FUNCTION: Bookmark.InvalidBookmarks() {{{1
                            " Class method to get all invalid bookmark strings read from the bookmarks
                            " file
    1              0.000003 function! s:Bookmark.InvalidBookmarks()
                                if !exists("g:NERDTreeInvalidBookmarks")
                                    let g:NERDTreeInvalidBookmarks = []
                                endif
                                return g:NERDTreeInvalidBookmarks
                            endfunction
                            
                            " FUNCTION: Bookmark.mustExist() {{{1
    1              0.000001 function! s:Bookmark.mustExist()
                                if !self.path.exists()
                                    call s:Bookmark.CacheBookmarks(1)
                                    throw "NERDTree.BookmarkPointsToInvalidLocationError: the bookmark \"".
                                        \ self.name ."\" points to a non existing location: \"". self.path.str()
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.New(name, path) {{{1
                            " Create a new bookmark object with the given name and path object
    1              0.000001 function! s:Bookmark.New(name, path)
                                if a:name =~# ' '
                                    throw "NERDTree.IllegalBookmarkNameError: illegal name:" . a:name
                                endif
                            
                                let newBookmark = copy(self)
                                let newBookmark.name = a:name
                                let newBookmark.path = a:path
                                return newBookmark
                            endfunction
                            
                            " FUNCTION: Bookmark.open(nerdtree, [options]) {{{1
                            "Args:
                            "
                            "nerdtree: the tree to load open the bookmark in
                            "
                            "A dictionary containing the following keys (all optional):
                            "  'where': Specifies whether the node should be opened in new split/tab or in
                            "           the previous window. Can be either 'v' (vertical split), 'h'
                            "           (horizontal split), 't' (new tab) or 'p' (previous window).
                            "  'reuse': if a window is displaying the file then jump the cursor there
                            "  'keepopen': dont close the tree window
                            "  'stay': open the file, but keep the cursor in the tree win
                            "
    1              0.000001 function! s:Bookmark.open(nerdtree, ...)
                                let opts = a:0 ? a:1 : {}
                            
                                if self.path.isDirectory && !has_key(opts, 'where')
                                    call self.toRoot(a:nerdtree)
                                else
                                    let opener = g:NERDTreeOpener.New(self.path, opts)
                                    call opener.open(self)
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.openInNewTab(options) {{{1
                            " Create a new bookmark object with the given name and path object
    1              0.000001 function! s:Bookmark.openInNewTab(options)
                                call nerdtree#deprecated('Bookmark.openInNewTab', 'is deprecated, use open() instead')
                                call self.open(a:options)
                            endfunction
                            
                            " FUNCTION: Bookmark.setPath(path) {{{1
                            " makes this bookmark point to the given path
    1              0.000001 function! s:Bookmark.setPath(path)
                                let self.path = a:path
                            endfunction
                            
                            " FUNCTION: Bookmark.SortBookmarksList() {{{1
                            " Class method that sorts the global list of bookmarks alphabetically by name.
                            " Note that case-sensitivity is determined by a user option.
    1              0.000001 function! s:Bookmark.SortBookmarksList()
                                call sort(s:Bookmark.Bookmarks(), s:Bookmark.CompareBookmarksByName, s:Bookmark)
                            endfunction
                            
                            " FUNCTION: Bookmark.str() {{{1
                            " Get the string that should be rendered in the view for this bookmark
    1              0.000001 function! s:Bookmark.str()
                                let pathStrMaxLen = winwidth(g:NERDTree.GetWinNum()) - 4 - strdisplaywidth(self.name)
                                if &nu
                                    let pathStrMaxLen = pathStrMaxLen - &numberwidth
                                endif
                            
                                let pathStr = self.path.str({'format': 'UI'})
                                if strdisplaywidth(pathStr) > pathStrMaxLen
                                    while strdisplaywidth(pathStr) > pathStrMaxLen && strchars(pathStr) > 0
                                        let pathStr = substitute(pathStr, '^.', '', '')
                                    endwhile
                                    let pathStr = '<' . pathStr
                                endif
                                return '>' . self.name . ' ' . pathStr
                            endfunction
                            
                            " FUNCTION: Bookmark.toRoot(nerdtree) {{{1
                            " Set the root of the given NERDTree to the node for this Bookmark. If a node
                            " for this Bookmark does not exist, a new one is initialized.
    1              0.000001 function! s:Bookmark.toRoot(nerdtree)
                                if self.validate()
                                    try
                                        let l:targetNode = self.getNode(a:nerdtree, 1)
                                        call l:targetNode.closeChildren()
                                    catch /^NERDTree.BookmarkedNodeNotFoundError/
                                        let l:targetNode = g:NERDTreeFileNode.New(s:Bookmark.BookmarkFor(self.name).path, a:nerdtree)
                                    endtry
                                    call a:nerdtree.changeRoot(l:targetNode)
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1
                            " Class method that makes the Bookmark with the given name the root of
                            " specified NERDTree.
    1              0.000001 function! s:Bookmark.ToRoot(name, nerdtree)
                                let l:bookmark = s:Bookmark.BookmarkFor(a:name)
                                call l:bookmark.toRoot(a:nerdtree)
                            endfunction
                            
                            " FUNCTION: Bookmark.validate() {{{1
    1              0.000001 function! s:Bookmark.validate()
                                if self.path.exists()
                                    return 1
                                else
                                    call s:Bookmark.CacheBookmarks(1)
                                    call nerdtree#echo(self.name . "now points to an invalid location. See :help NERDTreeInvalidBookmarks for info.")
                                    return 0
                                endif
                            endfunction
                            
                            " FUNCTION: Bookmark.Write() {{{1
                            " Class method to write all bookmarks to the bookmarks file
    1              0.000001 function! s:Bookmark.Write()
                                let bookmarkStrings = []
                                for i in s:Bookmark.Bookmarks()
                                    call add(bookmarkStrings, i.name . ' ' . fnamemodify(i.path.str(), ':~'))
                                endfor
                            
                                "add a blank line before the invalid ones
                                call add(bookmarkStrings, "")
                            
                                for j in s:Bookmark.InvalidBookmarks()
                                    call add(bookmarkStrings, j)
                                endfor
                                call writefile(bookmarkStrings, g:NERDTreeBookmarksFile)
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim
Sourced 1 time
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
                            " ============================================================================
                            " CLASS: TreeFileNode
                            "
                            " This class is the parent of the "TreeDirNode" class and is the "Component"
                            " part of the composite design pattern between the NERDTree node classes.
                            " ============================================================================
                            
                            
    1              0.000003 let s:TreeFileNode = {}
    1              0.000002 let g:NERDTreeFileNode = s:TreeFileNode
                            
                            " FUNCTION: TreeFileNode.activate(...) {{{1
    1              0.000001 function! s:TreeFileNode.activate(...)
                                call self.open(a:0 ? a:1 : {})
                            endfunction
                            
                            " FUNCTION: TreeFileNode.bookmark(name) {{{1
                            " bookmark this node with a:name
    1              0.000001 function! s:TreeFileNode.bookmark(name)
                            
                                " if a bookmark exists with the same name and the node is cached then save
                                " it so we can update its display string
                                let oldMarkedNode = {}
                                try
                                    let oldMarkedNode = g:NERDTreeBookmark.GetNodeForName(a:name, 1, self.getNerdtree())
                                catch /^NERDTree.BookmarkNotFoundError/
                                catch /^NERDTree.BookmarkedNodeNotFoundError/
                                endtry
                            
                                call g:NERDTreeBookmark.AddBookmark(a:name, self.path)
                                call self.path.cacheDisplayString()
                                call g:NERDTreeBookmark.Write()
                            
                                if !empty(oldMarkedNode)
                                    call oldMarkedNode.path.cacheDisplayString()
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.cacheParent() {{{1
                            " initializes self.parent if it isnt already
    1              0.000001 function! s:TreeFileNode.cacheParent()
                                if empty(self.parent)
                                    let parentPath = self.path.getParent()
                                    if parentPath.equals(self.path)
                                        throw "NERDTree.CannotCacheParentError: already at root"
                                    endif
                                    let self.parent = s:TreeFileNode.New(parentPath, self.getNerdtree())
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.clearBookmarks() {{{1
    1              0.000001 function! s:TreeFileNode.clearBookmarks()
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        call i.delete()
                                    end
                                endfor
                                call self.path.cacheDisplayString()
                            endfunction
                            
                            " FUNCTION: TreeFileNode.copy(dest) {{{1
    1              0.000001 function! s:TreeFileNode.copy(dest)
                                call self.path.copy(a:dest)
                                let newPath = g:NERDTreePath.New(a:dest)
                                let parent = self.getNerdtree().root.findNode(newPath.getParent())
                                if !empty(parent)
                                    call parent.refresh()
                                    return parent.findNode(newPath)
                                else
                                    return {}
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.delete {{{1
                            " Removes this node from the tree and calls the Delete method for its path obj
    1              0.000001 function! s:TreeFileNode.delete()
                                call self.path.delete()
                                call self.parent.removeChild(self)
                            endfunction
                            
                            " FUNCTION: TreeFileNode.displayString() {{{1
                            "
                            " Returns a string that specifies how the node should be represented as a
                            " string
                            "
                            " Return:
                            " a string that can be used in the view to represent this node
    1              0.000001 function! s:TreeFileNode.displayString()
                                return self.path.flagSet.renderToString() . self.path.displayString()
                            endfunction
                            
                            " FUNCTION: TreeFileNode.equals(treenode) {{{1
                            "
                            " Compares this treenode to the input treenode and returns 1 if they are the
                            " same node.
                            "
                            " Use this method instead of ==  because sometimes when the treenodes contain
                            " many children, vim seg faults when doing ==
                            "
                            " Args:
                            " treenode: the other treenode to compare to
    1              0.000001 function! s:TreeFileNode.equals(treenode)
                                return self.path.str() ==# a:treenode.path.str()
                            endfunction
                            
                            " FUNCTION: TreeFileNode.findNode(path) {{{1
                            " Returns self if this node.path.Equals the given path.
                            " Returns {} if not equal.
                            "
                            " Args:
                            " path: the path object to compare against
    1              0.000001 function! s:TreeFileNode.findNode(path)
                                if a:path.equals(self.path)
                                    return self
                                endif
                                return {}
                            endfunction
                            
                            " FUNCTION: TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction) {{{1
                            "
                            " Finds the next sibling for this node in the indicated direction. This sibling
                            " must be a directory and may/may not have children as specified.
                            "
                            " Args:
                            " direction: 0 if you want to find the previous sibling, 1 for the next sibling
                            "
                            " Return:
                            " a treenode object or {} if no appropriate sibling could be found
    1              0.000001 function! s:TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction)
                                " if we have no parent then we can have no siblings
                                if self.parent != {}
                                    let nextSibling = self.findSibling(a:direction)
                            
                                    while nextSibling != {}
                                        if nextSibling.path.isDirectory && nextSibling.hasVisibleChildren() && nextSibling.isOpen
                                            return nextSibling
                                        endif
                                        let nextSibling = nextSibling.findSibling(a:direction)
                                    endwhile
                                endif
                            
                                return {}
                            endfunction
                            
                            " FUNCTION: TreeFileNode.findSibling(direction) {{{1
                            "
                            " Finds the next sibling for this node in the indicated direction
                            "
                            " Args:
                            " direction: 0 if you want to find the previous sibling, 1 for the next sibling
                            "
                            " Return:
                            " a treenode object or {} if no sibling could be found
    1              0.000001 function! s:TreeFileNode.findSibling(direction)
                                " if we have no parent then we can have no siblings
                                if self.parent != {}
                            
                                    " get the index of this node in its parents children
                                    let siblingIndx = self.parent.getChildIndex(self.path)
                            
                                    if siblingIndx != -1
                                        " move a long to the next potential sibling node
                                        let siblingIndx = a:direction ==# 1 ? siblingIndx+1 : siblingIndx-1
                            
                                        " keep moving along to the next sibling till we find one that is valid
                                        let numSiblings = self.parent.getChildCount()
                                        while siblingIndx >= 0 && siblingIndx < numSiblings
                            
                                            " if the next node is not an ignored node (i.e. wont show up in the
                                            " view) then return it
                                            if self.parent.children[siblingIndx].path.ignore(self.getNerdtree()) ==# 0
                                                return self.parent.children[siblingIndx]
                                            endif
                            
                                            " go to next node
                                            let siblingIndx = a:direction ==# 1 ? siblingIndx+1 : siblingIndx-1
                                        endwhile
                                    endif
                                endif
                            
                                return {}
                            endfunction
                            
                            " FUNCTION: TreeFileNode.getNerdtree(){{{1
    1              0.000001 function! s:TreeFileNode.getNerdtree()
                                return self._nerdtree
                            endfunction
                            
                            " FUNCTION: TreeFileNode.GetRootForTab(){{{1
                            " get the root node for this tab
    1              0.000001 function! s:TreeFileNode.GetRootForTab()
                                if g:NERDTree.ExistsForTab()
                                    return getbufvar(t:NERDTreeBufName, 'NERDTree').root
                                end
                                return {}
                            endfunction
                            
                            " FUNCTION: TreeFileNode.GetSelected() {{{1
                            " If the cursor is currently positioned on a tree node, return the node.
                            " Otherwise, return the empty dictionary.
    1              0.000001 function! s:TreeFileNode.GetSelected()
                            
                                try
                                    let l:path = b:NERDTree.ui.getPath(line('.'))
                            
                                    if empty(l:path)
                                        return {}
                                    endif
                            
                                    return b:NERDTree.root.findNode(l:path)
                                catch /^NERDTree/
                                    return {}
                                endtry
                            endfunction
                            
                            " FUNCTION: TreeFileNode.isVisible() {{{1
                            " returns 1 if this node should be visible according to the tree filters and
                            " hidden file filters (and their on/off status)
    1              0.000001 function! s:TreeFileNode.isVisible()
                                return !self.path.ignore(self.getNerdtree())
                            endfunction
                            
                            " FUNCTION: TreeFileNode.isRoot() {{{1
    1              0.000001 function! s:TreeFileNode.isRoot()
                                if !g:NERDTree.ExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
                                endif
                            
                                return self.equals(self.getNerdtree().root)
                            endfunction
                            
                            " FUNCTION: TreeFileNode.New(path, nerdtree) {{{1
                            " Returns a new TreeNode object with the given path and parent
                            "
                            " Args:
                            " path: file/dir that the node represents
                            " nerdtree: the tree the node belongs to
    1              0.000001 function! s:TreeFileNode.New(path, nerdtree)
                                if a:path.isDirectory
                                    return g:NERDTreeDirNode.New(a:path, a:nerdtree)
                                else
                                    let newTreeNode = copy(self)
                                    let newTreeNode.path = a:path
                                    let newTreeNode.parent = {}
                                    let newTreeNode._nerdtree = a:nerdtree
                                    return newTreeNode
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.open() {{{1
    1              0.000001 function! s:TreeFileNode.open(...)
                                let opts = a:0 ? a:1 : {}
                                let opener = g:NERDTreeOpener.New(self.path, opts)
                                call opener.open(self)
                            endfunction
                            
                            " FUNCTION: TreeFileNode.openSplit() {{{1
                            " Open this node in a new window
    1              0.000001 function! s:TreeFileNode.openSplit()
                                call nerdtree#deprecated('TreeFileNode.openSplit', 'is deprecated, use .open() instead.')
                                call self.open({'where': 'h'})
                            endfunction
                            
                            " FUNCTION: TreeFileNode.openVSplit() {{{1
                            " Open this node in a new vertical window
    1              0.000001 function! s:TreeFileNode.openVSplit()
                                call nerdtree#deprecated('TreeFileNode.openVSplit', 'is deprecated, use .open() instead.')
                                call self.open({'where': 'v'})
                            endfunction
                            
                            " FUNCTION: TreeFileNode.openInNewTab(options) {{{1
    1              0.000001 function! s:TreeFileNode.openInNewTab(options)
                                echomsg 'TreeFileNode.openInNewTab is deprecated'
                                call self.open(extend({'where': 't'}, a:options))
                            endfunction
                            
                            " FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1
                            " Places the cursor on the line number this node is rendered on
                            "
                            " Args:
                            " isJump: 1 if this cursor movement should be counted as a jump by vim
                            " recurseUpward: try to put the cursor on the parent if the this node isnt
                            " visible
    1              0.000001 function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)
                                let ln = self.getNerdtree().ui.getLineNum(self)
                                if ln != -1
                                    if a:isJump
                                        mark '
                                    endif
                                    call cursor(ln, col("."))
                                else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.refresh() {{{1
    1              0.000001 function! s:TreeFileNode.refresh()
                                call self.path.refresh(self.getNerdtree())
                            endfunction
                            
                            " FUNCTION: TreeFileNode.refreshFlags() {{{1
    1              0.000001 function! s:TreeFileNode.refreshFlags()
                                call self.path.refreshFlags(self.getNerdtree())
                            endfunction
                            
                            " FUNCTION: TreeFileNode.rename() {{{1
                            " Calls the rename method for this nodes path obj
    1              0.000001 function! s:TreeFileNode.rename(newName)
                                let newName = substitute(a:newName, '\(\\\|\/\)$', '', '')
                                call self.path.rename(newName)
                                call self.parent.removeChild(self)
                            
                                let parentPath = self.path.getParent()
                                let newParent = self.getNerdtree().root.findNode(parentPath)
                            
                                if newParent != {}
                                    call newParent.createChild(self.path, 1)
                                    call newParent.refresh()
                                endif
                            endfunction
                            
                            " FUNCTION: TreeFileNode.renderToString {{{1
                            " returns a string representation for this tree to be rendered in the view
    1              0.000001 function! s:TreeFileNode.renderToString()
                                return self._renderToString(0, 0)
                            endfunction
                            
                            " Args:
                            " depth: the current depth in the tree for this call
                            " drawText: 1 if we should actually draw the line for this node (if 0 then the
                            " child nodes are rendered only)
                            " for each depth in the tree
    1              0.000001 function! s:TreeFileNode._renderToString(depth, drawText)
                                let output = ""
                                if a:drawText ==# 1
                            
                                    let treeParts = repeat('  ', a:depth - 1)
                            
                                    if !self.path.isDirectory
                                        let treeParts = treeParts . '  '
                                    endif
                            
                                    let line = treeParts . self.displayString()
                            
                                    let output = output . line . "\n"
                                endif
                            
                                " if the node is an open dir, draw its children
                                if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
                                    let childNodesToDraw = self.getVisibleChildren()
                            
                                    if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
                                        for i in childNodesToDraw
                                            let output = output . i._renderToString(a:depth + 1, 1)
                                        endfor
                                    endif
                                endif
                            
                                return output
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim
Sourced 1 time
Total time:   0.000436
 Self time:   0.000436

count  total (s)   self (s)
                            " ============================================================================
                            " CLASS: TreeDirNode
                            "
                            " A subclass of NERDTreeFileNode.
                            "
                            " The 'composite' part of the file/dir composite.
                            " ============================================================================
                            
                            
    1              0.000012 let s:TreeDirNode = copy(g:NERDTreeFileNode)
    1              0.000002 let g:NERDTreeDirNode = s:TreeDirNode
                            
                            " FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
                            " Class method that returns the highest cached ancestor of the current root.
    1              0.000001 function! s:TreeDirNode.AbsoluteTreeRoot()
                                let currentNode = b:NERDTree.root
                                while currentNode.parent != {}
                                    let currentNode = currentNode.parent
                                endwhile
                                return currentNode
                            endfunction
                            
                            " FUNCTION: TreeDirNode.activate([options]) {{{1
    1              0.000001 function! s:TreeDirNode.activate(...)
                                let l:options = (a:0 > 0) ? a:1 : {}
                            
                                call self.toggleOpen(l:options)
                            
                                " Note that we only re-render the NERDTree for this node if we did NOT
                                " create a new node and render it in a new window or tab.  In the latter
                                " case, rendering the NERDTree for this node could overwrite the text of
                                " the new NERDTree!
                                if !has_key(l:options, 'where') || empty(l:options['where'])
                                    call self.getNerdtree().render()
                                    call self.putCursorHere(0, 0)
                                endif
                            endfunction
                            
                            " FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
                            " Adds the given treenode to the list of children for this node
                            "
                            " Args:
                            " -treenode: the node to add
                            " -inOrder: 1 if the new node should be inserted in sorted order
    1              0.000001 function! s:TreeDirNode.addChild(treenode, inOrder)
                                call add(self.children, a:treenode)
                                let a:treenode.parent = self
                            
                                if a:inOrder
                                    call self.sortChildren()
                                endif
                            endfunction
                            
                            " FUNCTION: TreeDirNode.close() {{{1
                            " Mark this TreeDirNode as closed.
    1              0.000001 function! s:TreeDirNode.close()
                            
                                " Close all directories in this directory node's cascade. This is
                                " necessary to ensure consistency when cascades are rendered.
                                for l:dirNode in self.getCascade()
                                    let l:dirNode.isOpen = 0
                                endfor
                            endfunction
                            
                            " FUNCTION: TreeDirNode.closeChildren() {{{1
                            " Recursively close any directory nodes that are descendants of this node.
    1              0.000001 function! s:TreeDirNode.closeChildren()
                                for l:child in self.children
                                    if l:child.path.isDirectory
                                        call l:child.close()
                                        call l:child.closeChildren()
                                    endif
                                endfor
                            endfunction
                            
                            " FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
                            " Instantiates a new child node for this node with the given path. The new
                            " nodes parent is set to this node.
                            "
                            " Args:
                            " path: a Path object that this node will represent/contain
                            " inOrder: 1 if the new node should be inserted in sorted order
                            "
                            " Returns:
                            " the newly created node
    1              0.000001 function! s:TreeDirNode.createChild(path, inOrder)
                                let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
                                call self.addChild(newTreeNode, a:inOrder)
                                return newTreeNode
                            endfunction
                            
                            " FUNCTION: TreeDirNode.displayString() {{{1
                            " Assemble and return a string that can represent this TreeDirNode object in
                            " the NERDTree window.
    1              0.000001 function! s:TreeDirNode.displayString()
                                let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
                                let l:label = ''
                                let l:cascade = self.getCascade()
                                for l:dirNode in l:cascade
                                    let l:label .= l:dirNode.path.displayString()
                                endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
                                if l:cascade[-1].isOpen
                                    let l:symbol = g:NERDTreeDirArrowCollapsible
                                else
                                    let l:symbol = g:NERDTreeDirArrowExpandable
                                endif
                            
                                let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
                                let l:result = l:symbol . ' ' . l:flags . l:label
                                return l:result
                            endfunction
                            
                            " FUNCTION: TreeDirNode.findNode(path) {{{1
                            " Will find one of the children (recursively) that has the given path
                            "
                            " Args:
                            " path: a path object
    1              0.000002 unlet s:TreeDirNode.findNode
    1              0.000001 function! s:TreeDirNode.findNode(path)
                                if a:path.equals(self.path)
                                    return self
                                endif
                                if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return {}
                                endif
                            
                                if self.path.isDirectory
                                    for i in self.children
                                        let retVal = i.findNode(a:path)
                                        if retVal != {}
                                            return retVal
                                        endif
                                    endfor
                                endif
                                return {}
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getCascade() {{{1
                            " Return an array of dir nodes (starting from self) that can be cascade opened.
    1              0.000001 function! s:TreeDirNode.getCascade()
                                if !self.isCascadable()
                                    return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getChildCount() {{{1
                            " Returns the number of children this node has
    1              0.000001 function! s:TreeDirNode.getChildCount()
                                return len(self.children)
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getChild(path) {{{1
                            " Returns child node of this node that has the given path or {} if no such node
                            " exists.
                            "
                            " This function doesnt not recurse into child dir nodes
                            "
                            " Args:
                            " path: a path object
    1              0.000001 function! s:TreeDirNode.getChild(path)
                                if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return {}
                                endif
                            
                                let index = self.getChildIndex(a:path)
                                if index ==# -1
                                    return {}
                                else
                                    return self.children[index]
                                endif
                            
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
                            " returns the child at the given index
                            "
                            " Args:
                            " indx: the index to get the child from
                            " visible: 1 if only the visible children array should be used, 0 if all the
                            " children should be searched.
    1              0.000001 function! s:TreeDirNode.getChildByIndex(indx, visible)
                                let array_to_search = a:visible? self.getVisibleChildren() : self.children
                                if a:indx > len(array_to_search)
                                    throw "NERDTree.InvalidArgumentsError: Index is out of bounds."
                                endif
                                return array_to_search[a:indx]
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getChildIndex(path) {{{1
                            " Returns the index of the child node of this node that has the given path or
                            " -1 if no such node exists.
                            "
                            " This function doesnt not recurse into child dir nodes
                            "
                            " Args:
                            " path: a path object
    1              0.000001 function! s:TreeDirNode.getChildIndex(path)
                                if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return -1
                                endif
                            
                                "do a binary search for the child
                                let a = 0
                                let z = self.getChildCount()
                                while a < z
                                    let mid = (a+z)/2
                                    let diff = a:path.compareTo(self.children[mid].path)
                            
                                    if diff ==# -1
                                        let z = mid
                                    elseif diff ==# 1
                                        let a = mid+1
                                    else
                                        return mid
                                    endif
                                endwhile
                                return -1
                            endfunction
                            
                            " FUNCTION: TreeDirNode._glob(pattern, all) {{{1
                            " Return a list of strings naming the descendants of the directory in this
                            " TreeDirNode object that match the specified glob pattern.
                            "
                            " Args:
                            " pattern: (string) the glob pattern to apply
                            " all: (0 or 1) if 1, include "." and ".." if they match "pattern"; if 0,
                            "      always exclude them
                            "
                            " Note: If the pathnames in the result list are below the working directory,
                            " they are returned as pathnames relative to that directory. This is because
                            " this function, internally, attempts to obey 'wildignore' rules that use
                            " relative paths.
    1              0.000002 function! s:TreeDirNode._glob(pattern, all)
                            
                                " Construct a path specification such that "globpath()" will return
                                " relative pathnames, if possible.
                                if self.path.str() == getcwd()
                                    let l:pathSpec = ','
                                else
                                    let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
                            
                                    " On Windows, the drive letter may be removed by "fnamemodify()".
                                    if nerdtree#runningWindows() && l:pathSpec[0] == g:NERDTreePath.Slash()
                                        let l:pathSpec = self.path.drive . l:pathSpec
                                    endif
                                endif
                            
                                let l:globList = []
                            
                                " See ":h version7.txt" and ":h version8.txt" for details on the
                                " development of the "glob()" and "globpath()" functions.
                                if v:version > 704 || (v:version == 704 && has('patch654'))
                                    let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
                                elseif v:version == 704 && has('patch279')
                                    let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
                                elseif v:version > 702 || (v:version == 702 && has('patch051'))
                                    let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
                                    let l:globList = split(l:globString, "\n")
                                else
                                    let l:globString = globpath(l:pathSpec, a:pattern)
                                    let l:globList = split(l:globString, "\n")
                                endif
                            
                                " If "a:all" is false, filter "." and ".." from the output.
                                if !a:all
                                    let l:toRemove = []
                            
                                    for l:file in l:globList
                                        let l:tail = fnamemodify(l:file, ':t')
                            
                                        " Double the modifier if only a separator was stripped.
                                        if l:tail == ''
                                            let l:tail = fnamemodify(l:file, ':t:t')
                                        endif
                            
                                        if l:tail == '.' || l:tail == '..'
                                            call add(l:toRemove, l:file)
                                            if len(l:toRemove) == 2
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    for l:file in l:toRemove
                                        call remove(l:globList, index(l:globList, l:file))
                                    endfor
                                endif
                            
                                return l:globList
                            endfunction
                            
                            " FUNCTION: TreeDirNode.GetSelected() {{{1
                            " Returns the current node if it is a dir node, or else returns the current
                            " nodes parent
    1              0.000001 unlet s:TreeDirNode.GetSelected
    1              0.000003 function! s:TreeDirNode.GetSelected()
                                let currentDir = g:NERDTreeFileNode.GetSelected()
                                if currentDir != {} && !currentDir.isRoot()
                                    if currentDir.path.isDirectory ==# 0
                                        let currentDir = currentDir.parent
                                    endif
                                endif
                                return currentDir
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
                            " Returns the number of visible children this node has
    1              0.000001 function! s:TreeDirNode.getVisibleChildCount()
                                return len(self.getVisibleChildren())
                            endfunction
                            
                            " FUNCTION: TreeDirNode.getVisibleChildren() {{{1
                            " Returns a list of children to display for this node, in the correct order
                            "
                            " Return:
                            " an array of treenodes
    1              0.000001 function! s:TreeDirNode.getVisibleChildren()
                                let toReturn = []
                                for i in self.children
                                    if i.path.ignore(self.getNerdtree()) ==# 0
                                        call add(toReturn, i)
                                    endif
                                endfor
                                return toReturn
                            endfunction
                            
                            " FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
                            " returns 1 if this node has any childre, 0 otherwise..
    1              0.000001 function! s:TreeDirNode.hasVisibleChildren()
                                return self.getVisibleChildCount() != 0
                            endfunction
                            
                            " FUNCTION: TreeDirNode.isCascadable() {{{1
                            " true if this dir has only one visible child - which is also a dir
    1              0.000001 function! s:TreeDirNode.isCascadable()
                                if g:NERDTreeCascadeSingleChildDir == 0
                                    return 0
                                endif
                            
                                let c = self.getVisibleChildren()
                                return len(c) == 1 && c[0].path.isDirectory
                            endfunction
                            
                            " FUNCTION: TreeDirNode._initChildren() {{{1
                            " Removes all childen from this node and re-reads them
                            "
                            " Args:
                            " silent: 1 if the function should not echo any "please wait" messages for
                            " large directories
                            "
                            " Return: the number of child nodes read
    1              0.000001 function! s:TreeDirNode._initChildren(silent)
                                "remove all the current child nodes
                                let self.children = []
                            
                                let files = self._glob('*', 1) + self._glob('.*', 0)
                            
                                if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ...")
                                endif
                            
                                let invalidFilesFound = 0
                                for i in files
                                    try
                                        let path = g:NERDTreePath.New(i)
                                        call self.createChild(path, 0)
                                        call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
                                    catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                        let invalidFilesFound += 1
                                    endtry
                                endfor
                            
                                call self.sortChildren()
                            
                                if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
                                endif
                            
                                if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
                                endif
                                return self.getChildCount()
                            endfunction
                            
                            " FUNCTION: TreeDirNode.New(path, nerdtree) {{{1
                            " Return a new TreeDirNode object with the given path and parent.
                            "
                            " Args:
                            " path: dir that the node represents
                            " nerdtree: the tree the node belongs to
    1              0.000001 function! s:TreeDirNode.New(path, nerdtree)
                                if a:path.isDirectory != 1
                                    throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
                                endif
                            
                                let newTreeNode = copy(self)
                                let newTreeNode.path = a:path
                            
                                let newTreeNode.isOpen = 0
                                let newTreeNode.children = []
                            
                                let newTreeNode.parent = {}
                                let newTreeNode._nerdtree = a:nerdtree
                            
                                return newTreeNode
                            endfunction
                            
                            " FUNCTION: TreeDirNode.open([options]) {{{1
                            " Open this directory node in the current tree or elsewhere if special options
                            " are provided. Return 0 if options were processed. Otherwise, return the
                            " number of new cached nodes.
    1              0.000001 function! s:TreeDirNode.open(...)
                                let l:options = a:0 ? a:1 : {}
                            
                                " If special options were specified, process them and return.
                                if has_key(l:options, 'where') && !empty(l:options['where'])
                                    let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                    call l:opener.open(self)
                                    return 0
                                endif
                            
                                " Open any ancestors of this node that render within the same cascade.
                                let l:parent = self.parent
                                while !empty(l:parent) && !l:parent.isRoot()
                                    if index(l:parent.getCascade(), self) >= 0
                                        let l:parent.isOpen = 1
                                        let l:parent = l:parent.parent
                                    else
                                        break
                                    endif
                                endwhile
                            
                                let self.isOpen = 1
                            
                                let l:numChildrenCached = 0
                                if empty(self.children)
                                    let l:numChildrenCached = self._initChildren(0)
                                endif
                            
                                return l:numChildrenCached
                            endfunction
                            
                            " FUNCTION: TreeDirNode.openAlong([opts]) {{{1
                            " recursive open the dir if it has only one directory child.
                            "
                            " return the level of opened directories.
    1              0.000001 function! s:TreeDirNode.openAlong(...)
                                let opts = a:0 ? a:1 : {}
                                let level = 0
                            
                                let node = self
                                while node.path.isDirectory
                                    call node.open(opts)
                                    let level += 1
                                    if node.getVisibleChildCount() == 1
                                        let node = node.getChildByIndex(0, 1)
                                    else
                                        break
                                    endif
                                endwhile
                                return level
                            endfunction
                            
                            " FUNCTION: TreeDirNode.openExplorer() {{{1
                            " Open an explorer window for this node in the previous window. The explorer
                            " can be a NERDTree window or a netrw window.
    1              0.000001 function! s:TreeDirNode.openExplorer()
                                call self.open({'where': 'p'})
                            endfunction
                            
                            " FUNCTION: TreeDirNode.openInNewTab(options) {{{1
    1              0.000002 unlet s:TreeDirNode.openInNewTab
    1              0.000001 function! s:TreeDirNode.openInNewTab(options)
                                call nerdtree#deprecated('TreeDirNode.openInNewTab', 'is deprecated, use open() instead')
                                call self.open({'where': 't'})
                            endfunction
                            
                            " FUNCTION: TreeDirNode._openInNewTab() {{{1
    1              0.000001 function! s:TreeDirNode._openInNewTab()
                                tabnew
                                call g:NERDTreeCreator.CreateTabTree(self.path.str())
                            endfunction
                            
                            " FUNCTION: TreeDirNode.openRecursively() {{{1
                            " Open this directory node and any descendant directory nodes whose pathnames
                            " are not ignored.
    1              0.000001 function! s:TreeDirNode.openRecursively()
                                silent call self.open()
                            
                                for l:child in self.children
                                    if l:child.path.isDirectory && !l:child.path.ignore(l:child.getNerdtree())
                                        call l:child.openRecursively()
                                    endif
                                endfor
                            endfunction
                            
                            " FUNCTION: TreeDirNode.refresh() {{{1
    1              0.000001 function! s:TreeDirNode.refresh()
                                call self.path.refresh(self.getNerdtree())
                            
                                "if this node was ever opened, refresh its children
                                if self.isOpen || !empty(self.children)
                                    let files = self._glob('*', 1) + self._glob('.*', 0)
                                    let newChildNodes = []
                                    let invalidFilesFound = 0
                                    for i in files
                                        try
                                            "create a new path and see if it exists in this nodes children
                                            let path = g:NERDTreePath.New(i)
                                            let newNode = self.getChild(path)
                                            if newNode != {}
                                                call newNode.refresh()
                                                call add(newChildNodes, newNode)
                            
                                            "the node doesnt exist so create it
                                            else
                                                let newNode = g:NERDTreeFileNode.New(path, self.getNerdtree())
                                                let newNode.parent = self
                                                call add(newChildNodes, newNode)
                                            endif
                                        catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                            let invalidFilesFound = 1
                                        endtry
                                    endfor
                            
                                    "swap this nodes children out for the children we just read/refreshed
                                    let self.children = newChildNodes
                                    call self.sortChildren()
                            
                                    if invalidFilesFound
                                        call nerdtree#echoWarning("some files could not be loaded into the NERD tree")
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: TreeDirNode.refreshFlags() {{{1
    1              0.000002 unlet s:TreeDirNode.refreshFlags
    1              0.000001 function! s:TreeDirNode.refreshFlags()
                                call self.path.refreshFlags(self.getNerdtree())
                                for i in self.children
                                    call i.refreshFlags()
                                endfor
                            endfunction
                            
                            " FUNCTION: TreeDirNode.refreshDirFlags() {{{1
    1              0.000001 function! s:TreeDirNode.refreshDirFlags()
                                call self.path.refreshFlags(self.getNerdtree())
                            endfunction
                            
                            " FUNCTION: TreeDirNode.reveal(path) {{{1
                            " reveal the given path, i.e. cache and open all treenodes needed to display it
                            " in the UI
                            " Returns the revealed node
    1              0.000001 function! s:TreeDirNode.reveal(path, ...)
                                let opts = a:0 ? a:1 : {}
                            
                                if !a:path.isUnder(self.path)
                                    throw "NERDTree.InvalidArgumentsError: " . a:path.str() . " should be under " . self.path.str()
                                endif
                            
                                call self.open()
                            
                                if self.path.equals(a:path.getParent())
                                    let n = self.findNode(a:path)
                                    if has_key(opts, "open")
                                        call n.open()
                                    endif
                                    return n
                                endif
                            
                                let p = a:path
                                while !p.getParent().equals(self.path)
                                    let p = p.getParent()
                                endwhile
                            
                                let n = self.findNode(p)
                                return n.reveal(a:path, opts)
                            endfunction
                            
                            " FUNCTION: TreeDirNode.removeChild(treenode) {{{1
                            " Remove the given treenode from "self.children".
                            " Throws "NERDTree.ChildNotFoundError" if the node is not found.
                            "
                            " Args:
                            " treenode: the node object to remove
    1              0.000001 function! s:TreeDirNode.removeChild(treenode)
                                for i in range(0, self.getChildCount()-1)
                                    if self.children[i].equals(a:treenode)
                                        call remove(self.children, i)
                                        return
                                    endif
                                endfor
                            
                                throw "NERDTree.ChildNotFoundError: child node was not found"
                            endfunction
                            
                            " FUNCTION: TreeDirNode.sortChildren() {{{1
                            " Sort "self.children" by alphabetical order and directory priority.
    1              0.000001 function! s:TreeDirNode.sortChildren()
                                if count(g:NERDTreeSortOrder, '*') < 1
                                    call add(g:NERDTreeSortOrder, '*')
                                endif
                                let CompareFunc = function("nerdtree#compareNodesBySortKey")
                                call sort(self.children, CompareFunc)
                                let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
                            endfunction
                            
                            " FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
                            " Opens this directory if it is closed and vice versa
    1              0.000001 function! s:TreeDirNode.toggleOpen(...)
                                let opts = a:0 ? a:1 : {}
                                if self.isOpen ==# 1
                                    call self.close()
                                else
                                    if g:NERDTreeCascadeOpenSingleChildDir == 0
                                        call self.open(opts)
                                    else
                                        call self.openAlong(opts)
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
                            " Replaces the child of this with the given node (where the child node's full
                            " path matches a:newNode's fullpath). The search for the matching node is
                            " non-recursive
                            "
                            " Arg:
                            " newNode: the node to graft into the tree
    1              0.000001 function! s:TreeDirNode.transplantChild(newNode)
                                for i in range(0, self.getChildCount()-1)
                                    if self.children[i].equals(a:newNode)
                                        let self.children[i] = a:newNode
                                        let a:newNode.parent = self
                                        break
                                    endif
                                endfor
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/opener.vim
Sourced 1 time
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
                            " ============================================================================
                            " CLASS: Opener
                            "
                            " The Opener class defines an API for "opening" operations.
                            " ============================================================================
                            
                            
    1              0.000003 let s:Opener = {}
    1              0.000002 let g:NERDTreeOpener = s:Opener
                            
                            " FUNCTION: s:Opener._bufInWindows(bnum) {{{1
                            " [[STOLEN FROM VTREEEXPLORER.VIM]]
                            " Determine the number of windows open to this buffer number.
                            " Care of Yegappan Lakshman.  Thanks!
                            "
                            " Args:
                            " bnum: the subject buffers buffer number
    1              0.000002 function! s:Opener._bufInWindows(bnum)
                                let cnt = 0
                                let winnum = 1
                                while 1
                                    let bufnum = winbufnr(winnum)
                                    if bufnum < 0
                                        break
                                    endif
                                    if bufnum ==# a:bnum
                                        let cnt = cnt + 1
                                    endif
                                    let winnum = winnum + 1
                                endwhile
                            
                                return cnt
                            endfunction
                            
                            " FUNCTION: Opener._checkToCloseTree(newtab) {{{1
                            " Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
                            " if the tree should be closed now.
                            "
                            " Args:
                            " a:newtab - boolean. If set, only close the tree now if we are opening the
                            " target in a new tab. This is needed because we have to close tree before we
                            " leave the tab
    1              0.000001 function! s:Opener._checkToCloseTree(newtab)
                                if self._keepopen
                                    return
                                endif
                            
                                if (a:newtab && self._where == 't') || !a:newtab
                                    call g:NERDTree.CloseIfQuitOnOpen()
                                endif
                            endfunction
                            
                            " FUNCTION: s:Opener._firstUsableWindow() {{{1
                            " find the window number of the first normal window
    1              0.000001 function! s:Opener._firstUsableWindow()
                                let i = 1
                                while i <= winnr("$")
                                    let bnum = winbufnr(i)
                                    if bnum != -1 && getbufvar(bnum, '&buftype') ==# ''
                                                \ && !getwinvar(i, '&previewwindow')
                                                \ && (!getbufvar(bnum, '&modified') || &hidden)
                                        return i
                                    endif
                            
                                    let i += 1
                                endwhile
                                return -1
                            endfunction
                            
                            " FUNCTION: Opener._gotoTargetWin() {{{1
    1              0.000001 function! s:Opener._gotoTargetWin()
                                if b:NERDTree.isWinTree()
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
                                else
                                    call self._checkToCloseTree(1)
                            
                                    if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
                                        call self._previousWindow()
                                    endif
                            
                                    call self._checkToCloseTree(0)
                                endif
                            endfunction
                            
                            " FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1
                            " Returns 0 if opening a file from the tree in the given window requires it to
                            " be split, 1 otherwise
                            "
                            " Args:
                            " winnumber: the number of the window in question
    1              0.000001 function! s:Opener._isWindowUsable(winnumber)
                                "gotta split if theres only one window (i.e. the NERD tree)
                                if winnr("$") ==# 1
                                    return 0
                                endif
                            
                                let oldwinnr = winnr()
                                call nerdtree#exec(a:winnumber . "wincmd p")
                                let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
                                let modified = &modified
                                call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
                                if specialWindow
                                    return 0
                                endif
                            
                                if &hidden
                                    return 1
                                endif
                            
                                return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2
                            endfunction
                            
                            " FUNCTION: Opener.New(path, opts) {{{1
                            " Instantiate a new NERDTreeOpener object.
                            " Args:
                            " a:path: the path object that is to be opened
                            " a:opts: a dictionary containing the following optional keys...
                            "   'where': specifies whether the node should be opened in new split, in
                            "            a new tab or, in the last window; takes values "v", "h", or "t"
                            "   'reuse': if file is already shown in a window, jump there; takes values
                            "            "all", "currenttab", or empty
                            "   'keepopen': boolean (0 or 1); if true, the tree window will not be closed
                            "   'stay': boolean (0 or 1); if true, remain in tree window after opening
    1              0.000001 function! s:Opener.New(path, opts)
                                let l:newOpener = copy(self)
                            
                                let l:newOpener._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
                                let l:newOpener._nerdtree = b:NERDTree
                                let l:newOpener._path = a:path
                                let l:newOpener._reuse = has_key(a:opts, 'reuse') ? a:opts['reuse'] : ''
                                let l:newOpener._stay = nerdtree#has_opt(a:opts, 'stay')
                                let l:newOpener._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
                            
                                call l:newOpener._saveCursorPos()
                            
                                return l:newOpener
                            endfunction
                            
                            " FUNCTION: Opener._newSplit() {{{1
    1              0.000002 function! s:Opener._newSplit()
                                " Save the user's settings for splitbelow and splitright
                                let savesplitbelow=&splitbelow
                                let savesplitright=&splitright
                            
                                " 'there' will be set to a command to move from the split window
                                " back to the explorer window
                                "
                                " 'back' will be set to a command to move from the explorer window
                                " back to the newly split window
                                "
                                " 'right' and 'below' will be set to the settings needed for
                                " splitbelow and splitright IF the explorer is the only window.
                                "
                                let there= g:NERDTreeWinPos ==# "left" ? "wincmd h" : "wincmd l"
                                let back = g:NERDTreeWinPos ==# "left" ? "wincmd l" : "wincmd h"
                                let right= g:NERDTreeWinPos ==# "left"
                                let below=0
                            
                                " Attempt to go to adjacent window
                                call nerdtree#exec(back)
                            
                                let onlyOneWin = (winnr("$") ==# 1)
                            
                                " If no adjacent window, set splitright and splitbelow appropriately
                                if onlyOneWin
                                    let &splitright=right
                                    let &splitbelow=below
                                else
                                    " found adjacent window - invert split direction
                                    let &splitright=!right
                                    let &splitbelow=!below
                                endif
                            
                                let splitMode = onlyOneWin ? "vertical" : ""
                            
                                " Open the new window
                                try
                                    exec(splitMode." sp ")
                                catch /^Vim\%((\a\+)\)\=:E37/
                                    call g:NERDTree.CursorToTreeWin()
                                    throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                catch /^Vim\%((\a\+)\)\=:/
                                    "do nothing
                                endtry
                            
                                "resize the tree window if no other window was open before
                                if onlyOneWin
                                    let size = exists("b:NERDTreeOldWindowSize") ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
                                    call nerdtree#exec(there)
                                    exec("silent ". splitMode ." resize ". size)
                                    call nerdtree#exec('wincmd p')
                                endif
                            
                                " Restore splitmode settings
                                let &splitbelow=savesplitbelow
                                let &splitright=savesplitright
                            endfunction
                            
                            " FUNCTION: Opener._newVSplit() {{{1
    1              0.000001 function! s:Opener._newVSplit()
                                let l:winwidth = winwidth('.')
                            
                                if winnr('$') == 1
                                    let l:winwidth = g:NERDTreeWinSize
                                endif
                            
                                call nerdtree#exec('wincmd p')
                                vnew
                            
                                let l:currentWindowNumber = winnr()
                            
                                " Restore the NERDTree to its original width.
                                call g:NERDTree.CursorToTreeWin()
                                execute 'silent vertical resize ' . l:winwidth
                            
                                call nerdtree#exec(l:currentWindowNumber . 'wincmd w')
                            endfunction
                            
                            " FUNCTION: Opener.open(target) {{{1
    1              0.000001 function! s:Opener.open(target)
                                if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                    return
                                endif
                            
                                call self._openFile()
                            endfunction
                            
                            " FUNCTION: Opener._openFile() {{{1
    1              0.000001 function! s:Opener._openFile()
                            
                                if self._reuseWindow()
                                    return
                                endif
                            
                                call self._gotoTargetWin()
                            
                                if self._stay
                                    silent call self._path.edit()
                                    call self._restoreCursorPos()
                                    return
                                endif
                            
                                call self._path.edit()
                            endfunction
                            
                            " FUNCTION: Opener._openDirectory(node) {{{1
    1              0.000001 function! s:Opener._openDirectory(node)
                                call self._gotoTargetWin()
                            
                                if self._nerdtree.isWinTree()
                                    call g:NERDTreeCreator.CreateWindowTree(a:node.path.str())
                                else
                                    if empty(self._where)
                                        call b:NERDTree.changeRoot(a:node)
                                    elseif self._where == 't'
                                        call g:NERDTreeCreator.CreateTabTree(a:node.path.str())
                                    else
                                        call g:NERDTreeCreator.CreateWindowTree(a:node.path.str())
                                    endif
                                endif
                            
                                if self._stay
                                    call self._restoreCursorPos()
                                endif
                            endfunction
                            
                            " FUNCTION: Opener._previousWindow() {{{1
    1              0.000001 function! s:Opener._previousWindow()
                                if !self._isWindowUsable(winnr("#")) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
                                else
                                    try
                                        if !self._isWindowUsable(winnr("#"))
                                            call nerdtree#exec(self._firstUsableWindow() . "wincmd w")
                                        else
                                            call nerdtree#exec('wincmd p')
                                        endif
                                    catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
                                endif
                            endfunction
                            
                            " FUNCTION: Opener._restoreCursorPos() {{{1
    1              0.000001 function! s:Opener._restoreCursorPos()
                                call nerdtree#exec(self._tabnr . 'tabnext')
                                call nerdtree#exec(bufwinnr(self._bufnr) . 'wincmd w')
                            endfunction
                            
                            " FUNCTION: Opener._reuseWindow() {{{1
                            " put the cursor in the first window we find for this file
                            "
                            " return 1 if we were successful
    1              0.000001 function! s:Opener._reuseWindow()
                                if empty(self._reuse)
                                    return 0
                                endif
                            
                                "check the current tab for the window
                                let winnr = bufwinnr('^' . self._path.str() . '$')
                                if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                endif
                            
                                if self._reuse == 'currenttab'
                                    return 0
                                endif
                            
                                "check other tabs
                                let tabnr = self._path.tabnr()
                                if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec(tabnr . 'tabnext')
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . "wincmd w")
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " FUNCTION: Opener._saveCursorPos() {{{1
    1              0.000001 function! s:Opener._saveCursorPos()
                                let self._bufnr = bufnr("")
                                let self._tabnr = tabpagenr()
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/creator.vim
Sourced 1 time
Total time:   0.000261
 Self time:   0.000261

count  total (s)   self (s)
                            " ============================================================================
                            " CLASS: Creator
                            "
                            " This class is responsible for creating NERDTree instances.  The new NERDTree
                            " may be a tab tree, a window tree, or a mirrored tree.  In the process of
                            " creating a NERDTree, it sets up all of the window and buffer options and key
                            " mappings etc.
                            " ============================================================================
                            
                            
    1              0.000003 let s:Creator = {}
    1              0.000002 let g:NERDTreeCreator = s:Creator
                            
                            " FUNCTION: s:Creator._bindMappings() {{{1
    1              0.000001 function! s:Creator._bindMappings()
                                "make <cr> do the same as the activate node mapping
                                nnoremap <silent> <buffer> <cr> :call nerdtree#ui_glue#invokeKeyMap(g:NERDTreeMapActivateNode)<cr>
                            
                                call g:NERDTreeKeyMap.BindAll()
                            
                                command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
                                command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
                                command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
                                command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
                                command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
                            endfunction
                            
                            " FUNCTION: s:Creator._broadcastInitEvent() {{{1
    1              0.000001 function! s:Creator._broadcastInitEvent()
                                silent doautocmd User NERDTreeInit
                            endfunction
                            
                            " FUNCTION: s:Creator.BufNamePrefix() {{{2
    1              0.000001 function! s:Creator.BufNamePrefix()
                                return 'NERD_tree_'
                            endfunction
                            
                            " FUNCTION: s:Creator.CreateTabTree(a:name) {{{1
    1              0.000001 function! s:Creator.CreateTabTree(name)
                                let creator = s:Creator.New()
                                call creator.createTabTree(a:name)
                            endfunction
                            
                            " FUNCTION: s:Creator.createTabTree(a:name) {{{1
                            " name: the name of a bookmark or a directory
    1              0.000001 function! s:Creator.createTabTree(name)
                                let l:path = self._pathForString(a:name)
                            
                                " Abort if an exception was thrown (i.e., if the bookmark or directory
                                " does not exist).
                                if empty(l:path)
                                    return
                                endif
                            
                                " Obey the user's preferences for changing the working directory.
                                if g:NERDTreeChDirMode != 0
                                    call l:path.changeToDir()
                                endif
                            
                                if g:NERDTree.ExistsForTab()
                                    call g:NERDTree.Close()
                                    call self._removeTreeBufForTab()
                                endif
                            
                                call self._createTreeWin()
                                call self._createNERDTree(l:path, 'tab')
                                call b:NERDTree.render()
                                call b:NERDTree.root.putCursorHere(0, 0)
                            
                                call self._broadcastInitEvent()
                            endfunction
                            
                            " FUNCTION: s:Creator.CreateWindowTree(dir) {{{1
    1              0.000001 function! s:Creator.CreateWindowTree(dir)
                                let creator = s:Creator.New()
                                call creator.createWindowTree(a:dir)
                            endfunction
                            
                            " FUNCTION: s:Creator.createWindowTree(dir) {{{1
    1              0.000001 function! s:Creator.createWindowTree(dir)
                                try
                                    let path = g:NERDTreePath.New(a:dir)
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echo("Invalid directory name:" . a:name)
                                    return
                                endtry
                            
                                "we want the directory buffer to disappear when we do the :edit below
                                setlocal bufhidden=wipe
                            
                                let previousBuf = expand("#")
                            
                                "we need a unique name for each window tree buffer to ensure they are
                                "all independent
                                exec g:NERDTreeCreatePrefix . " edit " . self._nextBufferName()
                            
                                call self._createNERDTree(path, "window")
                                let b:NERDTree._previousBuf = bufnr(previousBuf)
                                call self._setCommonBufOptions()
                            
                                call b:NERDTree.render()
                            
                                call self._broadcastInitEvent()
                            endfunction
                            
                            " FUNCTION: s:Creator._createNERDTree(path) {{{1
    1              0.000001 function! s:Creator._createNERDTree(path, type)
                                let b:NERDTree = g:NERDTree.New(a:path, a:type)
                            
                                " TODO: This assignment is kept for compatibility reasons.  Many other
                                " plugins use "b:NERDTreeRoot" instead of "b:NERDTree.root".  Remove this
                                " assignment in the future.
                                let b:NERDTreeRoot = b:NERDTree.root
                            
                                call b:NERDTree.root.open()
                            endfunction
                            
                            " FUNCTION: s:Creator.CreateMirror() {{{1
    1              0.000001 function! s:Creator.CreateMirror()
                                let creator = s:Creator.New()
                                call creator.createMirror()
                            endfunction
                            
                            " FUNCTION: s:Creator.createMirror() {{{1
    1              0.000001 function! s:Creator.createMirror()
                                "get the names off all the nerd tree buffers
                                let treeBufNames = []
                                for i in range(1, tabpagenr("$"))
                                    let nextName = self._tabpagevar(i, 'NERDTreeBufName')
                                    if nextName != -1 && (!exists("t:NERDTreeBufName") || nextName != t:NERDTreeBufName)
                                        call add(treeBufNames, nextName)
                                    endif
                                endfor
                                let treeBufNames = self._uniq(treeBufNames)
                            
                                "map the option names (that the user will be prompted with) to the nerd
                                "tree buffer names
                                let options = {}
                                let i = 0
                                while i < len(treeBufNames)
                                    let bufName = treeBufNames[i]
                                    let treeRoot = getbufvar(bufName, "NERDTree").root
                                    let options[i+1 . '. ' . treeRoot.path.str() . '  (buf name: ' . bufName . ')'] = bufName
                                    let i = i + 1
                                endwhile
                            
                                "work out which tree to mirror, if there is more than 1 then ask the user
                                let bufferName = ''
                                if len(keys(options)) > 1
                                    let choices = ["Choose a tree to mirror"]
                                    let choices = extend(choices, sort(keys(options)))
                                    let choice = inputlist(choices)
                                    if choice < 1 || choice > len(options) || choice ==# ''
                                        return
                                    endif
                            
                                    let bufferName = options[sort(keys(options))[choice-1]]
                                elseif len(keys(options)) ==# 1
                                    let bufferName = values(options)[0]
                                else
                                    call nerdtree#echo("No trees to mirror")
                                    return
                                endif
                            
                                if g:NERDTree.ExistsForTab() && g:NERDTree.IsOpen()
                                    call g:NERDTree.Close()
                                endif
                            
                                let t:NERDTreeBufName = bufferName
                                call self._createTreeWin()
                                exec 'buffer ' .  bufferName
                                if !&hidden
                                    call b:NERDTree.render()
                                endif
                            endfunction
                            
                            " FUNCTION: s:Creator._createTreeWin() {{{1
                            " Initialize the NERDTree window.  Open the window, size it properly, set all
                            " local options, etc.
    1              0.000001 function! s:Creator._createTreeWin()
                                let l:splitLocation = g:NERDTreeWinPos ==# 'left' ? 'topleft ' : 'botright '
                                let l:splitSize = g:NERDTreeWinSize
                            
                                if !g:NERDTree.ExistsForTab()
                                    let t:NERDTreeBufName = self._nextBufferName()
                                    silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' new'
                                    silent! execute 'edit ' . t:NERDTreeBufName
                                else
                                    silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' split'
                                    silent! execute 'buffer ' . t:NERDTreeBufName
                                endif
                            
                                call self._setCommonBufOptions()
                            
                                if has('patch-7.4.1925')
                                    clearjumps
                                endif
                            
                                setlocal winfixwidth
                            endfunction
                            
                            " FUNCTION: s:Creator._isBufHidden(nr) {{{1
    1              0.000001 function! s:Creator._isBufHidden(nr)
                                redir => bufs
                                silent ls!
                                redir END
                            
                                return bufs =~ a:nr . '..h'
                            endfunction
                            
                            " FUNCTION: s:Creator.New() {{{1
    1              0.000001 function! s:Creator.New()
                                let newCreator = copy(self)
                                return newCreator
                            endfunction
                            
                            " FUNCTION: s:Creator._nextBufferName() {{{2
                            " returns the buffer name for the next nerd tree
    1              0.000001 function! s:Creator._nextBufferName()
                                let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
                                return name
                            endfunction
                            
                            " FUNCTION: s:Creator._nextBufferNumber() {{{2
                            " the number to add to the nerd tree buffer name to make the buf name unique
    1              0.000001 function! s:Creator._nextBufferNumber()
                                if !exists("s:Creator._NextBufNum")
                                    let s:Creator._NextBufNum = 1
                                else
                                    let s:Creator._NextBufNum += 1
                                endif
                            
                                return s:Creator._NextBufNum
                            endfunction
                            
                            " FUNCTION: s:Creator._pathForString(str) {{{1
                            " find a bookmark or adirectory for the given string
    1              0.000001 function! s:Creator._pathForString(str)
                                let path = {}
                                if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                    let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
                                else
                                    let dir = a:str ==# '' ? getcwd() : a:str
                            
                                    "hack to get an absolute path if a relative path is given
                                    if dir =~# '^\.'
                                        let dir = getcwd() . g:NERDTreePath.Slash() . dir
                                    endif
                                    let dir = g:NERDTreePath.Resolve(dir)
                            
                                    try
                                        let path = g:NERDTreePath.New(dir)
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo("No bookmark or directory found for: " . a:str)
                                        return {}
                                    endtry
                                endif
                                if !path.isDirectory
                                    let path = path.getParent()
                                endif
                            
                                return path
                            endfunction
                            
                            " Function: s:Creator._removeTreeBufForTab()   {{{1
    1              0.000001 function! s:Creator._removeTreeBufForTab()
                                let buf = bufnr(t:NERDTreeBufName)
                            
                                "if &hidden is not set then it will already be gone
                                if buf != -1
                            
                                    "nerdtree buf may be mirrored/displayed elsewhere
                                    if self._isBufHidden(buf)
                                        exec "bwipeout " . buf
                                    endif
                            
                                endif
                            
                                unlet t:NERDTreeBufName
                            endfunction
                            
                            " FUNCTION: s:Creator._setCommonBufOptions() {{{1
    1              0.000001 function! s:Creator._setCommonBufOptions()
                                "throwaway buffer options
                                setlocal noswapfile
                                setlocal buftype=nofile
                                setlocal bufhidden=hide
                                setlocal nowrap
                                setlocal foldcolumn=0
                                setlocal foldmethod=manual
                                setlocal nofoldenable
                                setlocal nobuflisted
                                setlocal nospell
                                if g:NERDTreeShowLineNumbers
                                    setlocal nu
                                else
                                    setlocal nonu
                                    if v:version >= 703
                                        setlocal nornu
                                    endif
                                endif
                            
                                iabc <buffer>
                            
                                if g:NERDTreeHighlightCursorline
                                    setlocal cursorline
                                endif
                            
                                call self._setupStatusline()
                                call self._bindMappings()
                                setlocal filetype=nerdtree
                            endfunction
                            
                            " FUNCTION: s:Creator._setupStatusline() {{{1
    1              0.000001 function! s:Creator._setupStatusline()
                                if g:NERDTreeStatusline != -1
                                    let &l:statusline = g:NERDTreeStatusline
                                endif
                            endfunction
                            
                            " FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1
    1              0.000001 function! s:Creator._tabpagevar(tabnr, var)
                                let currentTab = tabpagenr()
                                let old_ei = &ei
                                set ei=all
                            
                                exec "tabnext " . a:tabnr
                                let v = -1
                                if exists('t:' . a:var)
                                    exec 'let v = t:' . a:var
                                endif
                                exec "tabnext " . currentTab
                            
                                let &ei = old_ei
                            
                                return v
                            endfunction
                            
                            " FUNCTION: s:Creator.ToggleTabTree(dir) {{{1
    1              0.000001 function! s:Creator.ToggleTabTree(dir)
                                let creator = s:Creator.New()
                                call creator.toggleTabTree(a:dir)
                            endfunction
                            
                            " FUNCTION: s:Creator.toggleTabTree(dir) {{{1
                            " Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is
                            " closed it is restored or initialized (if it doesnt exist)
                            "
                            " Args:
                            " dir: the full path for the root node (is only used if the NERD tree is being
                            " initialized.
    1              0.000001 function! s:Creator.toggleTabTree(dir)
                                if g:NERDTree.ExistsForTab()
                                    if !g:NERDTree.IsOpen()
                                        call self._createTreeWin()
                                        if !&hidden
                                            call b:NERDTree.render()
                                        endif
                                        call b:NERDTree.ui.restoreScreenState()
                                    else
                                        call g:NERDTree.Close()
                                    endif
                                else
                                    call self.createTabTree(a:dir)
                                endif
                            endfunction
                            
                            " Function: s:Creator._uniq(list)   {{{1
                            " returns a:list without duplicates
    1              0.000001 function! s:Creator._uniq(list)
                              let uniqlist = []
                              for elem in a:list
                                if index(uniqlist, elem) ==# -1
                                  let uniqlist += [elem]
                                endif
                              endfor
                              return uniqlist
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/flag_set.vim
Sourced 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                            "CLASS: FlagSet
                            "============================================================
    1              0.000003 let s:FlagSet = {}
    1              0.000002 let g:NERDTreeFlagSet = s:FlagSet
                            
                            "FUNCTION: FlagSet.addFlag(scope, flag) {{{1
    1              0.000001 function! s:FlagSet.addFlag(scope, flag)
                                let flags = self._flagsForScope(a:scope)
                                if index(flags, a:flag) == -1
                                    call add(flags, a:flag)
                                end
                            endfunction
                            
                            "FUNCTION: FlagSet.clearFlags(scope) {{{1
    1              0.000001 function! s:FlagSet.clearFlags(scope)
                                let self._flags[a:scope] = []
                            endfunction
                            
                            "FUNCTION: FlagSet._flagsForScope(scope) {{{1
    1              0.000001 function! s:FlagSet._flagsForScope(scope)
                                if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
                                endif
                                return self._flags[a:scope]
                            endfunction
                            
                            "FUNCTION: FlagSet.New() {{{1
    1              0.000001 function! s:FlagSet.New()
                                let newObj = copy(self)
                                let newObj._flags = {}
                                return newObj
                            endfunction
                            
                            "FUNCTION: FlagSet.removeFlag(scope, flag) {{{1
    1              0.000001 function! s:FlagSet.removeFlag(scope, flag)
                                let flags = self._flagsForScope(a:scope)
                            
                                let i = index(flags, a:flag)
                                if i >= 0
                                    call remove(flags, i)
                                endif
                            endfunction
                            
                            "FUNCTION: FlagSet.renderToString() {{{1
    1              0.000001 function! s:FlagSet.renderToString()
                                let flagstring = ""
                                for i in values(self._flags)
                                    let flagstring .= join(i)
                                endfor
                            
                                if len(flagstring) == 0
                                    return ""
                                endif
                            
                                return '[' . flagstring . ']'
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/nerdtree.vim
Sourced 1 time
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
                            "CLASS: NERDTree
                            "============================================================
    1              0.000003 let s:NERDTree = {}
    1              0.000002 let g:NERDTree = s:NERDTree
                            
                            "FUNCTION: s:NERDTree.AddPathFilter() {{{1
    1              0.000002 function! s:NERDTree.AddPathFilter(callback)
                                call add(s:NERDTree.PathFilters(), a:callback)
                            endfunction
                            
                            "FUNCTION: s:NERDTree.changeRoot(node) {{{1
    1              0.000001 function! s:NERDTree.changeRoot(node)
                                if a:node.path.isDirectory
                                    let self.root = a:node
                                else
                                    call a:node.cacheParent()
                                    let self.root = a:node.parent
                                endif
                            
                                call self.root.open()
                            
                                "change dir to the dir of the new root if instructed to
                                if g:NERDTreeChDirMode ==# 2
                                    call self.root.path.changeToDir()
                                endif
                            
                                call self.render()
                                call self.root.putCursorHere(0, 0)
                            
                                silent doautocmd User NERDTreeNewRoot
                            endfunction
                            
                            "FUNCTION: s:NERDTree.Close() {{{1
                            "Closes the tab tree window for this tab
    1              0.000001 function! s:NERDTree.Close()
                                if !s:NERDTree.IsOpen()
                                    return
                                endif
                            
                                if winnr("$") != 1
                                    " Use the window ID to identify the currently active window or fall
                                    " back on the buffer ID if win_getid/win_gotoid are not available, in
                                    " which case we'll focus an arbitrary window showing the buffer.
                                    let l:useWinId = exists('*win_getid') && exists('*win_gotoid')
                            
                                    if winnr() == s:NERDTree.GetWinNum()
                                        call nerdtree#exec("wincmd p")
                                        let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr("")
                                        call nerdtree#exec("wincmd p")
                                    else
                                        let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr("")
                                    endif
                            
                                    call nerdtree#exec(s:NERDTree.GetWinNum() . " wincmd w")
                                    close
                                    if l:useWinId
                                        call nerdtree#exec("call win_gotoid(" . l:activeBufOrWin . ")")
                                    else
                                        call nerdtree#exec(bufwinnr(l:activeBufOrWin) . " wincmd w")
                                    endif
                                else
                                    close
                                endif
                            endfunction
                            
                            "FUNCTION: s:NERDTree.CloseIfQuitOnOpen() {{{1
                            "Closes the NERD tree window if the close on open option is set
    1              0.000001 function! s:NERDTree.CloseIfQuitOnOpen()
                                if g:NERDTreeQuitOnOpen && s:NERDTree.IsOpen()
                                    call s:NERDTree.Close()
                                endif
                            endfunction
                            
                            "FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1
                            "Places the cursor at the top of the bookmarks table
    1              0.000001 function! s:NERDTree.CursorToBookmarkTable()
                                if !b:NERDTree.ui.getShowBookmarks()
                                    throw "NERDTree.IllegalOperationError: cant find bookmark table, bookmarks arent active"
                                endif
                            
                                if g:NERDTreeMinimalUI
                                    return cursor(1, 2)
                                endif
                            
                                let rootNodeLine = b:NERDTree.ui.getRootLineNum()
                            
                                let line = 1
                                while getline(line) !~# '^>-\+Bookmarks-\+$'
                                    let line = line + 1
                                    if line >= rootNodeLine
                                        throw "NERDTree.BookmarkTableNotFoundError: didnt find the bookmarks table"
                                    endif
                                endwhile
                                call cursor(line, 2)
                            endfunction
                            
                            "FUNCTION: s:NERDTree.CursorToTreeWin(){{{1
                            "Places the cursor in the nerd tree window
    1              0.000001 function! s:NERDTree.CursorToTreeWin()
                                call g:NERDTree.MustBeOpen()
                                call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")
                            endfunction
                            
                            " Function: s:NERDTree.ExistsForBuffer()   {{{1
                            " Returns 1 if a nerd tree root exists in the current buffer
    1              0.000001 function! s:NERDTree.ExistsForBuf()
                                return exists("b:NERDTree")
                            endfunction
                            
                            " Function: s:NERDTree.ExistsForTab()   {{{1
                            " Returns 1 if a nerd tree root exists in the current tab
    1              0.000001 function! s:NERDTree.ExistsForTab()
                                if !exists("t:NERDTreeBufName")
                                    return
                                end
                            
                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
                                return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))
                            endfunction
                            
    1              0.000003 function! s:NERDTree.ForCurrentBuf()
                                if s:NERDTree.ExistsForBuf()
                                    return b:NERDTree
                                else
                                    return {}
                                endif
                            endfunction
                            
                            "FUNCTION: s:NERDTree.ForCurrentTab() {{{1
    1              0.000001 function! s:NERDTree.ForCurrentTab()
                                if !s:NERDTree.ExistsForTab()
                                    return
                                endif
                            
                                let bufnr = bufnr(t:NERDTreeBufName)
                                return getbufvar(bufnr, "NERDTree")
                            endfunction
                            
                            "FUNCTION: s:NERDTree.getRoot() {{{1
    1              0.000001 function! s:NERDTree.getRoot()
                                return self.root
                            endfunction
                            
                            "FUNCTION: s:NERDTree.GetWinNum() {{{1
                            "gets the nerd tree window number for this tab
    1              0.000001 function! s:NERDTree.GetWinNum()
                                if exists("t:NERDTreeBufName")
                                    return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1
                            endfunction
                            
                            "FUNCTION: s:NERDTree.IsOpen() {{{1
    1              0.000001 function! s:NERDTree.IsOpen()
                                return s:NERDTree.GetWinNum() != -1
                            endfunction
                            
                            "FUNCTION: s:NERDTree.isTabTree() {{{1
    1              0.000001 function! s:NERDTree.isTabTree()
                                return self._type == "tab"
                            endfunction
                            
                            "FUNCTION: s:NERDTree.isWinTree() {{{1
    1              0.000001 function! s:NERDTree.isWinTree()
                                return self._type == "window"
                            endfunction
                            
                            "FUNCTION: s:NERDTree.MustBeOpen() {{{1
    1              0.000001 function! s:NERDTree.MustBeOpen()
                                if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
                                endif
                            endfunction
                            
                            "FUNCTION: s:NERDTree.New() {{{1
    1              0.000001 function! s:NERDTree.New(path, type)
                                let newObj = copy(self)
                                let newObj.ui = g:NERDTreeUI.New(newObj)
                                let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
                                let newObj._type = a:type
                                return newObj
                            endfunction
                            
                            "FUNCTION: s:NERDTree.PathFilters() {{{1
    1              0.000001 function! s:NERDTree.PathFilters()
                                if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
                                return s:NERDTree._PathFilters
                            endfunction
                            
                            "FUNCTION: s:NERDTree.previousBuf() {{{1
    1              0.000001 function! s:NERDTree.previousBuf()
                                return self._previousBuf
                            endfunction
                            
    1              0.000001 function! s:NERDTree.setPreviousBuf(bnum)
                                let self._previousBuf = a:bnum
                            endfunction
                            
                            "FUNCTION: s:NERDTree.render() {{{1
                            "A convenience function - since this is called often
    1              0.000001 function! s:NERDTree.render()
                                call self.ui.render()
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/ui.vim
Sourced 1 time
Total time:   0.000353
 Self time:   0.000353

count  total (s)   self (s)
                            " ============================================================================
                            " CLASS: UI
                            " ============================================================================
                            
                            
    1              0.000002 let s:UI = {}
    1              0.000002 let g:NERDTreeUI = s:UI
                            
                            " FUNCTION: s:UI.centerView() {{{2
                            " centers the nerd tree window around the cursor (provided the nerd tree
                            " options permit)
    1              0.000001 function! s:UI.centerView()
                                if g:NERDTreeAutoCenter
                                    let current_line = winline()
                                    let lines_to_top = current_line
                                    let lines_to_bottom = winheight(g:NERDTree.GetWinNum()) - current_line
                                    if lines_to_top < g:NERDTreeAutoCenterThreshold || lines_to_bottom < g:NERDTreeAutoCenterThreshold
                                        normal! zz
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: s:UI._dumpHelp  {{{1
                            " prints out the quick help
    1              0.000001 function! s:UI._dumpHelp()
                                if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let help .= "\" <CR>,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    silent! put =help
                                elseif !self.isMinimal()
                                    let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
                                    silent! put =help
                                endif
                            endfunction
                            
                            
                            " FUNCTION: s:UI.new(nerdtree) {{{1
    1              0.000001 function! s:UI.New(nerdtree)
                                let newObj = copy(self)
                                let newObj.nerdtree = a:nerdtree
                                let newObj._showHelp = 0
                                let newObj._ignoreEnabled = 1
                                let newObj._showFiles = g:NERDTreeShowFiles
                                let newObj._showHidden = g:NERDTreeShowHidden
                                let newObj._showBookmarks = g:NERDTreeShowBookmarks
                            
                                return newObj
                            endfunction
                            
                            " FUNCTION: s:UI.getPath(ln) {{{1
                            " Return the "Path" object for the node that is rendered on the given line
                            " number.  If the "up a dir" line is selected, return the "Path" object for
                            " the parent of the root.  Return the empty dictionary if the given line
                            " does not reference a tree node.
    1              0.000001 function! s:UI.getPath(ln)
                                let line = getline(a:ln)
                            
                                let rootLine = self.getRootLineNum()
                            
                                if a:ln == rootLine
                                    return self.nerdtree.root.path
                                endif
                            
                                if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
                                endif
                            
                                if a:ln < rootLine
                                    return {}
                                endif
                            
                                let indent = self._indentLevelFor(line)
                            
                                " remove the tree parts and the leading space
                                let curFile = self._stripMarkup(line)
                            
                                let dir = ""
                                let lnum = a:ln
                                while lnum > 0
                                    let lnum = lnum - 1
                                    let curLine = getline(lnum)
                                    let curLineStripped = self._stripMarkup(curLine)
                            
                                    " have we reached the top of the tree?
                                    if lnum == rootLine
                                        let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
                                        break
                                    endif
                                    if curLineStripped =~# '/$'
                                        let lpindent = self._indentLevelFor(curLine)
                                        if lpindent < indent
                                            let indent = indent - 1
                            
                                            let dir = substitute (curLineStripped,'^\\', "", "") . dir
                                            continue
                                        endif
                                    endif
                                endwhile
                                let curFile = self.nerdtree.root.path.drive . dir . curFile
                                let toReturn = g:NERDTreePath.New(curFile)
                                return toReturn
                            endfunction
                            
                            " FUNCTION: s:UI.getLineNum(file_node){{{1
                            " returns the line number this node is rendered on, or -1 if it isnt rendered
    1              0.000001 function! s:UI.getLineNum(file_node)
                                " if the node is the root then return the root line no.
                                if a:file_node.isRoot()
                                    return self.getRootLineNum()
                                endif
                            
                                let totalLines = line("$")
                            
                                " the path components we have matched so far
                                let pathcomponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/ *$', '', '')]
                                " the index of the component we are searching for
                                let curPathComponent = 1
                            
                                let fullpath = a:file_node.path.str({'format': 'UI'})
                            
                                let lnum = self.getRootLineNum()
                                while lnum > 0
                                    let lnum = lnum + 1
                                    " have we reached the bottom of the tree?
                                    if lnum ==# totalLines+1
                                        return -1
                                    endif
                            
                                    let curLine = getline(lnum)
                            
                                    let indent = self._indentLevelFor(curLine)
                                    if indent ==# curPathComponent
                                        let curLine = self._stripMarkup(curLine)
                            
                                        let curPath =  join(pathcomponents, '/') . '/' . curLine
                                        if stridx(fullpath, curPath, 0) ==# 0
                                            if fullpath ==# curPath || strpart(fullpath, len(curPath)-1,1) ==# '/'
                                                let curLine = substitute(curLine, '/ *$', '', '')
                                                call add(pathcomponents, curLine)
                                                let curPathComponent = curPathComponent + 1
                            
                                                if fullpath ==# curPath
                                                    return lnum
                                                endif
                                            endif
                                        endif
                                    endif
                                endwhile
                                return -1
                            endfunction
                            
                            " FUNCTION: s:UI.getRootLineNum(){{{1
                            " gets the line number of the root node
    1              0.000001 function! s:UI.getRootLineNum()
                                let rootLine = 1
                                while getline(rootLine) !~# '^\(/\|<\)'
                                    let rootLine = rootLine + 1
                                endwhile
                                return rootLine
                            endfunction
                            
                            " FUNCTION: s:UI.getShowBookmarks() {{{1
    1              0.000002 function! s:UI.getShowBookmarks()
                                return self._showBookmarks
                            endfunction
                            
                            " FUNCTION: s:UI.getShowFiles() {{{1
    1              0.000001 function! s:UI.getShowFiles()
                                return self._showFiles
                            endfunction
                            
                            " FUNCTION: s:UI.getShowHelp() {{{1
    1              0.000001 function! s:UI.getShowHelp()
                                return self._showHelp
                            endfunction
                            
                            " FUNCTION: s:UI.getShowHidden() {{{1
    1              0.000001 function! s:UI.getShowHidden()
                                return self._showHidden
                            endfunction
                            
                            " FUNCTION: s:UI._indentLevelFor(line) {{{1
    1              0.000001 function! s:UI._indentLevelFor(line)
                                " have to do this work around because match() returns bytes, not chars
                                let numLeadBytes = match(a:line, '\M\[^ '.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.']')
                                " The next line is a backward-compatible workaround for strchars(a:line(0:numLeadBytes-1]). strchars() is in 7.3+
                                let leadChars = len(split(a:line[0:numLeadBytes-1], '\zs'))
                            
                                return leadChars / s:UI.IndentWid()
                            endfunction
                            
                            " FUNCTION: s:UI.IndentWid() {{{1
    1              0.000001 function! s:UI.IndentWid()
                                return 2
                            endfunction
                            
                            " FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1
    1              0.000001 function! s:UI.isIgnoreFilterEnabled()
                                return self._ignoreEnabled == 1
                            endfunction
                            
                            " FUNCTION: s:UI.isMinimal() {{{1
    1              0.000001 function! s:UI.isMinimal()
                                return g:NERDTreeMinimalUI
                            endfunction
                            
                            " FUNCTION: s:UI.MarkupReg() {{{1
    1              0.000001 function! s:UI.MarkupReg()
                                return '^\(['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+\)'
                            endfunction
                            
                            " FUNCTION: s:UI._renderBookmarks {{{1
    1              0.000001 function! s:UI._renderBookmarks()
                            
                                if !self.isMinimal()
                                    call setline(line(".")+1, ">----------Bookmarks----------")
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                if g:NERDTreeBookmarksSort == 1 || g:NERDTreeBookmarksSort == 2
                                    call g:NERDTreeBookmark.SortBookmarksList()
                                endif
                            
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    call setline(line(".")+1, i.str())
                                    call cursor(line(".")+1, col("."))
                                endfor
                            
                                call setline(line(".")+1, '')
                                call cursor(line(".")+1, col("."))
                            endfunction
                            
                            " FUNCTION: s:UI.restoreScreenState() {{{1
                            "
                            " Sets the screen state back to what it was when nerdtree#saveScreenState was last
                            " called.
                            "
                            " Assumes the cursor is in the NERDTree window
    1              0.000001 function! s:UI.restoreScreenState()
                                if !has_key(self, '_screenState')
                                    return
                                endif
                                exec("silent vertical resize " . self._screenState['oldWindowSize'])
                            
                                let old_scrolloff=&scrolloff
                                let &scrolloff=0
                                call cursor(self._screenState['oldTopLine'], 0)
                                normal! zt
                                call setpos(".", self._screenState['oldPos'])
                                let &scrolloff=old_scrolloff
                            endfunction
                            
                            " FUNCTION: s:UI.saveScreenState() {{{1
                            " Saves the current cursor position in the current buffer and the window
                            " scroll position
    1              0.000001 function! s:UI.saveScreenState()
                                let win = winnr()
                                call g:NERDTree.CursorToTreeWin()
                                let self._screenState = {}
                                let self._screenState['oldPos'] = getpos(".")
                                let self._screenState['oldTopLine'] = line("w0")
                                let self._screenState['oldWindowSize']= winwidth("")
                                call nerdtree#exec(win . "wincmd w")
                            endfunction
                            
                            " FUNCTION: s:UI.setShowHidden(val) {{{1
    1              0.000001 function! s:UI.setShowHidden(val)
                                let self._showHidden = a:val
                            endfunction
                            
                            " FUNCTION: s:UI._stripMarkup(line){{{1
                            " returns the given line with all the tree parts stripped off
                            "
                            " Args:
                            " line: the subject line
    1              0.000001 function! s:UI._stripMarkup(line)
                                let line = a:line
                                " remove the tree parts and the leading space
                                let line = substitute (line, g:NERDTreeUI.MarkupReg(),"","")
                            
                                " strip off any read only flag
                                let line = substitute (line, ' \['.g:NERDTreeGlyphReadOnly.'\]', "","")
                            
                                " strip off any bookmark flags
                                let line = substitute (line, ' {[^}]*}', "","")
                            
                                " strip off any executable flags
                                let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                " strip off any generic flags
                                let line = substitute (line, '\[[^]]*\]', "","")
                            
                                let line = substitute (line,' -> .*',"","") " remove link to
                            
                                return line
                            endfunction
                            
                            " FUNCTION: s:UI.render() {{{1
    1              0.000001 function! s:UI.render()
                                setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
                                let curLine = line(".")
                                let curCol = col(".")
                                let topLine = line("w0")
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
                                silent 1,$delete _
                            
                                call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
                                if !self.isMinimal()
                                    call setline(line(".")+1, "")
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                " add the 'up a dir' line
                                if !self.isMinimal()
                                    call setline(line(".")+1, s:UI.UpDirLine())
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                " draw the header line
                                let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
                                call setline(line(".")+1, header)
                                call cursor(line(".")+1, col("."))
                            
                                " draw the tree
                                silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
                                silent 1,1delete _
                            
                                " restore the view
                                let old_scrolloff=&scrolloff
                                let &scrolloff=0
                                call cursor(topLine, 1)
                                normal! zt
                                call cursor(curLine, curCol)
                                let &scrolloff = old_scrolloff
                            
                                setlocal readonly nomodifiable
                            endfunction
                            
                            
                            " FUNCTION: UI.renderViewSavingPosition {{{1
                            " Renders the tree and ensures the cursor stays on the current node or the
                            " current nodes parent if it is no longer available upon re-rendering
    1              0.000002 function! s:UI.renderViewSavingPosition()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                            
                                " go up the tree till we find a node that will be visible or till we run
                                " out of nodes
                                while currentNode != {} && !currentNode.isVisible() && !currentNode.isRoot()
                                    let currentNode = currentNode.parent
                                endwhile
                            
                                call self.render()
                            
                                if currentNode != {}
                                    call currentNode.putCursorHere(0, 0)
                                endif
                            endfunction
                            
                            " FUNCTION: s:UI.toggleHelp() {{{1
    1              0.000001 function! s:UI.toggleHelp()
                                let self._showHelp = !self._showHelp
                            endfunction
                            
                            " FUNCTION: s:UI.toggleIgnoreFilter() {{{1
                            " toggles the use of the NERDTreeIgnore option
    1              0.000001 function! s:UI.toggleIgnoreFilter()
                                let self._ignoreEnabled = !self._ignoreEnabled
                                call self.renderViewSavingPosition()
                                call self.centerView()
                            endfunction
                            
                            " FUNCTION: s:UI.toggleShowBookmarks() {{{1
                            " Toggle the visibility of the Bookmark table.
    1              0.000001 function! s:UI.toggleShowBookmarks()
                                let self._showBookmarks = !self._showBookmarks
                            
                                if self.getShowBookmarks()
                                    call self.nerdtree.render()
                                    call g:NERDTree.CursorToBookmarkTable()
                                else
                            
                                    if empty(g:NERDTreeFileNode.GetSelected())
                                        call b:NERDTree.root.putCursorHere(0, 0)
                                        normal! 0
                                    endif
                            
                                    call self.renderViewSavingPosition()
                                endif
                            
                                call self.centerView()
                            endfunction
                            
                            " FUNCTION: s:UI.toggleShowFiles() {{{1
                            " toggles the display of hidden files
    1              0.000001 function! s:UI.toggleShowFiles()
                                let self._showFiles = !self._showFiles
                                call self.renderViewSavingPosition()
                                call self.centerView()
                            endfunction
                            
                            " FUNCTION: s:UI.toggleShowHidden() {{{1
                            " toggles the display of hidden files
    1              0.000001 function! s:UI.toggleShowHidden()
                                let self._showHidden = !self._showHidden
                                call self.renderViewSavingPosition()
                                call self.centerView()
                            endfunction
                            
                            " FUNCTION: s:UI.toggleZoom() {{{1
                            " zoom (maximize/minimize) the NERDTree window
    1              0.000001 function! s:UI.toggleZoom()
                                if exists("b:NERDTreeZoomed") && b:NERDTreeZoomed
                                    let size = exists("b:NERDTreeOldWindowSize") ? b:NERDTreeOldWindowSize : g:NERDTreeWinSize
                                    exec "silent vertical resize ". size
                                    let b:NERDTreeZoomed = 0
                                else
                                    exec "vertical resize"
                                    let b:NERDTreeZoomed = 1
                                endif
                            endfunction
                            
                            " FUNCTION: s:UI.UpDirLine() {{{1
    1              0.000001 function! s:UI.UpDirLine()
                                return '.. (up a dir)'
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/event.vim
Sourced 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
                            "CLASS: Event
                            "============================================================
    1              0.000003 let s:Event = {}
    1              0.000002 let g:NERDTreeEvent = s:Event
                            
    1              0.000002 function! s:Event.New(nerdtree, subject, action, params) abort
                                let newObj = copy(self)
                                let newObj.nerdtree = a:nerdtree
                                let newObj.subject = a:subject
                                let newObj.action = a:action
                                let newObj.params = a:params
                                return newObj
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/lib/nerdtree/notifier.vim
Sourced 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                            "CLASS: Notifier
                            "============================================================
    1              0.000002 let s:Notifier = {}
                            
    1              0.000002 function! s:Notifier.AddListener(event, funcname)
                                let listeners = s:Notifier.GetListenersForEvent(a:event)
                                if listeners == []
                                    let listenersMap = s:Notifier.GetListenersMap()
                                    let listenersMap[a:event] = listeners
                                endif
                                call add(listeners, a:funcname)
                            endfunction
                            
    1              0.000002 function! s:Notifier.NotifyListeners(event, path, nerdtree, params)
                                let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
                                for listener in s:Notifier.GetListenersForEvent(a:event)
                                    call {listener}(event)
                                endfor
                            endfunction
                            
    1              0.000001 function! s:Notifier.GetListenersMap()
                                if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
                                endif
                                return s:refreshListenersMap
                            endfunction
                            
    1              0.000001 function! s:Notifier.GetListenersForEvent(name)
                                let listenersMap = s:Notifier.GetListenersMap()
                                return get(listenersMap, a:name, [])
                            endfunction
                            
    1              0.000010 let g:NERDTreePathNotifier = deepcopy(s:Notifier)

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim
Sourced 1 time
Total time:   0.000475
 Self time:   0.000475

count  total (s)   self (s)
    1              0.000005 if exists("g:loaded_nerdtree_ui_glue_autoload")
                                finish
                            endif
    1              0.000002 let g:loaded_nerdtree_ui_glue_autoload = 1
                            
                            " FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1
    1              0.000002 function! nerdtree#ui_glue#createDefaultBindings()
                                let s = '<SNR>' . s:SID() . '_'
                            
                                call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })
                                call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })
                                call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })
                            
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': "all", 'callback': "nerdtree#ui_glue#chRootCwd" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })
                            
                                call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })
                            endfunction
                            
                            
                            "SECTION: Interface bindings {{{1
                            "============================================================
                            
                            "FUNCTION: s:activateAll() {{{1
                            "handle the user activating the updir line
    1              0.000002 function! s:activateAll()
                                if getline(".") ==# g:NERDTreeUI.UpDirLine()
                                    return nerdtree#ui_glue#upDir(0)
                                endif
                            endfunction
                            
                            " FUNCTION: s:activateDirNode(directoryNode) {{{1
    1              0.000001 function! s:activateDirNode(directoryNode)
                            
                                if a:directoryNode.isRoot() && a:directoryNode.isOpen
                                    call nerdtree#echo('cannot close tree root')
                                    return
                                endif
                            
                                call a:directoryNode.activate()
                            endfunction
                            
                            "FUNCTION: s:activateFileNode() {{{1
                            "handle the user activating a tree node
    1              0.000001 function! s:activateFileNode(node)
                                call a:node.activate({'reuse': 'all', 'where': 'p'})
                            endfunction
                            
                            "FUNCTION: s:activateBookmark() {{{1
                            "handle the user activating a bookmark
    1              0.000001 function! s:activateBookmark(bm)
                                call a:bm.activate(b:NERDTree, !a:bm.path.isDirectory ? {'where': 'p'} : {})
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1
                            " Associate the current node with the given name
    1              0.000002 function! nerdtree#ui_glue#bookmarkNode(...)
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                if currentNode != {}
                                    let name = a:1
                                    if empty(name)
                                        let name = currentNode.path.getLastPathComponent(0)
                                    endif
                                    try
                                        call currentNode.bookmark(name)
                                        call b:NERDTree.render()
                                    catch /^NERDTree.IllegalBookmarkNameError/
                                        call nerdtree#echo("bookmark names must not contain spaces")
                                    endtry
                                else
                                    call nerdtree#echo("select a node first")
                                endif
                            endfunction
                            
                            " FUNCTION: s:chCwd(node) {{{1
    1              0.000001 function! s:chCwd(node)
                                try
                                    call a:node.path.changeToDir()
                                catch /^NERDTree.PathChangeError/
                                    call nerdtree#echoWarning("could not change cwd")
                                endtry
                            endfunction
                            
                            " FUNCTION: s:chRoot(node) {{{1
                            " changes the current root to the selected one
    1              0.000001 function! s:chRoot(node)
                                call b:NERDTree.changeRoot(a:node)
                            endfunction
                            
                            " FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1
                            " changes the current root to CWD
    1              0.000001 function! nerdtree#ui_glue#chRootCwd()
                                try
                                    let cwd = g:NERDTreePath.New(getcwd())
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echo("current directory does not exist.")
                                    return
                                endtry
                                if cwd.str() == g:NERDTreeFileNode.GetRootForTab().path.str()
                                   return
                                endif
                                call s:chRoot(g:NERDTreeDirNode.New(cwd, b:NERDTree))
                            endfunction
                            
                            " FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1
    1              0.000002 function! nerdtree#ui_glue#clearBookmarks(bookmarks)
                                if a:bookmarks ==# ''
                                    let currentNode = g:NERDTreeFileNode.GetSelected()
                                    if currentNode != {}
                                        call currentNode.clearBookmarks()
                                    endif
                                else
                                    for name in split(a:bookmarks, ' ')
                                        let bookmark = g:NERDTreeBookmark.BookmarkFor(name)
                                        call bookmark.delete()
                                    endfor
                                endif
                                call b:NERDTree.root.refresh()
                                call b:NERDTree.render()
                            endfunction
                            
                            " FUNCTION: s:closeChildren(node) {{{1
                            " closes all childnodes of the current node
    1              0.000002 function! s:closeChildren(node)
                                call a:node.closeChildren()
                                call b:NERDTree.render()
                                call a:node.putCursorHere(0, 0)
                            endfunction
                            
                            " FUNCTION: s:closeCurrentDir(node) {{{1
                            " Close the parent directory of the current node.
    1              0.000001 function! s:closeCurrentDir(node)
                            
                                if a:node.isRoot()
                                    call nerdtree#echo('cannot close parent of tree root')
                                    return
                                endif
                            
                                let l:parent = a:node.parent
                            
                                while l:parent.isCascadable()
                                    let l:parent = l:parent.parent
                                endwhile
                            
                                if l:parent.isRoot()
                                    call nerdtree#echo('cannot close tree root')
                                    return
                                endif
                            
                                call l:parent.close()
                                call b:NERDTree.render()
                                call l:parent.putCursorHere(0, 0)
                            endfunction
                            
                            " FUNCTION: s:closeTreeWindow() {{{1
                            " close the tree window
    1              0.000001 function! s:closeTreeWindow()
                                if b:NERDTree.isWinTree() && b:NERDTree.previousBuf() != -1
                                    exec "buffer " . b:NERDTree.previousBuf()
                                else
                                    if winnr("$") > 1
                                        call g:NERDTree.Close()
                                    else
                                        call nerdtree#echo("Cannot close last window")
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: s:deleteBookmark(bookmark) {{{1
                            " Prompt the user to confirm the deletion of the selected bookmark.
    1              0.000001 function! s:deleteBookmark(bookmark)
                                let l:message = "Delete the bookmark \"" . a:bookmark.name
                                            \ . "\" from the bookmark list?"
                            
                                let l:choices = "&Yes\n&No"
                            
                                echo | redraw
                                let l:selection = confirm(l:message, l:choices, 1, 'Warning')
                            
                                if l:selection != 1
                                    call nerdtree#echo('bookmark not deleted')
                                    return
                                endif
                            
                                try
                                    call a:bookmark.delete()
                                    silent call b:NERDTree.root.refresh()
                                    call b:NERDTree.render()
                                    echo | redraw
                                catch /^NERDTree/
                                    call nerdtree#echoWarning('could not remove bookmark')
                                endtry
                            endfunction
                            
                            " FUNCTION: s:displayHelp() {{{1
                            " toggles the help display
    1              0.000001 function! s:displayHelp()
                                call b:NERDTree.ui.toggleHelp()
                                call b:NERDTree.render()
                                call b:NERDTree.ui.centerView()
                            endfunction
                            
                            " FUNCTION: s:findAndRevealPath(pathStr) {{{1
    1              0.000001 function! s:findAndRevealPath(pathStr)
                                let l:pathStr = !empty(a:pathStr) ? a:pathStr : expand('%:p')
                            
                                if empty(l:pathStr)
                                    call nerdtree#echoWarning('no file for the current buffer')
                                    return
                                endif
                            
                                try
                                    let l:pathObj = g:NERDTreePath.New(l:pathStr)
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echoWarning('invalid path')
                                    return
                                endtry
                            
                                if !g:NERDTree.ExistsForTab()
                                    try
                                        let l:cwd = g:NERDTreePath.New(getcwd())
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo('current directory does not exist.')
                                        let l:cwd = l:pathObj.getParent()
                                    endtry
                            
                                    if l:pathObj.isUnder(l:cwd)
                                        call g:NERDTreeCreator.CreateTabTree(l:cwd.str())
                                    else
                                        call g:NERDTreeCreator.CreateTabTree(l:pathObj.getParent().str())
                                    endif
                                else
                                    NERDTreeFocus
                            
                                    if !l:pathObj.isUnder(b:NERDTree.root.path)
                                        call s:chRoot(g:NERDTreeDirNode.New(l:pathObj.getParent(), b:NERDTree))
                                    endif
                                endif
                            
                                if l:pathObj.isHiddenUnder(b:NERDTree.root.path)
                                    call b:NERDTree.ui.setShowHidden(1)
                                endif
                            
                                let l:node = b:NERDTree.root.reveal(l:pathObj)
                                call b:NERDTree.render()
                                call l:node.putCursorHere(1, 0)
                            endfunction
                            
                            "FUNCTION: s:handleLeftClick() {{{1
                            "Checks if the click should open the current node
    1              0.000001 function! s:handleLeftClick()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                if currentNode != {}
                            
                                    "the dir arrows are multibyte chars, and vim's string functions only
                                    "deal with single bytes - so split the line up with the hack below and
                                    "take the line substring manually
                                    let line = split(getline(line(".")), '\zs')
                                    let startToCur = ""
                                    for i in range(0,len(line)-1)
                                        let startToCur .= line[i]
                                    endfor
                            
                                    if currentNode.path.isDirectory
                                        if startToCur =~# g:NERDTreeUI.MarkupReg() && startToCur =~# '[+~'.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \?$'
                                            call currentNode.activate()
                                            return
                                        endif
                                    endif
                            
                                    if (g:NERDTreeMouseMode ==# 2 && currentNode.path.isDirectory) || g:NERDTreeMouseMode ==# 3
                                        let char = strpart(startToCur, strlen(startToCur)-1, 1)
                                        if char !~# g:NERDTreeUI.MarkupReg()
                                            if currentNode.path.isDirectory
                                                call currentNode.activate()
                                            else
                                                call currentNode.activate({'reuse': 'all', 'where': 'p'})
                                            endif
                                            return
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            " FUNCTION: s:handleMiddleMouse() {{{1
    1              0.000001 function! s:handleMiddleMouse()
                            
                                " A middle mouse click does not automatically position the cursor as one
                                " would expect. Forcing the execution of a regular left mouse click here
                                " fixes this problem.
                                execute "normal! \<LeftMouse>"
                            
                                let l:currentNode = g:NERDTreeFileNode.GetSelected()
                                if empty(l:currentNode)
                                    call nerdtree#echoError('use the pointer to select a node')
                                    return
                                endif
                            
                                if l:currentNode.path.isDirectory
                                    call l:currentNode.openExplorer()
                                else
                                    call l:currentNode.open({'where': 'h'})
                                endif
                            endfunction
                            
                            " FUNCTION: s:jumpToChild(direction) {{{2
                            " Args:
                            " direction: 0 if going to first child, 1 if going to last
    1              0.000003 function! s:jumpToChild(currentNode, direction)
                                if a:currentNode.isRoot()
                                    return nerdtree#echo("cannot jump to " . (a:direction ? "last" : "first") .  " child")
                                end
                                let dirNode = a:currentNode.parent
                                let childNodes = dirNode.getVisibleChildren()
                            
                                let targetNode = childNodes[0]
                                if a:direction
                                    let targetNode = childNodes[len(childNodes) - 1]
                                endif
                            
                                if targetNode.equals(a:currentNode)
                                    let siblingDir = a:currentNode.parent.findOpenDirSiblingWithVisibleChildren(a:direction)
                                    if siblingDir != {}
                                        let indx = a:direction ? siblingDir.getVisibleChildCount()-1 : 0
                                        let targetNode = siblingDir.getChildByIndex(indx, 1)
                                    endif
                                endif
                            
                                call targetNode.putCursorHere(1, 0)
                            
                                call b:NERDTree.ui.centerView()
                            endfunction
                            
                            
                            " FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1
                            "this is needed since I cant figure out how to invoke dict functions from a
                            "key map
    1              0.000002 function! nerdtree#ui_glue#invokeKeyMap(key)
                                call g:NERDTreeKeyMap.Invoke(a:key)
                            endfunction
                            
                            " FUNCTION: s:jumpToFirstChild() {{{1
                            " wrapper for the jump to child method
    1              0.000001 function! s:jumpToFirstChild(node)
                                call s:jumpToChild(a:node, 0)
                            endfunction
                            
                            " FUNCTION: s:jumpToLastChild() {{{1
                            " wrapper for the jump to child method
    1              0.000001 function! s:jumpToLastChild(node)
                                call s:jumpToChild(a:node, 1)
                            endfunction
                            
                            " FUNCTION: s:jumpToParent(node) {{{1
                            " Move the cursor to the parent of the specified node. For a cascade, move to
                            " the parent of the cascade's highest node. At the root, do nothing.
    1              0.000001 function! s:jumpToParent(node)
                                let l:parent = a:node.parent
                            
                                " If "a:node" represents a directory, back out of its cascade.
                                if a:node.path.isDirectory
                                    while !empty(l:parent) && !l:parent.isRoot()
                                        if index(l:parent.getCascade(), a:node) >= 0
                                            let l:parent = l:parent.parent
                                        else
                                            break
                                        endif
                                    endwhile
                                endif
                            
                                if !empty(l:parent)
                                    call l:parent.putCursorHere(1, 0)
                                    call b:NERDTree.ui.centerView()
                                else
                                    call nerdtree#echo('could not jump to parent node')
                                endif
                            endfunction
                            
                            " FUNCTION: s:jumpToRoot() {{{1
                            " moves the cursor to the root node
    1              0.000001 function! s:jumpToRoot()
                                call b:NERDTree.root.putCursorHere(1, 0)
                                call b:NERDTree.ui.centerView()
                            endfunction
                            
                            " FUNCTION: s:jumpToNextSibling(node) {{{1
    1              0.000001 function! s:jumpToNextSibling(node)
                                call s:jumpToSibling(a:node, 1)
                            endfunction
                            
                            " FUNCTION: s:jumpToPrevSibling(node) {{{1
    1              0.000001 function! s:jumpToPrevSibling(node)
                                call s:jumpToSibling(a:node, 0)
                            endfunction
                            
                            " FUNCTION: s:jumpToSibling(currentNode, forward) {{{2
                            " moves the cursor to the sibling of the current node in the given direction
                            "
                            " Args:
                            " forward: 1 if the cursor should move to the next sibling, 0 if it should
                            " move back to the previous sibling
    1              0.000001 function! s:jumpToSibling(currentNode, forward)
                                let sibling = a:currentNode.findSibling(a:forward)
                            
                                if !empty(sibling)
                                    call sibling.putCursorHere(1, 0)
                                    call b:NERDTree.ui.centerView()
                                endif
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1
                            " Open the Bookmark that has the specified name. This function provides the
                            " implementation for the ":OpenBookmark" command.
    1              0.000002 function! nerdtree#ui_glue#openBookmark(name)
                                try
                                    let l:bookmark = g:NERDTreeBookmark.BookmarkFor(a:name)
                                catch /^NERDTree.BookmarkNotFoundError/
                                    call nerdtree#echoError('bookmark "' . a:name . '" not found')
                                    return
                                endtry
                                if l:bookmark.path.isDirectory
                                    call l:bookmark.open(b:NERDTree)
                                else
                                    call l:bookmark.open(b:NERDTree, {'where': 'p'})
                                endif
                            endfunction
                            
                            " FUNCTION: s:openHSplit(target) {{{1
    1              0.000001 function! s:openHSplit(target)
                                call a:target.activate({'where': 'h'})
                            endfunction
                            
                            " FUNCTION: s:openVSplit(target) {{{1
    1              0.000001 function! s:openVSplit(target)
                                call a:target.activate({'where': 'v'})
                            endfunction
                            
                            " FUNCTION: s:openExplorer(node) {{{1
    1              0.000001 function! s:openExplorer(node)
                                call a:node.openExplorer()
                            endfunction
                            
                            " FUNCTION: s:openInNewTab(target) {{{1
    1              0.000001 function! s:openInNewTab(target)
                                let l:opener = g:NERDTreeOpener.New(a:target.path, {'where': 't'})
                                call l:opener.open(a:target)
                            endfunction
                            
                            " FUNCTION: s:openInNewTabSilent(target) {{{1
    1              0.000002 function! s:openInNewTabSilent(target)
                                let l:opener = g:NERDTreeOpener.New(a:target.path, {'where': 't', 'stay': 1})
                                call l:opener.open(a:target)
                            endfunction
                            
                            " FUNCTION: s:openNodeRecursively(node) {{{1
    1              0.000001 function! s:openNodeRecursively(node)
                                call nerdtree#echo("Recursively opening node. Please wait...")
                                call a:node.openRecursively()
                                call b:NERDTree.render()
                                redraw
                                call nerdtree#echo("Recursively opening node. Please wait... DONE")
                            endfunction
                            
                            "FUNCTION: s:previewNodeCurrent(node) {{{1
    1              0.000001 function! s:previewNodeCurrent(node)
                                call a:node.open({'stay': 1, 'where': 'p', 'keepopen': 1})
                            endfunction
                            
                            "FUNCTION: s:previewNodeHSplit(node) {{{1
    1              0.000001 function! s:previewNodeHSplit(node)
                                call a:node.open({'stay': 1, 'where': 'h', 'keepopen': 1})
                            endfunction
                            
                            "FUNCTION: s:previewNodeVSplit(node) {{{1
    1              0.000001 function! s:previewNodeVSplit(node)
                                call a:node.open({'stay': 1, 'where': 'v', 'keepopen': 1})
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1
                            " put the cursor on the node associate with the given name
    1              0.000002 function! nerdtree#ui_glue#revealBookmark(name)
                                try
                                    let targetNode = g:NERDTreeBookmark.GetNodeForName(a:name, 0, b:NERDTree)
                                    call targetNode.putCursorHere(0, 1)
                                catch /^NERDTree.BookmarkNotFoundError/
                                    call nerdtree#echo("Bookmark isnt cached under the current root")
                                endtry
                            endfunction
                            
                            " FUNCTION: s:refreshRoot() {{{1
                            " Reloads the current root. All nodes below this will be lost and the root dir
                            " will be reloaded.
    1              0.000001 function! s:refreshRoot()
                                call nerdtree#echo("Refreshing the root node. This could take a while...")
                                call b:NERDTree.root.refresh()
                                call b:NERDTree.render()
                                redraw
                                call nerdtree#echo("Refreshing the root node. This could take a while... DONE")
                            endfunction
                            
                            " FUNCTION: s:refreshCurrent(node) {{{1
                            " refreshes the root for the current node
    1              0.000001 function! s:refreshCurrent(node)
                                let node = a:node
                                if !node.path.isDirectory
                                    let node = node.parent
                                endif
                            
                                call nerdtree#echo("Refreshing node. This could take a while...")
                                call node.refresh()
                                call b:NERDTree.render()
                                redraw
                                call nerdtree#echo("Refreshing node. This could take a while... DONE")
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#setupCommands() {{{1
    1              0.000001 function! nerdtree#ui_glue#setupCommands()
                                command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
                                command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
                                command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
                                command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
                                command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
                                command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')
                                command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
                                command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
                            endfunction
                            
                            " Function: s:SID()   {{{1
    1              0.000001 function s:SID()
                                if !exists("s:sid")
                                    let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
                                endif
                                return s:sid
                            endfun
                            
                            " FUNCTION: s:showMenu(node) {{{1
    1              0.000001 function! s:showMenu(node)
                                let mc = g:NERDTreeMenuController.New(g:NERDTreeMenuItem.AllEnabled())
                                call mc.showMenu()
                            endfunction
                            
                            " FUNCTION: s:toggleIgnoreFilter() {{{1
    1              0.000001 function! s:toggleIgnoreFilter()
                                call b:NERDTree.ui.toggleIgnoreFilter()
                            endfunction
                            
                            " FUNCTION: s:toggleShowBookmarks() {{{1
    1              0.000001 function! s:toggleShowBookmarks()
                                call b:NERDTree.ui.toggleShowBookmarks()
                            endfunction
                            
                            " FUNCTION: s:toggleShowFiles() {{{1
    1              0.000001 function! s:toggleShowFiles()
                                call b:NERDTree.ui.toggleShowFiles()
                            endfunction
                            
                            " FUNCTION: s:toggleShowHidden() {{{1
                            " toggles the display of hidden files
    1              0.000001 function! s:toggleShowHidden()
                                call b:NERDTree.ui.toggleShowHidden()
                            endfunction
                            
                            " FUNCTION: s:toggleZoom() {{{1
    1              0.000001 function! s:toggleZoom()
                                call b:NERDTree.ui.toggleZoom()
                            endfunction
                            
                            " FUNCTION: nerdtree#ui_glue#upDir(preserveState) {{{1
                            " Move the NERDTree up one level.
                            "
                            " Args:
                            " preserveState: if 1, the current root is left open when the new tree is
                            " rendered; if 0, the current root node is closed
    1              0.000002 function! nerdtree#ui_glue#upDir(preserveState)
                            
                                try
                                    call b:NERDTree.root.cacheParent()
                                catch /^NERDTree.CannotCacheParentError/
                                    call nerdtree#echo('already at root directory')
                                    return
                                endtry
                            
                                let l:oldRoot = b:NERDTree.root
                                let l:newRoot = b:NERDTree.root.parent
                            
                                call l:newRoot.open()
                                call l:newRoot.transplantChild(l:oldRoot)
                            
                                if !a:preserveState
                                    call l:oldRoot.close()
                                endif
                            
                                call b:NERDTree.changeRoot(l:newRoot)
                                call l:oldRoot.putCursorHere(0, 0)
                            endfunction
                            
                            " FUNCTION: s:upDirCurrentRootOpen() {{{1
    1              0.000001 function! s:upDirCurrentRootOpen()
                                call nerdtree#ui_glue#upDir(1)
                            endfunction
                            
                            " FUNCTION: s:upDirCurrentRootClosed() {{{1
    1              0.000001 function! s:upDirCurrentRootClosed()
                                call nerdtree#ui_glue#upDir(0)
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim
Sourced 1 time
Total time:   0.000107
 Self time:   0.000057

count  total (s)   self (s)
                            " ============================================================================
                            " File:        exec_menuitem.vim
                            " Description: plugin for NERD Tree that provides an execute file menu item
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
    1              0.000005 if exists("g:loaded_nerdtree_exec_menuitem")
                                finish
                            endif
    1              0.000002 let g:loaded_nerdtree_exec_menuitem = 1
                            
    1   0.000064   0.000014 call NERDTreeAddMenuItem({
                                        \ 'text': '(!)Execute file',
                                        \ 'shortcut': '!',
                                        \ 'callback': 'NERDTreeExecFile',
                                        \ 'isActiveCallback': 'NERDTreeExecFileActive' })
                            
    1              0.000002 function! NERDTreeExecFileActive()
                                let node = g:NERDTreeFileNode.GetSelected()
                                return !node.path.isDirectory && node.path.isExecutable
                            endfunction
                            
    1              0.000001 function! NERDTreeExecFile()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                echo "==========================================================\n"
                                echo "Complete the command to execute (add arguments etc):\n"
                                let cmd = treenode.path.str({'escape': 1})
                                let cmd = input(':!', cmd . ' ')
                            
                                if cmd != ''
                                    exec ':!' . cmd
                                else
                                    echo "Aborted"
                                endif
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim
Sourced 1 time
Total time:   0.000768
 Self time:   0.000384

count  total (s)   self (s)
                            " ============================================================================
                            " File:        fs_menu.vim
                            " Description: plugin for the NERD Tree that provides a file system menu
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
    1              0.000004 if exists("g:loaded_nerdtree_fs_menu")
                                finish
                            endif
    1              0.000002 let g:loaded_nerdtree_fs_menu = 1
                            
                            "Automatically delete the buffer after deleting or renaming a file
    1              0.000002 if !exists("g:NERDTreeAutoDeleteBuffer")
    1              0.000002     let g:NERDTreeAutoDeleteBuffer = 0
    1              0.000001 endif
                            
    1   0.000048   0.000006 call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
    1   0.000043   0.000005 call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
    1   0.000123   0.000005 call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})
                            
    1              0.000006 if has("gui_mac") || has("gui_macvim") || has("mac")
    1   0.000041   0.000005     call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
    1   0.000039   0.000005     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
    1   0.000043   0.000005     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
    1              0.000003 endif
                            
    1              0.000079 if executable("xdg-open")
                                call NERDTreeAddMenuItem({'text': '(r)eveal the current node in file manager', 'shortcut': 'r', 'callback': 'NERDTreeRevealFileLinux'})
                                call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileLinux'})
                            endif
                            
    1   0.000010   0.000005 if g:NERDTreePath.CopyingSupported()
    1   0.000043   0.000005     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
    1              0.000001 endif
                            
    1              0.000002 if has("unix") || has("osx")
    1   0.000040   0.000005     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})
    1              0.000001 else
                                call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})
                            endif
                            
                            "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
                            "prints out the given msg and, if the user responds by pushing 'y' then the
                            "buffer with the given bufnum is deleted
                            "
                            "Args:
                            "bufnum: the buffer that may be deleted
                            "msg: a message that will be echoed to the user asking them if they wish to
                            "     del the buffer
    1              0.000003 function! s:promptToDelBuffer(bufnum, msg)
                                echo a:msg
                                if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
                                    " 1. ensure that all windows which display the just deleted filename
                                    " now display an empty buffer (so a layout is preserved).
                                    " Is not it better to close single tabs with this file only ?
                                    let s:originalTabNumber = tabpagenr()
                                    let s:originalWindowNumber = winnr()
                                    " Go to the next buffer in buffer list if at least one extra buffer is listed
                                    " Otherwise open a new empty buffer
                                    if v:version >= 800
                                        let l:listedBufferCount = len(getbufinfo({'buflisted':1}))
                                    elseif v:version >= 702
                                        let l:listedBufferCount = len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))
                                    else
                                        " Ignore buffer count in this case to make sure we keep the old
                                        " behavior
                                        let l:listedBufferCount = 0
                                    endif
                                    if l:listedBufferCount > 1
                                        exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':bnext! ' | endif"
                                    else
                                        exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':enew! ' | endif"
                                    endif
                                    exec "tabnext " . s:originalTabNumber
                                    exec s:originalWindowNumber . "wincmd w"
                                    " 3. We don't need a previous buffer anymore
                                    exec "bwipeout! " . a:bufnum
                                endif
                            endfunction
                            
                            "FUNCTION: s:promptToRenameBuffer(bufnum, msg){{{1
                            "prints out the given msg and, if the user responds by pushing 'y' then the
                            "buffer with the given bufnum is replaced with a new one
                            "
                            "Args:
                            "bufnum: the buffer that may be deleted
                            "msg: a message that will be echoed to the user asking them if they wish to
                            "     del the buffer
    1              0.000002 function! s:promptToRenameBuffer(bufnum, msg, newFileName)
                                echo a:msg
                                if g:NERDTreeAutoDeleteBuffer || nr2char(getchar()) ==# 'y'
                                    let quotedFileName = fnameescape(a:newFileName)
                                    " 1. ensure that a new buffer is loaded
                                    exec "badd " . quotedFileName
                                    " 2. ensure that all windows which display the just deleted filename
                                    " display a buffer for a new filename.
                                    let s:originalTabNumber = tabpagenr()
                                    let s:originalWindowNumber = winnr()
                                    let editStr = g:NERDTreePath.New(a:newFileName).str({'format': 'Edit'})
                                    exec "tabdo windo if winbufnr(0) == " . a:bufnum . " | exec ':e! " . editStr . "' | endif"
                                    exec "tabnext " . s:originalTabNumber
                                    exec s:originalWindowNumber . "wincmd w"
                                    " 3. We don't need a previous buffer anymore
                                    exec "bwipeout! " . a:bufnum
                                endif
                            endfunction
                            "FUNCTION: NERDTreeAddNode(){{{1
    1              0.000001 function! NERDTreeAddNode()
                                let curDirNode = g:NERDTreeDirNode.GetSelected()
                            
                                let newNodeName = input("Add a childnode\n".
                                                      \ "==========================================================\n".
                                                      \ "Enter the dir/file name to be created. Dirs end with a '/'\n" .
                                                      \ "", curDirNode.path.str() . g:NERDTreePath.Slash(), "file")
                            
                                if newNodeName ==# ''
                                    call nerdtree#echo("Node Creation Aborted.")
                                    return
                                endif
                            
                                try
                                    let newPath = g:NERDTreePath.Create(newNodeName)
                                    let parentNode = b:NERDTree.root.findNode(newPath.getParent())
                            
                                    let newTreeNode = g:NERDTreeFileNode.New(newPath, b:NERDTree)
                                    if empty(parentNode)
                                        call b:NERDTree.root.refresh()
                                        call b:NERDTree.render()
                                    elseif parentNode.isOpen || !empty(parentNode.children)
                                        call parentNode.addChild(newTreeNode, 1)
                                        call NERDTreeRender()
                                        call newTreeNode.putCursorHere(1, 0)
                                    endif
                                catch /^NERDTree/
                                    call nerdtree#echoWarning("Node Not Created.")
                                endtry
                            endfunction
                            
                            "FUNCTION: NERDTreeMoveNode(){{{1
    1              0.000001 function! NERDTreeMoveNode()
                                let curNode = g:NERDTreeFileNode.GetSelected()
                                let newNodePath = input("Rename the current node\n" .
                                                      \ "==========================================================\n" .
                                                      \ "Enter the new path for the node:                          \n" .
                                                      \ "", curNode.path.str(), "file")
                            
                                if newNodePath ==# ''
                                    call nerdtree#echo("Node Renaming Aborted.")
                                    return
                                endif
                            
                                try
                                    let bufnum = bufnr("^".curNode.path.str()."$")
                            
                                    call curNode.rename(newNodePath)
                                    call b:NERDTree.root.refresh()
                                    call NERDTreeRender()
                            
                                    "if the node is open in a buffer, ask the user if they want to
                                    "close that buffer
                                    if bufnum != -1
                                        let prompt = "\nNode renamed.\n\nThe old file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Replace this buffer with the new file? (yN)"
                                        call s:promptToRenameBuffer(bufnum,  prompt, newNodePath)
                                    endif
                            
                                    call curNode.putCursorHere(1, 0)
                            
                                    redraw
                                catch /^NERDTree/
                                    call nerdtree#echoWarning("Node Not Renamed.")
                                endtry
                            endfunction
                            
                            " FUNCTION: NERDTreeDeleteNode() {{{1
    1              0.000001 function! NERDTreeDeleteNode()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                let confirmed = 0
                            
                                if currentNode.path.isDirectory && ((currentNode.isOpen && currentNode.getChildCount() > 0) ||
                                                                  \ (len(currentNode._glob('*', 1)) > 0))
                                    let choice =input("Delete the current node\n" .
                                                     \ "==========================================================\n" .
                                                     \ "STOP! Directory is not empty! To delete, type 'yes'\n" .
                                                     \ "" . currentNode.path.str() . ": ")
                                    let confirmed = choice ==# 'yes'
                                else
                                    echo "Delete the current node\n" .
                                       \ "==========================================================\n".
                                       \ "Are you sure you wish to delete the node:\n" .
                                       \ "" . currentNode.path.str() . " (yN):"
                                    let choice = nr2char(getchar())
                                    let confirmed = choice ==# 'y'
                                endif
                            
                            
                                if confirmed
                                    try
                                        call currentNode.delete()
                                        call NERDTreeRender()
                            
                                        "if the node is open in a buffer, ask the user if they want to
                                        "close that buffer
                                        let bufnum = bufnr("^".currentNode.path.str()."$")
                                        if buflisted(bufnum)
                                            let prompt = "\nNode deleted.\n\nThe file is open in buffer ". bufnum . (bufwinnr(bufnum) ==# -1 ? " (hidden)" : "") .". Delete this buffer? (yN)"
                                            call s:promptToDelBuffer(bufnum, prompt)
                                        endif
                            
                                        redraw
                                    catch /^NERDTree/
                                        call nerdtree#echoWarning("Could not remove node")
                                    endtry
                                else
                                    call nerdtree#echo("delete aborted")
                                endif
                            
                            endfunction
                            
                            " FUNCTION: NERDTreeListNode() {{{1
    1              0.000001 function! NERDTreeListNode()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                if !empty(treenode)
                                    let s:uname = system("uname")
                                    let stat_cmd = 'stat -c "%s" ' 
                                    
                                    if s:uname =~? "Darwin"                
                                        let stat_cmd = 'stat -f "%z" '
                                    endif
                            
                                    let cmd = 'size=$(' . stat_cmd . shellescape(treenode.path.str()) . ') && ' .
                                    \         'size_with_commas=$(echo $size | sed -e :a -e "s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta") && ' .
                                    \         'ls -ld ' . shellescape(treenode.path.str()) . ' | sed -e "s/ $size / $size_with_commas /"'
                            
                                    let metadata = split(system(cmd),'\n')
                                    call nerdtree#echo(metadata[0])
                                else
                                    call nerdtree#echo("No information available")
                                endif
                            endfunction
                            
                            " FUNCTION: NERDTreeListNodeWin32() {{{1
    1              0.000001 function! NERDTreeListNodeWin32()
                                let l:node = g:NERDTreeFileNode.GetSelected()
                            
                                if !empty(l:node)
                            
                                    let l:save_shell = &shell
                                    set shell&
                            
                                    if exists('+shellslash')
                                        let l:save_shellslash = &shellslash
                                        set noshellslash
                                    endif
                            
                                    let l:command = 'DIR /Q '
                                                \ . shellescape(l:node.path.str())
                                                \ . ' | FINDSTR "^[012][0-9]/[0-3][0-9]/[12][0-9][0-9][0-9]"'
                            
                                    let l:metadata = split(system(l:command), "\n")
                            
                                    if v:shell_error == 0
                                        call nerdtree#echo(l:metadata[0])
                                    else
                                        call nerdtree#echoError('shell command failed')
                                    endif
                            
                                    let &shell = l:save_shell
                            
                                    if exists('l:save_shellslash')
                                        let &shellslash = l:save_shellslash
                                    endif
                            
                                    return
                                endif
                            
                                call nerdtree#echo('node not recognized')
                            endfunction
                            
                            " FUNCTION: NERDTreeCopyNode() {{{1
    1              0.000001 function! NERDTreeCopyNode()
                                let currentNode = g:NERDTreeFileNode.GetSelected()
                                let newNodePath = input("Copy the current node\n" .
                                                      \ "==========================================================\n" .
                                                      \ "Enter the new path to copy the node to:                   \n" .
                                                      \ "", currentNode.path.str(), "file")
                            
                                if newNodePath != ""
                                    "strip trailing slash
                                    let newNodePath = substitute(newNodePath, '\/$', '', '')
                            
                                    let confirmed = 1
                                    if currentNode.path.copyingWillOverwrite(newNodePath)
                                        call nerdtree#echo("Warning: copying may overwrite files! Continue? (yN)")
                                        let choice = nr2char(getchar())
                                        let confirmed = choice ==# 'y'
                                    endif
                            
                                    if confirmed
                                        try
                                            let newNode = currentNode.copy(newNodePath)
                                            if empty(newNode)
                                                call b:NERDTree.root.refresh()
                                                call b:NERDTree.render()
                                            else
                                                call NERDTreeRender()
                                                call newNode.putCursorHere(0, 0)
                                            endif
                                        catch /^NERDTree/
                                            call nerdtree#echoWarning("Could not copy node")
                                        endtry
                                    endif
                                else
                                    call nerdtree#echo("Copy aborted.")
                                endif
                                redraw
                            endfunction
                            
                            " FUNCTION: NERDTreeQuickLook() {{{1
    1              0.000001 function! NERDTreeQuickLook()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                if treenode != {}
                                    call system("qlmanage -p 2>/dev/null '" . treenode.path.str() . "'")
                                endif
                            endfunction
                            
                            " FUNCTION: NERDTreeRevealInFinder() {{{1
    1              0.000001 function! NERDTreeRevealInFinder()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                if treenode != {}
                                    call system("open -R '" . treenode.path.str() . "'")
                                endif
                            endfunction
                            
                            " FUNCTION: NERDTreeExecuteFile() {{{1
    1              0.000001 function! NERDTreeExecuteFile()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                if treenode != {}
                                    call system("open '" . treenode.path.str() . "'")
                                endif
                            endfunction
                            
                            " FUNCTION: NERDTreeRevealFileLinux() {{{1
    1              0.000001 function! NERDTreeRevealFileLinux()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                let parentnode = treenode.parent
                                if parentnode != {}
                                    call system("xdg-open '" . parentnode.path.str() . "' &")
                                endif
                            endfunction
                            
                            " FUNCTION: NERDTreeExecuteFileLinux() {{{1
    1              0.000001 function! NERDTreeExecuteFileLinux()
                                let treenode = g:NERDTreeFileNode.GetSelected()
                                if treenode != {}
                                    call system("xdg-open '" . treenode.path.str() . "' &")
                                endif
                            endfunction
                            
                            " vim: set sw=4 sts=4 et fdm=marker:
                            

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/neomake/plugin/neomake.vim
Sourced 1 time
Total time:   0.000253
 Self time:   0.000190

count  total (s)   self (s)
    1              0.000006 if exists('g:loaded_neomake') || &compatible
                                finish
                            endif
    1              0.000002 let g:loaded_neomake = 1
                            
    1              0.000007 command! -nargs=* -bang -bar -complete=customlist,neomake#cmd#complete_makers
                                        \ Neomake call neomake#Make(<bang>1, [<f-args>])
                            
                            " These commands are available for clarity
    1              0.000004 command! -nargs=* -bar -complete=customlist,neomake#cmd#complete_makers
                                        \ NeomakeProject Neomake! <args>
    1              0.000006 command! -nargs=* -bar -complete=customlist,neomake#cmd#complete_makers
                                        \ NeomakeFile Neomake <args>
                            
    1              0.000005 command! -nargs=+ -bang -complete=shellcmd
                                        \ NeomakeSh call neomake#ShCommand(<bang>0, <q-args>)
    1              0.000002 command! NeomakeListJobs call neomake#ListJobs()
    1              0.000005 command! -bang -nargs=1 -complete=custom,neomake#cmd#complete_jobs
                                        \ NeomakeCancelJob call neomake#CancelJob(<q-args>, <bang>0)
    1              0.000003 command! -bang NeomakeCancelJobs call neomake#CancelJobs(<bang>0)
                            
    1              0.000005 command! -bang -bar -nargs=? -complete=customlist,neomake#cmd#complete_makers
                                        \ NeomakeInfo call neomake#debug#display_info(<bang>0, <f-args>)
                            
                            " Enable/disable/toggle commands.  {{{
    1              0.000003 function! s:handle_disabled_status(scope, disabled, verbose) abort
                                if a:scope is# g:
                                    if a:disabled
                                        if exists('#neomake')
                                            autocmd! neomake
                                            augroup! neomake
                                        endif
                                        call neomake#configure#disable_automake()
                                    else
                                        call s:setup_autocmds()
                                    endif
                                elseif a:scope is# t:
                                    let tab = tabpagenr()
                                    let buffers = neomake#compat#uniq(sort(tabpagebuflist()))
                                    if a:disabled
                                        for b in buffers
                                            call neomake#configure#disable_automake_for_buffer(b)
                                        endfor
                                    else
                                        for b in buffers
                                            call neomake#configure#enable_automake_for_buffer(b)
                                        endfor
                                    endif
                                elseif a:scope is# b:
                                    let bufnr = bufnr('%')
                                    if a:disabled
                                        call neomake#configure#disable_automake_for_buffer(bufnr)
                                    else
                                        call neomake#configure#enable_automake_for_buffer(bufnr)
                                    endif
                                endif
                                call s:display_status()
                                call neomake#configure#automake()
                                call neomake#statusline#clear_cache()
                            endfunction
                            
    1              0.000002 function! s:disable(scope) abort
                                let old = get(get(a:scope, 'neomake', {}), 'disabled', -1)
                                if old ==# 1
                                    return
                                endif
                                call neomake#config#set_dict(a:scope, 'neomake.disabled', 1)
                                call s:handle_disabled_status(a:scope, 1, &verbose)
                            endfunction
                            
    1              0.000001 function! s:enable(scope) abort
                                let old = get(get(a:scope, 'neomake', {}), 'disabled', -1)
                                if old != 1
                                    return
                                endif
                                call neomake#config#set_dict(a:scope, 'neomake.disabled', 0)
                                call s:handle_disabled_status(a:scope, 0, &verbose)
                            endfunction
                            
    1              0.000001 function! s:toggle(scope) abort
                                let new = !get(get(a:scope, 'neomake', {}), 'disabled', 0)
                                if new
                                    call neomake#config#set_dict(a:scope, 'neomake.disabled', 1)
                                    call s:handle_disabled_status(a:scope, 1, 1)
                                else
                                    call neomake#config#unset_dict(a:scope, 'neomake.disabled')
                                    call s:handle_disabled_status(a:scope, 0, 1)
                                endif
                            endfunction
                            
    1              0.000001 function! s:display_status() abort
                                let [disabled, source] = neomake#config#get_with_source('disabled', 0)
                                let msg = 'Neomake is ' . (disabled ? 'disabled' : 'enabled')
                                if source !=# 'default'
                                    let msg .= ' ('.source.')'
                                endif
                            
                                " Add information from different scopes (if explicitly configured there).
                                for [scope_name, scope] in [['buffer', b:], ['tab', t:], ['global', g:]]
                                    if scope_name ==# source
                                        continue
                                    endif
                                    let disabled = get(get(scope, 'neomake', {}), 'disabled', -1)
                                    if disabled != -1
                                        let msg .= printf(' [%s: %s]', scope_name, disabled ? 'disabled' : 'enabled')
                                    endif
                                endfor
                                let msg .= '.'
                            
                                echom msg
                                call neomake#log#debug(msg)
                            endfunction
                            
    1              0.000003 command! -bar NeomakeToggle call s:toggle(g:)
    1              0.000002 command! -bar NeomakeToggleBuffer call s:toggle(b:)
    1              0.000002 command! -bar NeomakeToggleTab call s:toggle(t:)
    1              0.000002 command! -bar NeomakeDisable call s:disable(g:)
    1              0.000002 command! -bar NeomakeDisableBuffer call s:disable(b:)
    1              0.000002 command! -bar NeomakeDisableTab call s:disable(t:)
    1              0.000002 command! -bar NeomakeEnable call s:enable(g:)
    1              0.000002 command! -bar NeomakeEnableBuffer call s:enable(b:)
    1              0.000002 command! -bar NeomakeEnableTab call s:enable(t:)
                            
    1              0.000002 command! NeomakeStatus call s:display_status()
                            " }}}
                            
    1              0.000001 function! s:define_highlights() abort
                                if g:neomake_place_signs
                                    call neomake#signs#DefineHighlights()
                                endif
                                if get(g:, 'neomake_highlight_columns', 1)
                                            \ || get(g:, 'neomake_highlight_lines', 0)
                                    call neomake#highlights#DefineHighlights()
                                endif
                            endfunction
                            
    1              0.000001 function! s:setup_autocmds() abort
                                augroup neomake
                                    au!
                                    if !exists('*nvim_buf_add_highlight')
                                        autocmd BufEnter * call neomake#highlights#ShowHighlights()
                                    endif
                                    if has('timers')
                                        autocmd CursorMoved * call neomake#CursorMovedDelayed()
                                        " Force-redraw display of current error after resizing Vim, which appears
                                        " to clear the previously echoed error.
                                        autocmd VimResized * call timer_start(100, function('neomake#EchoCurrentError'))
                                    else
                                        autocmd CursorMoved * call neomake#CursorMoved()
                                    endif
                                    autocmd VimLeave * call neomake#VimLeave()
                                    autocmd ColorScheme * call s:define_highlights()
                                augroup END
                            endfunction
                            
    1              0.000003 if has('signs')
    1              0.000004     let g:neomake_place_signs = get(g:, 'neomake_place_signs', 1)
    1              0.000001 else
                                let g:neomake_place_signs = 0
                                lockvar g:neomake_place_signs
                            endif
                            
    1   0.000072   0.000009 call s:setup_autocmds()
                            
                            " vim: sw=4 et

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/deoplete.nvim/plugin/deoplete.vim
Sourced 1 time
Total time:   0.000338
 Self time:   0.000192

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: deoplete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000004 if exists('g:loaded_deoplete')
                              finish
                            endif
    1              0.000002 let g:loaded_deoplete = 1
                            
                            " Global options definition.
    1              0.000003 if get(g:, 'deoplete#enable_at_startup', 0)
    1   0.000313   0.000167   call deoplete#enable()
    1              0.000004 endif

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/deoplete.nvim/autoload/deoplete.vim
Sourced 1 time
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: deoplete.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000003 function! deoplete#initialize() abort
                              return deoplete#init#_initialize()
                            endfunction
    1              0.000001 function! deoplete#is_enabled() abort
                              return deoplete#init#_is_handler_enabled()
                            endfunction
    1              0.000001 function! deoplete#enable() abort
                              if has('vim_starting')
                                augroup deoplete
                                  autocmd!
                                  autocmd VimEnter * call deoplete#enable()
                                augroup END
                                return 1
                              endif
                            
                              if deoplete#initialize() && deoplete#is_enabled()
                                return 1
                              endif
                              return deoplete#init#_enable_handler()
                            endfunction
    1              0.000001 function! deoplete#disable() abort
                              call deoplete#initialize()
                              return deoplete#init#_disable_handler()
                            endfunction
    1              0.000001 function! deoplete#toggle() abort
                              call deoplete#initialize()
                              return deoplete#is_enabled() ?
                                    \ deoplete#init#_disable_handler() :
                                    \ deoplete#init#_enable_handler()
                            endfunction
                            
    1              0.000002 function! deoplete#enable_logging(level, logfile) abort
                              let g:deoplete#_logging = {'level': a:level, 'logfile': a:logfile}
                              call deoplete#util#rpcnotify('deoplete_enable_logging', {})
                            endfunction
                            
    1              0.000002 function! deoplete#send_event(event, ...) abort
                              let sources = get(a:000, 0, [])
                              call deoplete#util#rpcnotify('deoplete_on_event',
                                    \ deoplete#init#_context(a:event, sources))
                            endfunction
                            
    1              0.000003 function! deoplete#manual_complete(...) abort
                              if !deoplete#is_enabled()
                                return ''
                              endif
                            
                              " Start complete.
                              return "\<C-r>=deoplete#mapping#_rpcrequest_wrapper("
                                    \ . string(get(a:000, 0, [])) . ")\<CR>"
                            endfunction
    1              0.000001 function! deoplete#close_popup() abort
                              call deoplete#handler#_skip_next_completion()
                              return pumvisible() ? "\<C-y>" : ''
                            endfunction
    1              0.000002 function! deoplete#smart_close_popup() abort
                              call deoplete#handler#_skip_next_completion()
                              return pumvisible() ? "\<C-e>" : ''
                            endfunction
    1              0.000001 function! deoplete#cancel_popup() abort
                              call deoplete#handler#_skip_next_completion()
                              return pumvisible() ? "\<C-e>" : ''
                            endfunction
    1              0.000001 function! deoplete#refresh() abort
                              if exists('g:deoplete#_context')
                                if get(g:deoplete#_context, 'event', '') ==# 'Manual'
                                  let g:deoplete#_context.event = 'Refresh'
                                endif
                              endif
                              return pumvisible() ? "\<C-e>" : ''
                            endfunction
    1              0.000001 function! deoplete#undo_completion() abort
                              return deoplete#mapping#_undo_completion()
                            endfunction
    1              0.000003 function! deoplete#complete_common_string() abort
                              return deoplete#mapping#_complete_common_string()
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/gzip.vim
Sourced 1 time
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2016 Oct 30
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000009 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
                            endif
    1              0.000002 let loaded_gzip = 1
                            
    1              0.000001 augroup gzip
                              " Remove all gzip autocommands
    1              0.000032   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000028   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
    1              0.000005   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000008   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000007   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000003   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000005   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000003   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000002   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000003   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000002   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000002   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000002   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000002   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000005   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000003   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000002   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000002   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000002   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000002   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000003 augroup END

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/health.vim
Sourced 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000010 autocmd CmdUndefined CheckHealth checkhealth

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/man.vim
Sourced 1 time
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
                            " Maintainer: Anmol Sethi <anmol@aubble.com>
                            
    1              0.000003 if exists('g:loaded_man')
                              finish
                            endif
    1              0.000002 let g:loaded_man = 1
                            
    1              0.000007 command! -bar -range=0 -complete=customlist,man#complete -nargs=* Man call man#open_page(v:count, v:count1, <q-mods>, <f-args>)
                            
    1              0.000001 augroup man
    1              0.000033   autocmd!
    1              0.000005   autocmd BufReadCmd man://* call man#read_page(matchstr(expand('<amatch>'), 'man://\zs.*'))
    1              0.000004 augroup END

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/matchit.vim
Sourced 1 time
Total time:   0.000563
 Self time:   0.000563

count  total (s)   self (s)
                            "  matchit.vim: (global plugin) Extended "%" matching
                            "  Last Change: 2017 Sep 15
                            "  Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
                            "  Version:     1.13.3, for Vim 6.3+
                            "		Fix from Tommy Allen included.
                            "		Fix from Fernando Torres included.
                            "		Improvement from Ken Takata included.
                            "  URL:		http://www.vim.org/script.php?script_id=39
                            
                            " Documentation:
                            "  The documentation is in a separate file, matchit.txt .
                            
                            " Credits:
                            "  Vim editor by Bram Moolenaar (Thanks, Bram!)
                            "  Original script and design by Raul Segura Acevedo
                            "  Support for comments by Douglas Potts
                            "  Support for back references and other improvements by Benji Fisher
                            "  Support for many languages by Johannes Zellner
                            "  Suggestions for improvement, bug reports, and support for additional
                            "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
                            "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
                            
                            " Debugging:
                            "  If you'd like to try the built-in debugging commands...
                            "   :MatchDebug      to activate debugging for the current buffer
                            "  This saves the values of several key script variables as buffer-local
                            "  variables.  See the MatchDebug() function, below, for details.
                            
                            " TODO:  I should think about multi-line patterns for b:match_words.
                            "   This would require an option:  how many lines to scan (default 1).
                            "   This would be useful for Python, maybe also for *ML.
                            " TODO:  Maybe I should add a menu so that people will actually use some of
                            "   the features that I have implemented.
                            " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
                            "   Match_wrapper() instead.
                            " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                            " TODO:  Make backrefs safer by using '\V' (very no-magic).
                            " TODO:  Add a level of indirection, so that custom % scripts can use my
                            "   work but extend it.
                            
                            " allow user to prevent loading
                            " and prevent duplicate loading
    1              0.000005 if exists("loaded_matchit") || &cp
                              finish
                            endif
    1              0.000002 let loaded_matchit = 1
    1              0.000001 let s:last_mps = ""
    1              0.000001 let s:last_words = ":"
    1              0.000001 let s:patBR = ""
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000008 nnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'n') <CR>
    1              0.000005 nnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'n') <CR>
    1              0.000005 vnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'v') <CR>m'gv``
    1              0.000004 vnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'v') <CR>m'gv``
    1              0.000004 onoremap <silent> %  v:<C-U>call <SID>Match_wrapper('',1,'o') <CR>
    1              0.000004 onoremap <silent> g% v:<C-U>call <SID>Match_wrapper('',0,'o') <CR>
                            
                            " Analogues of [{ and ]} using matching patterns:
    1              0.000004 nnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "n") <CR>
    1              0.000004 nnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "n") <CR>
    1              0.000003 vmap [% <Esc>[%m'gv``
    1              0.000003 vmap ]% <Esc>]%m'gv``
                            " vnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "v") <CR>m'gv``
                            " vnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "v") <CR>m'gv``
    1              0.000007 onoremap <silent> [% v:<C-U>call <SID>MultiMatch("bW", "o") <CR>
    1              0.000005 onoremap <silent> ]% v:<C-U>call <SID>MultiMatch("W",  "o") <CR>
                            
                            " text object:
    1              0.000003 vmap a% <Esc>[%v]%
                            
                            " Auto-complete mappings:  (not yet "ready for prime time")
                            " TODO Read :help write-plugin for the "right" way to let the user
                            " specify a key binding.
                            "   let g:match_auto = '<C-]>'
                            "   let g:match_autoCR = '<C-CR>'
                            " if exists("g:match_auto")
                            "   execute "inoremap " . g:match_auto . ' x<Esc>"=<SID>Autocomplete()<CR>Pls'
                            " endif
                            " if exists("g:match_autoCR")
                            "   execute "inoremap " . g:match_autoCR . ' <CR><C-R>=<SID>Autocomplete()<CR>'
                            " endif
                            " if exists("g:match_gthhoh")
                            "   execute "inoremap " . g:match_gthhoh . ' <C-O>:call <SID>Gthhoh()<CR>'
                            " endif " gthhoh = "Get the heck out of here!"
                            
    1              0.000002 let s:notslash = '\\\@<!\%(\\\\\)*'
                            
    1              0.000003 function! s:Match_wrapper(word, forward, mode) range
                              " In s:CleanUp(), :execute "set" restore_options .
                              let restore_options = ""
                              if exists("b:match_ignorecase") && b:match_ignorecase != &ic
                                let restore_options .= (&ic ? " " : " no") . "ignorecase"
                                let &ignorecase = b:match_ignorecase
                              endif
                              if &ve != ''
                                let restore_options = " ve=" . &ve . restore_options
                                set ve=
                              endif
                              " If this function was called from Visual mode, make sure that the cursor
                              " is at the correct end of the Visual range:
                              if a:mode == "v"
                                execute "normal! gv\<Esc>"
                              endif
                              " In s:CleanUp(), we may need to check whether the cursor moved forward.
                              let startline = line(".")
                              let startcol = col(".")
                              " Use default behavior if called with a count.
                              if v:count
                                exe "normal! " . v:count . "%"
                                return s:CleanUp(restore_options, a:mode, startline, startcol)
                              end
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              "
                              if !exists("b:match_words") || b:match_words == ""
                                let match_words = ""
                                " Allow b:match_words = "GetVimMatchWords()" .
                              elseif b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                            " Thanks to Preben "Peppe" Guldberg and Bram Moolenaar for this suggestion!
                              if (match_words != s:last_words) || (&mps != s:last_mps)
                                  \ || exists("b:match_debug")
                                let s:last_mps = &mps
                                " The next several lines were here before
                                " BF started messing with this script.
                                " quote the special chars in 'matchpairs', replace [,:] with \| and then
                                " append the builtin pairs (/*, */, #if, #ifdef, #else, #elif, #endif)
                                " let default = substitute(escape(&mps, '[$^.*~\\/?]'), '[,:]\+',
                                "  \ '\\|', 'g').'\|\/\*\|\*\/\|#if\>\|#ifdef\>\|#else\>\|#elif\>\|#endif\>'
                                let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") .
                                  \ '\/\*:\*\/,#\s*if\%(def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                                " s:all = pattern with all the keywords
                                let match_words = match_words . (strlen(match_words) ? "," : "") . default
                                let s:last_words = match_words
                                if match_words !~ s:notslash . '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = substitute(s:pat, s:notslash . '\zs[,:]\+', '\\|', 'g')
                                let s:all = '\%(' . s:all . '\)'
                                " let s:all = '\%(' . substitute(s:all, '\\\ze[,:]', '', 'g') . '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                                " Reconstruct the version with unresolved backrefs.
                                let s:patBR = substitute(match_words.',',
                                  \ s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
                                let s:patBR = substitute(s:patBR, s:notslash.'\zs:\{2,}', ':', 'g')
                              endif
                            
                              " Second step:  set the following local variables:
                              "     matchline = line on which the cursor started
                              "     curcol    = number of characters before match
                              "     prefix    = regexp for start of line to start of match
                              "     suffix    = regexp for end of match to end of line
                              " Require match to end on or after the cursor and prefer it to
                              " start on or before the cursor.
                              let matchline = getline(startline)
                              if a:word != ''
                                " word given
                                if a:word !~ s:all
                                  echohl WarningMsg|echo 'Missing rule for word:"'.a:word.'"'|echohl NONE
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let matchline = a:word
                                let curcol = 0
                                let prefix = '^\%('
                                let suffix = '\)$'
                              " Now the case when "word" is not given
                              else	" Find the match that ends on or after the cursor and set curcol.
                                let regexp = s:Wholematch(matchline, s:all, startcol-1)
                                let curcol = match(matchline, regexp)
                                " If there is no match, give up.
                                if curcol == -1
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let endcol = matchend(matchline, regexp)
                                let suf = strlen(matchline) - endcol
                                let prefix = (curcol ? '^.*\%'  . (curcol + 1) . 'c\%(' : '^\%(')
                                let suffix = (suf ? '\)\%' . (endcol + 1) . 'c.*$'  : '\)$')
                              endif
                              if exists("b:match_debug")
                                let b:match_match = matchstr(matchline, regexp)
                                let b:match_col = curcol+1
                              endif
                            
                              " Third step:  Find the group and single word that match, and the original
                              " (backref) versions of these.  Then, resolve the backrefs.
                              " Set the following local variable:
                              " group = colon-separated list of patterns, one of which matches
                              "       = ini:mid:fin or ini:fin
                              "
                              " Now, set group and groupBR to the matching group: 'if:endif' or
                              " 'while:endwhile' or whatever.  A bit of a kluge:  s:Choose() returns
                              " group . "," . groupBR, and we pick it apart.
                              let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, s:patBR)
                              let i = matchend(group, s:notslash . ",")
                              let groupBR = strpart(group, i)
                              let group = strpart(group, 0, i-1)
                              " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
                              if s:do_BR " Do the hard part:  resolve those backrefs!
                                let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              endif
                              if exists("b:match_debug")
                                let b:match_wholeBR = groupBR
                                let i = matchend(groupBR, s:notslash . ":")
                                let b:match_iniBR = strpart(groupBR, 0, i-1)
                              endif
                            
                              " Fourth step:  Set the arguments for searchpair().
                              let i = matchend(group, s:notslash . ":")
                              let j = matchend(group, '.*' . s:notslash . ":")
                              let ini = strpart(group, 0, i-1)
                              let mid = substitute(strpart(group, i,j-i-1), s:notslash.'\zs:', '\\|', 'g')
                              let fin = strpart(group, j)
                              "Un-escape the remaining , and : characters.
                              let ini = substitute(ini, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              let mid = substitute(mid, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              let fin = substitute(fin, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              " searchpair() requires that these patterns avoid \(\) groups.
                              let ini = substitute(ini, s:notslash . '\zs\\(', '\\%(', 'g')
                              let mid = substitute(mid, s:notslash . '\zs\\(', '\\%(', 'g')
                              let fin = substitute(fin, s:notslash . '\zs\\(', '\\%(', 'g')
                              " Set mid.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix . fin . suffix
                                \ || !a:forward && matchline =~ prefix . ini . suffix
                                let mid = ""
                              endif
                              " Set flag.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix . fin . suffix
                                \ || !a:forward && matchline !~ prefix . ini . suffix
                                let flag = "bW"
                              else
                                let flag = "W"
                              endif
                              " Set skip.
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              if exists("b:match_debug")
                                let b:match_ini = ini
                                let b:match_tail = (strlen(mid) ? mid.'\|' : '') . fin
                              endif
                            
                              " Fifth step:  actually start moving the cursor and call searchpair().
                              " Later, :execute restore_cursor to get to the original screen.
                              let view = winsaveview()
                              call cursor(0, curcol + 1)
                              " normal! 0
                              " if curcol
                              "   execute "normal!" . curcol . "l"
                              " endif
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = "0"
                              else
                                execute "if " . skip . "| let skip = '0' | endif"
                              endif
                              let sp_return = searchpair(ini, mid, fin, flag, skip)
                              let final_position = "call cursor(" . line(".") . "," . col(".") . ")"
                              " Restore cursor position and original screen.
                              call winrestview(view)
                              normal! m'
                              if sp_return > 0
                                execute final_position
                              endif
                              return s:CleanUp(restore_options, a:mode, startline, startcol, mid.'\|'.fin)
                            endfun
                            
                            " Restore options and do some special handling for Operator-pending mode.
                            " The optional argument is the tail of the matching group.
    1              0.000003 fun! s:CleanUp(options, mode, startline, startcol, ...)
                              if strlen(a:options)
                                execute "set" a:options
                              endif
                              " Open folds, if appropriate.
                              if a:mode != "o"
                                if &foldopen =~ "percent"
                                  normal! zv
                                endif
                                " In Operator-pending mode, we want to include the whole match
                                " (for example, d%).
                                " This is only a problem if we end up moving in the forward direction.
                              elseif (a:startline < line(".")) ||
                            	\ (a:startline == line(".") && a:startcol < col("."))
                                if a:0
                                  " Check whether the match is a single character.  If not, move to the
                                  " end of the match.
                                  let matchline = getline(".")
                                  let currcol = col(".")
                                  let regexp = s:Wholematch(matchline, a:1, currcol-1)
                                  let endcol = matchend(matchline, regexp)
                                  if endcol > currcol  " This is NOT off by one!
                            	call cursor(0, endcol)
                                  endif
                                endif " a:0
                              endif " a:mode != "o" && etc.
                              return 0
                            endfun
                            
                            " Example (simplified HTML patterns):  if
                            "   a:groupBR	= '<\(\k\+\)>:</\1>'
                            "   a:prefix	= '^.\{3}\('
                            "   a:group	= '<\(\k\+\)>:</\(\k\+\)>'
                            "   a:suffix	= '\).\{2}$'
                            "   a:matchline	=  "123<tag>12" or "123</tag>12"
                            " then extract "tag" from a:matchline and return "<tag>:</tag>" .
    1              0.000002 fun! s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              if a:matchline !~ a:prefix .
                                \ substitute(a:group, s:notslash . '\zs:', '\\|', 'g') . a:suffix
                                return a:group
                              endif
                              let i = matchend(a:groupBR, s:notslash . ':')
                              let ini = strpart(a:groupBR, 0, i-1)
                              let tailBR = strpart(a:groupBR, i)
                              let word = s:Choose(a:group, a:matchline, ":", "", a:prefix, a:suffix,
                                \ a:groupBR)
                              let i = matchend(word, s:notslash . ":")
                              let wordBR = strpart(word, i)
                              let word = strpart(word, 0, i-1)
                              " Now, a:matchline =~ a:prefix . word . a:suffix
                              if wordBR != ini
                                let table = s:Resolve(ini, wordBR, "table")
                              else
                                " let table = "----------"
                                let table = ""
                                let d = 0
                                while d < 10
                                  if tailBR =~ s:notslash . '\\' . d
                            	" let table[d] = d
                            	let table = table . d
                                  else
                            	let table = table . "-"
                                  endif
                                  let d = d + 1
                                endwhile
                              endif
                              let d = 9
                              while d
                                if table[d] != "-"
                                  let backref = substitute(a:matchline, a:prefix.word.a:suffix,
                            	\ '\'.table[d], "")
                            	" Are there any other characters that should be escaped?
                                  let backref = escape(backref, '*,:')
                                  execute s:Ref(ini, d, "start", "len")
                                  let ini = strpart(ini, 0, start) . backref . strpart(ini, start+len)
                                  let tailBR = substitute(tailBR, s:notslash . '\zs\\' . d,
                            	\ escape(backref, '\\&'), 'g')
                                endif
                                let d = d-1
                              endwhile
                              if exists("b:match_debug")
                                if s:do_BR
                                  let b:match_table = table
                                  let b:match_word = word
                                else
                                  let b:match_table = ""
                                  let b:match_word = ""
                                endif
                              endif
                              return ini . ":" . tailBR
                            endfun
                            
                            " Input a comma-separated list of groups with backrefs, such as
                            "   a:groups = '\(foo\):end\1,\(bar\):end\1'
                            " and return a comma-separated list of groups with backrefs replaced:
                            "   return '\(foo\):end\(foo\),\(bar\):end\(bar\)'
    1              0.000001 fun! s:ParseWords(groups)
                              let groups = substitute(a:groups.",", s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
                              let groups = substitute(groups, s:notslash . '\zs:\{2,}', ':', 'g')
                              let parsed = ""
                              while groups =~ '[^,:]'
                                let i = matchend(groups, s:notslash . ':')
                                let j = matchend(groups, s:notslash . ',')
                                let ini = strpart(groups, 0, i-1)
                                let tail = strpart(groups, i, j-i-1) . ":"
                                let groups = strpart(groups, j)
                                let parsed = parsed . ini
                                let i = matchend(tail, s:notslash . ':')
                                while i != -1
                                  " In 'if:else:endif', ini='if' and word='else' and then word='endif'.
                                  let word = strpart(tail, 0, i-1)
                                  let tail = strpart(tail, i)
                                  let i = matchend(tail, s:notslash . ':')
                                  let parsed = parsed . ":" . s:Resolve(ini, word, "word")
                                endwhile " Now, tail has been used up.
                                let parsed = parsed . ","
                              endwhile " groups =~ '[^,:]'
                              let parsed = substitute(parsed, ',$', '', '')
                              return parsed
                            endfun
                            
                            " TODO I think this can be simplified and/or made more efficient.
                            " TODO What should I do if a:start is out of range?
                            " Return a regexp that matches all of a:string, such that
                            " matchstr(a:string, regexp) represents the match for a:pat that starts
                            " as close to a:start as possible, before being preferred to after, and
                            " ends after a:start .
                            " Usage:
                            " let regexp = s:Wholematch(getline("."), 'foo\|bar', col(".")-1)
                            " let i      = match(getline("."), regexp)
                            " let j      = matchend(getline("."), regexp)
                            " let match  = matchstr(getline("."), regexp)
    1              0.000002 fun! s:Wholematch(string, pat, start)
                              let group = '\%(' . a:pat . '\)'
                              let prefix = (a:start ? '\(^.*\%<' . (a:start + 2) . 'c\)\zs' : '^')
                              let len = strlen(a:string)
                              let suffix = (a:start+1 < len ? '\(\%>'.(a:start+1).'c.*$\)\@=' : '$')
                              if a:string !~ prefix . group . suffix
                                let prefix = ''
                              endif
                              return prefix . group . suffix
                            endfun
                            
                            " No extra arguments:  s:Ref(string, d) will
                            " find the d'th occurrence of '\(' and return it, along with everything up
                            " to and including the matching '\)'.
                            " One argument:  s:Ref(string, d, "start") returns the index of the start
                            " of the d'th '\(' and any other argument returns the length of the group.
                            " Two arguments:  s:Ref(string, d, "foo", "bar") returns a string to be
                            " executed, having the effect of
                            "   :let foo = s:Ref(string, d, "start")
                            "   :let bar = s:Ref(string, d, "len")
    1              0.000002 fun! s:Ref(string, d, ...)
                              let len = strlen(a:string)
                              if a:d == 0
                                let start = 0
                              else
                                let cnt = a:d
                                let match = a:string
                                while cnt
                                  let cnt = cnt - 1
                                  let index = matchend(match, s:notslash . '\\(')
                                  if index == -1
                            	return ""
                                  endif
                                  let match = strpart(match, index)
                                endwhile
                                let start = len - strlen(match)
                                if a:0 == 1 && a:1 == "start"
                                  return start - 2
                                endif
                                let cnt = 1
                                while cnt
                                  let index = matchend(match, s:notslash . '\\(\|\\)') - 1
                                  if index == -2
                            	return ""
                                  endif
                                  " Increment if an open, decrement if a ')':
                                  let cnt = cnt + (match[index]=="(" ? 1 : -1)  " ')'
                                  " let cnt = stridx('0(', match[index]) + cnt
                                  let match = strpart(match, index+1)
                                endwhile
                                let start = start - 2
                                let len = len - start - strlen(match)
                              endif
                              if a:0 == 1
                                return len
                              elseif a:0 == 2
                                return "let " . a:1 . "=" . start . "| let " . a:2 . "=" . len
                              else
                                return strpart(a:string, start, len)
                              endif
                            endfun
                            
                            " Count the number of disjoint copies of pattern in string.
                            " If the pattern is a literal string and contains no '0' or '1' characters
                            " then s:Count(string, pattern, '0', '1') should be faster than
                            " s:Count(string, pattern).
    1              0.000001 fun! s:Count(string, pattern, ...)
                              let pat = escape(a:pattern, '\\')
                              if a:0 > 1
                                let foo = substitute(a:string, '[^'.a:pattern.']', "a:1", "g")
                                let foo = substitute(a:string, pat, a:2, "g")
                                let foo = substitute(foo, '[^' . a:2 . ']', "", "g")
                                return strlen(foo)
                              endif
                              let result = 0
                              let foo = a:string
                              let index = matchend(foo, pat)
                              while index != -1
                                let result = result + 1
                                let foo = strpart(foo, index)
                                let index = matchend(foo, pat)
                              endwhile
                              return result
                            endfun
                            
                            " s:Resolve('\(a\)\(b\)', '\(c\)\2\1\1\2') should return table.word, where
                            " word = '\(c\)\(b\)\(a\)\3\2' and table = '-32-------'.  That is, the first
                            " '\1' in target is replaced by '\(a\)' in word, table[1] = 3, and this
                            " indicates that all other instances of '\1' in target are to be replaced
                            " by '\3'.  The hard part is dealing with nesting...
                            " Note that ":" is an illegal character for source and target,
                            " unless it is preceded by "\".
    1              0.000002 fun! s:Resolve(source, target, output)
                              let word = a:target
                              let i = matchend(word, s:notslash . '\\\d') - 1
                              let table = "----------"
                              while i != -2 " There are back references to be replaced.
                                let d = word[i]
                                let backref = s:Ref(a:source, d)
                                " The idea is to replace '\d' with backref.  Before we do this,
                                " replace any \(\) groups in backref with :1, :2, ... if they
                                " correspond to the first, second, ... group already inserted
                                " into backref.  Later, replace :1 with \1 and so on.  The group
                                " number w+b within backref corresponds to the group number
                                " s within a:source.
                                " w = number of '\(' in word before the current one
                                let w = s:Count(
                                \ substitute(strpart(word, 0, i-1), '\\\\', '', 'g'), '\(', '1')
                                let b = 1 " number of the current '\(' in backref
                                let s = d " number of the current '\(' in a:source
                                while b <= s:Count(substitute(backref, '\\\\', '', 'g'), '\(', '1')
                                \ && s < 10
                                  if table[s] == "-"
                            	if w + b < 10
                            	  " let table[s] = w + b
                            	  let table = strpart(table, 0, s) . (w+b) . strpart(table, s+1)
                            	endif
                            	let b = b + 1
                            	let s = s + 1
                                  else
                            	execute s:Ref(backref, b, "start", "len")
                            	let ref = strpart(backref, start, len)
                            	let backref = strpart(backref, 0, start) . ":". table[s]
                            	\ . strpart(backref, start+len)
                            	let s = s + s:Count(substitute(ref, '\\\\', '', 'g'), '\(', '1')
                                  endif
                                endwhile
                                let word = strpart(word, 0, i-1) . backref . strpart(word, i+1)
                                let i = matchend(word, s:notslash . '\\\d') - 1
                              endwhile
                              let word = substitute(word, s:notslash . '\zs:', '\\', 'g')
                              if a:output == "table"
                                return table
                              elseif a:output == "word"
                                return word
                              else
                                return table . word
                              endif
                            endfun
                            
                            " Assume a:comma = ",".  Then the format for a:patterns and a:1 is
                            "   a:patterns = "<pat1>,<pat2>,..."
                            "   a:1 = "<alt1>,<alt2>,..."
                            " If <patn> is the first pattern that matches a:string then return <patn>
                            " if no optional arguments are given; return <patn>,<altn> if a:1 is given.
    1              0.000002 fun! s:Choose(patterns, string, comma, branch, prefix, suffix, ...)
                              let tail = (a:patterns =~ a:comma."$" ? a:patterns : a:patterns . a:comma)
                              let i = matchend(tail, s:notslash . a:comma)
                              if a:0
                                let alttail = (a:1 =~ a:comma."$" ? a:1 : a:1 . a:comma)
                                let j = matchend(alttail, s:notslash . a:comma)
                              endif
                              let current = strpart(tail, 0, i-1)
                              if a:branch == ""
                                let currpat = current
                              else
                                let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
                              endif
                              while a:string !~ a:prefix . currpat . a:suffix
                                let tail = strpart(tail, i)
                                let i = matchend(tail, s:notslash . a:comma)
                                if i == -1
                                  return -1
                                endif
                                let current = strpart(tail, 0, i-1)
                                if a:branch == ""
                                  let currpat = current
                                else
                                  let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
                                endif
                                if a:0
                                  let alttail = strpart(alttail, j)
                                  let j = matchend(alttail, s:notslash . a:comma)
                                endif
                              endwhile
                              if a:0
                                let current = current . a:comma . strpart(alttail, 0, j-1)
                              endif
                              return current
                            endfun
                            
                            " Call this function to turn on debugging information.  Every time the main
                            " script is run, buffer variables will be saved.  These can be used directly
                            " or viewed using the menu items below.
    1              0.000003 if !exists(":MatchDebug")
    1              0.000003   command! -nargs=0 MatchDebug call s:Match_debug()
    1              0.000001 endif
                            
    1              0.000001 fun! s:Match_debug()
                              let b:match_debug = 1	" Save debugging information.
                              " pat = all of b:match_words with backrefs parsed
                              amenu &Matchit.&pat	:echo b:match_pat<CR>
                              " match = bit of text that is recognized as a match
                              amenu &Matchit.&match	:echo b:match_match<CR>
                              " curcol = cursor column of the start of the matching text
                              amenu &Matchit.&curcol	:echo b:match_col<CR>
                              " wholeBR = matching group, original version
                              amenu &Matchit.wh&oleBR	:echo b:match_wholeBR<CR>
                              " iniBR = 'if' piece, original version
                              amenu &Matchit.ini&BR	:echo b:match_iniBR<CR>
                              " ini = 'if' piece, with all backrefs resolved from match
                              amenu &Matchit.&ini	:echo b:match_ini<CR>
                              " tail = 'else\|endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&tail	:echo b:match_tail<CR>
                              " fin = 'endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&word	:echo b:match_word<CR>
                              " '\'.d in ini refers to the same thing as '\'.table[d] in word.
                              amenu &Matchit.t&able	:echo '0:' . b:match_table . ':9'<CR>
                            endfun
                            
                            " Jump to the nearest unmatched "(" or "if" or "<tag>" if a:spflag == "bW"
                            " or the nearest unmatched "</tag>" or "endif" or ")" if a:spflag == "W".
                            " Return a "mark" for the original position, so that
                            "   let m = MultiMatch("bW", "n") ... execute m
                            " will return to the original position.  If there is a problem, do not
                            " move the cursor and return "", unless a count is given, in which case
                            " go up or down as many levels as possible and again return "".
                            " TODO This relies on the same patterns as % matching.  It might be a good
                            " idea to give it its own matching patterns.
    1              0.000002 fun! s:MultiMatch(spflag, mode)
                              if !exists("b:match_words") || b:match_words == ""
                                return {}
                              end
                              let restore_options = ""
                              if exists("b:match_ignorecase") && b:match_ignorecase != &ic
                                let restore_options .= (&ic ? " " : " no") . "ignorecase"
                                let &ignorecase = b:match_ignorecase
                              endif
                              let startline = line(".")
                              let startcol = col(".")
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              " This part is copied and slightly modified from s:Match_wrapper().
                              let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") .
                                \ '\/\*:\*\/,#\s*if\%(def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                              " Allow b:match_words = "GetVimMatchWords()" .
                              if b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                              if (match_words != s:last_words) || (&mps != s:last_mps) ||
                                \ exists("b:match_debug")
                                let s:last_words = match_words
                                let s:last_mps = &mps
                                let match_words = match_words . (strlen(match_words) ? "," : "") . default
                                if match_words !~ s:notslash . '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = '\%(' . substitute(s:pat . (strlen(s:pat) ? "," : "") . default,
                            	\ '[,:]\+', '\\|', 'g') . '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                              endif
                            
                              " Second step:  figure out the patterns for searchpair()
                              " and save the screen, cursor position, and 'ignorecase'.
                              " - TODO:  A lot of this is copied from s:Match_wrapper().
                              " - maybe even more functionality should be split off
                              " - into separate functions!
                              let cdefault = (s:pat =~ '[^,]$' ? "," : "") . default
                              let open =  substitute(s:pat . cdefault,
                            	\ s:notslash . '\zs:.\{-}' . s:notslash . ',', '\\),\\(', 'g')
                              let open =  '\(' . substitute(open, s:notslash . '\zs:.*$', '\\)', '')
                              let close = substitute(s:pat . cdefault,
                            	\ s:notslash . '\zs,.\{-}' . s:notslash . ':', '\\),\\(', 'g')
                              let close = substitute(close, '^.\{-}' . s:notslash . ':', '\\(', '') . '\)'
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              let view = winsaveview()
                            
                              " Third step: call searchpair().
                              " Replace '\('--but not '\\('--with '\%(' and ',' with '\|'.
                              let openpat =  substitute(open, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
                              let openpat = substitute(openpat, ',', '\\|', 'g')
                              let closepat = substitute(close, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
                              let closepat = substitute(closepat, ',', '\\|', 'g')
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = '0'
                              else
                                execute "if " . skip . "| let skip = '0' | endif"
                              endif
                              mark '
                              let level = v:count1
                              while level
                                if searchpair(openpat, '', closepat, a:spflag, skip) < 1
                                  call s:CleanUp(restore_options, a:mode, startline, startcol)
                                  return {}
                                endif
                                let level = level - 1
                              endwhile
                            
                              " Restore options and return view dict to restore the original position.
                              call s:CleanUp(restore_options, a:mode, startline, startcol)
                              return view
                            endfun
                            
                            " Search backwards for "if" or "while" or "<tag>" or ...
                            " and return "endif" or "endwhile" or "</tag>" or ... .
                            " For now, this uses b:match_words and the same script variables
                            " as s:Match_wrapper() .  Later, it may get its own patterns,
                            " either from a buffer variable or passed as arguments.
                            " fun! s:Autocomplete()
                            "   echo "autocomplete not yet implemented :-("
                            "   if !exists("b:match_words") || b:match_words == ""
                            "     return ""
                            "   end
                            "   let startpos = s:MultiMatch("bW")
                            "
                            "   if startpos == ""
                            "     return ""
                            "   endif
                            "   " - TODO:  figure out whether 'if' or '<tag>' matched, and construct
                            "   " - the appropriate closing.
                            "   let matchline = getline(".")
                            "   let curcol = col(".") - 1
                            "   " - TODO:  Change the s:all argument if there is a new set of match pats.
                            "   let regexp = s:Wholematch(matchline, s:all, curcol)
                            "   let suf = strlen(matchline) - matchend(matchline, regexp)
                            "   let prefix = (curcol ? '^.\{'  . curcol . '}\%(' : '^\%(')
                            "   let suffix = (suf ? '\).\{' . suf . '}$'  : '\)$')
                            "   " Reconstruct the version with unresolved backrefs.
                            "   let patBR = substitute(b:match_words.',', '[,:]*,[,:]*', ',', 'g')
                            "   let patBR = substitute(patBR, ':\{2,}', ':', "g")
                            "   " Now, set group and groupBR to the matching group: 'if:endif' or
                            "   " 'while:endwhile' or whatever.
                            "   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)
                            "   let i = matchend(group, s:notslash . ",")
                            "   let groupBR = strpart(group, i)
                            "   let group = strpart(group, 0, i-1)
                            "   " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
                            "   if s:do_BR
                            "     let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                            "   endif
                            " " let g:group = group
                            "
                            "   " - TODO:  Construct the closing from group.
                            "   let fake = "end" . expand("<cword>")
                            "   execute startpos
                            "   return fake
                            " endfun
                            
                            " Close all open structures.  "Get the heck out of here!"
                            " fun! s:Gthhoh()
                            "   let close = s:Autocomplete()
                            "   while strlen(close)
                            "     put=close
                            "     let close = s:Autocomplete()
                            "   endwhile
                            " endfun
                            
                            " Parse special strings as typical skip arguments for searchpair():
                            "   s:foo becomes (current syntax item) =~ foo
                            "   S:foo becomes (current syntax item) !~ foo
                            "   r:foo becomes (line before cursor) =~ foo
                            "   R:foo becomes (line before cursor) !~ foo
    1              0.000002 fun! s:ParseSkip(str)
                              let skip = a:str
                              if skip[1] == ":"
                                if skip[0] == "s"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') =~? '" .
                            	\ strpart(skip,2) . "'"
                                elseif skip[0] == "S"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') !~? '" .
                            	\ strpart(skip,2) . "'"
                                elseif skip[0] == "r"
                                  let skip = "strpart(getline('.'),0,col('.'))=~'" . strpart(skip,2). "'"
                                elseif skip[0] == "R"
                                  let skip = "strpart(getline('.'),0,col('.'))!~'" . strpart(skip,2). "'"
                                endif
                              endif
                              return skip
                            endfun
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2017 Sep 30
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - the "CursorMoved" autocmd event is not available.
    1              0.000008 if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
                              finish
                            endif
    1              0.000002 let g:loaded_matchparen = 1
                            
    1              0.000002 if !exists("g:matchparen_timeout")
    1              0.000002   let g:matchparen_timeout = 300
    1              0.000001 endif
    1              0.000002 if !exists("g:matchparen_insert_timeout")
    1              0.000002   let g:matchparen_insert_timeout = 60
    1              0.000001 endif
                            
    1              0.000001 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000008   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
    1              0.000002   if exists('##TextChanged')
    1              0.000008     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000001   endif
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000003 if exists("*s:Highlight_Matching_Pair")
                              finish
                            endif
                            
    1              0.000004 let s:cpo_save = &cpo
    1              0.000004 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000002 function! s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' .
                            	\ '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000003 command! DoMatchParen call s:DoMatchParen()
    1              0.000003 command! NoMatchParen call s:NoMatchParen()
                            
    1              0.000003 func! s:NoMatchParen()
                              let w = winnr()
                              noau windo silent! call matchdelete(3)
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000001 func! s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000004 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000454
 Self time:   0.000454

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Feb 08, 2016
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000006 if &cp || exists("g:loaded_netrwPlugin")
                             finish
                            endif
    1              0.000002 let g:loaded_netrwPlugin = "v156"
    1              0.000003 let s:keepcpo = &cpo
    1              0.000004 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000001 augroup FileExplorer
    1              0.000033  au!
    1              0.000005  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000003  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000003  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000008  if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
                             endif
    1              0.000001 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001 augroup Network
    1              0.000033  au!
    1              0.000005  au BufReadCmd   file://*											call netrw#FileUrlRead(expand("<amatch>"))
    1              0.000022  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000021  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000018  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000018  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000001  try                                                       
    1              0.000017   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000001  catch /^Vim\%((\a\+)\)\=:E216/                            
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             endtry
    1              0.000001 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000008 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000008 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000003 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000008 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000003 com! -nargs=?		Ntree		call netrw#SetTreetop(<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000005 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000005 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000005 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000003 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000005 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000003 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000003 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000003 if !exists("g:netrw_nogx")
    1              0.000005  if maparg('gx','n') == ""
    1              0.000007   if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000005    nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000001   endif
    1              0.000009   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
    1              0.000001  endif
    1              0.000005  if maparg('gx','v') == ""
    1              0.000007   if !hasmapto('<Plug>NetrwBrowseXVis')
    1              0.000004    vmap <unique> gx <Plug>NetrwBrowseXVis
    1              0.000001   endif
    1              0.000006   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000001  endif
    1              0.000001 endif
    1              0.000002 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
                            endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000002 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000001 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000003 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000005 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/rplugin.vim
Sourced 1 time
Total time:   0.000863
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000006 if exists('g:loaded_remote_plugins')
                              finish
                            endif
    1              0.000002 let g:loaded_remote_plugins = '/path/to/manifest'
                            
                            " Get the path to the rplugin manifest file.
    1              0.000002 function! s:GetManifestPath() abort
                              let manifest_base = ''
                            
                              if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
                              endif
                            
                              let dest = has('win32') ? '$LOCALAPPDATA' : '$XDG_DATA_HOME'
                              if !exists(dest)
                                let dest = has('win32') ? '~/AppData/Local' : '~/.local/share'
                              endif
                            
                              let dest = fnamemodify(expand(dest), ':p')
                              if !empty(dest)
                                let dest .= ('/' ==# dest[-1:] ? '' : '/') . 'nvim'
                                if !isdirectory(dest)
                                  call mkdir(dest, 'p', 0700)
                                endif
                                let manifest_base = dest
                              endif
                            
                              return manifest_base.'/rplugin.vim'
                            endfunction
                            
                            " Old manifest file based on known script locations.
    1              0.000001 function! s:GetOldManifestPath() abort
                              let prefix = exists('$MYVIMRC')
                                    \ ? $MYVIMRC
                                    \ : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
                              return fnamemodify(expand(prefix, 1), ':h')
                                    \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'
                            endfunction
                            
    1              0.000001 function! s:GetManifest() abort
                              let manifest = s:GetManifestPath()
                              if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                let old_manifest = s:GetOldManifestPath()
                                if filereadable(old_manifest)
                                  call rename(old_manifest, manifest)
                                endif
                              endif
                              return manifest
                            endfunction
                            
    1              0.000001 function! s:LoadRemotePlugins() abort
                              let g:loaded_remote_plugins = s:GetManifest()
                              if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
                              endif
                            endfunction
                            
    1              0.000004 command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
                            
    1   0.000804   0.000011 call s:LoadRemotePlugins()

SCRIPT  /Users/stevezhang/.local/share/nvim/rplugin.vim
Sourced 1 time
Total time:   0.000610
 Self time:   0.000034

count  total (s)   self (s)
                            " node plugins
                            
                            
                            " python3 plugins
    1   0.000592   0.000016 call remote#host#RegisterPlugin('python3', '/Users/stevezhang/.local/share/nvim/plugged/deoplete.nvim/rplugin/python3/deoplete', [
                                  \ {'sync': v:false, 'name': '_deoplete_init', 'type': 'function', 'opts': {}},
                                 \ ])
                            
                            
                            " ruby plugins
                            
                            
                            " python plugins
                            
                            

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/autoload/remote/define.vim
Sourced 1 time
Total time:   0.000219
 Self time:   0.000219

count  total (s)   self (s)
    1              0.000005 function! remote#define#CommandOnHost(host, method, sync, name, opts)
                              let prefix = ''
                            
                              if has_key(a:opts, 'range')
                                if a:opts.range == '' || a:opts.range == '%'
                                  " -range or -range=%, pass the line range in a list
                                  let prefix = '<line1>,<line2>'
                                elseif matchstr(a:opts.range, '\d') != ''
                                  " -range=N, pass the count
                                  let prefix = '<count>'
                                endif
                              elseif has_key(a:opts, 'count')
                                let prefix = '<count>'
                              endif
                            
                              let forward_args = [prefix.a:name]
                            
                              if has_key(a:opts, 'bang')
                                call add(forward_args, '<bang>')
                              endif
                            
                              if has_key(a:opts, 'register')
                                call add(forward_args, ' <register>')
                              endif
                            
                              if has_key(a:opts, 'nargs')
                                call add(forward_args, ' <args>')
                              endif
                            
                              exe s:GetCommandPrefix(a:name, a:opts)
                                    \ .' call remote#define#CommandBootstrap("'.a:host.'"'
                                    \ .                                ', "'.a:method.'"'
                                    \ .                                ', '.string(a:sync)
                                    \ .                                ', "'.a:name.'"'
                                    \ .                                ', '.string(a:opts).''
                                    \ .                                ', "'.join(forward_args, '').'"'
                                    \ .                                ')'
                            endfunction
                            
                            
    1              0.000003 function! remote#define#CommandBootstrap(host, method, sync, name, opts, forward)
                              let channel = remote#host#Require(a:host)
                            
                              if channel
                                call remote#define#CommandOnChannel(channel, a:method, a:sync, a:name, a:opts)
                                exe a:forward
                              else
                                exe 'delcommand '.a:name
                                echoerr 'Host "'a:host.'" is not available, deleting command "'.a:name.'"'
                              endif
                            endfunction
                            
                            
    1              0.000002 function! remote#define#CommandOnChannel(channel, method, sync, name, opts)
                              let rpcargs = [a:channel, '"'.a:method.'"']
                              if has_key(a:opts, 'nargs')
                                " -nargs, pass arguments in a list
                                call add(rpcargs, '[<f-args>]')
                              endif
                            
                              if has_key(a:opts, 'range')
                                if a:opts.range == '' || a:opts.range == '%'
                                  " -range or -range=%, pass the line range in a list
                                  call add(rpcargs, '[<line1>, <line2>]')
                                elseif matchstr(a:opts.range, '\d') != ''
                                  " -range=N, pass the count
                                  call add(rpcargs, '<count>')
                                endif
                              elseif has_key(a:opts, 'count')
                                " count
                                call add(rpcargs, '<count>')
                              endif
                            
                              if has_key(a:opts, 'bang')
                                " bang
                                call add(rpcargs, '<q-bang> == "!"')
                              endif
                            
                              if has_key(a:opts, 'register')
                                " register
                                call add(rpcargs, '<q-reg>')
                              endif
                            
                              call s:AddEval(rpcargs, a:opts)
                              exe s:GetCommandPrefix(a:name, a:opts)
                                    \ . ' call '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'
                            endfunction
                            
                            
    1              0.000002 function! remote#define#AutocmdOnHost(host, method, sync, name, opts)
                              let group = s:GetNextAutocmdGroup()
                              let forward = '"doau '.group.' '.a:name.' ".'
                                    \ . 'fnameescape(expand("<amatch>"))'
                              let a:opts.group = group
                              let bootstrap_def = s:GetAutocmdPrefix(a:name, a:opts)
                                    \ .' call remote#define#AutocmdBootstrap("'.a:host.'"'
                                    \ .                                ', "'.a:method.'"'
                                    \ .                                ', '.string(a:sync)
                                    \ .                                ', "'.a:name.'"'
                                    \ .                                ', '.string(a:opts).''
                                    \ .                                ', "'.escape(forward, '"').'"'
                                    \ .                                ')'
                              exe bootstrap_def
                            endfunction
                            
                            
    1              0.000002 function! remote#define#AutocmdBootstrap(host, method, sync, name, opts, forward)
                              let channel = remote#host#Require(a:host)
                            
                              exe 'autocmd! '.a:opts.group
                              if channel
                                call remote#define#AutocmdOnChannel(channel, a:method, a:sync, a:name,
                                      \ a:opts)
                                exe eval(a:forward)
                              else
                                exe 'augroup! '.a:opts.group
                                echoerr 'Host "'a:host.'" for "'.a:name.'" autocmd is not available'
                              endif
                            endfunction
                            
                            
    1              0.000002 function! remote#define#AutocmdOnChannel(channel, method, sync, name, opts)
                              let rpcargs = [a:channel, '"'.a:method.'"']
                              call s:AddEval(rpcargs, a:opts)
                            
                              let autocmd_def = s:GetAutocmdPrefix(a:name, a:opts)
                                    \ . ' call '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'
                              exe autocmd_def
                            endfunction
                            
                            
    1              0.000002 function! remote#define#FunctionOnHost(host, method, sync, name, opts)
                              let group = s:GetNextAutocmdGroup()
                              exe 'autocmd! '.group.' FuncUndefined '.a:name
                                    \ .' call remote#define#FunctionBootstrap("'.a:host.'"'
                                    \ .                                 ', "'.a:method.'"'
                                    \ .                                 ', '.string(a:sync)
                                    \ .                                 ', "'.a:name.'"'
                                    \ .                                 ', '.string(a:opts)
                                    \ .                                 ', "'.group.'"'
                                    \ .                                 ')'
                            endfunction
                            
                            
    1              0.000002 function! remote#define#FunctionBootstrap(host, method, sync, name, opts, group)
                              let channel = remote#host#Require(a:host)
                            
                              exe 'autocmd! '.a:group
                              exe 'augroup! '.a:group
                              if channel
                                call remote#define#FunctionOnChannel(channel, a:method, a:sync, a:name,
                                      \ a:opts)
                              else
                                echoerr 'Host "'a:host.'" for "'.a:name.'" function is not available'
                              endif
                            endfunction
                            
                            
    1              0.000002 function! remote#define#FunctionOnChannel(channel, method, sync, name, opts)
                              let rpcargs = [a:channel, '"'.a:method.'"', 'a:000']
                              if has_key(a:opts, 'range')
                                call add(rpcargs, '[a:firstline, a:lastline]')
                              endif
                              call s:AddEval(rpcargs, a:opts)
                            
                              let function_def = s:GetFunctionPrefix(a:name, a:opts)
                                    \ . 'return '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'
                                    \ . "\nendfunction"
                              exe function_def
                            endfunction
                            
    1              0.000002 let s:busy = {}
    1              0.000002 let s:pending_notifications = {}
                            
    1              0.000002 function! s:GetRpcFunction(sync)
                              if a:sync ==# 'urgent'
                                return 'rpcnotify'
                              elseif a:sync
                                return 'remote#define#request'
                              endif
                              return 'remote#define#notify'
                            endfunction
                            
    1              0.000002 function! remote#define#notify(chan, ...)
                              if get(s:busy, a:chan, 0) > 0
                                let pending = get(s:pending_notifications, a:chan, [])
                                call add(pending, deepcopy(a:000))
                                let s:pending_notifications[a:chan] = pending
                              else
                                call call('rpcnotify', [a:chan] + a:000)
                              endif
                            endfunction
                            
    1              0.000002 function! remote#define#request(chan, ...)
                              let s:busy[a:chan] = get(s:busy, a:chan, 0)+1
                              let val = call('rpcrequest', [a:chan]+a:000)
                              let s:busy[a:chan] -= 1
                              if s:busy[a:chan] == 0
                                for msg in get(s:pending_notifications, a:chan, [])
                                  call call('rpcnotify', [a:chan] + msg)
                                endfor
                                let s:pending_notifications[a:chan] = []
                              endif
                              return val
                            endfunction
                            
    1              0.000002 function! s:GetCommandPrefix(name, opts)
                              return 'command!'.s:StringifyOpts(a:opts, ['nargs', 'complete', 'range',
                                    \ 'count', 'bang', 'bar', 'register']).' '.a:name
                            endfunction
                            
                            
                            " Each msgpack-rpc autocommand has it's own unique group, which is derived
                            " from an autoincrementing gid(group id). This is required for replacing the
                            " autocmd implementation with the lazy-load mechanism
    1              0.000002 let s:next_gid = 1
    1              0.000001 function! s:GetNextAutocmdGroup()
                              let gid = s:next_gid
                              let s:next_gid += 1
                            
                              let group_name = 'RPC_DEFINE_AUTOCMD_GROUP_'.gid
                              " Ensure the group is defined
                              exe 'augroup '.group_name.' | augroup END'
                              return group_name
                            endfunction
                            
                            
    1              0.000001 function! s:GetAutocmdPrefix(name, opts)
                              if has_key(a:opts, 'group')
                                let group = a:opts.group
                              else
                                let group = s:GetNextAutocmdGroup()
                              endif
                              let rv = ['autocmd!', group, a:name]
                            
                              if has_key(a:opts, 'pattern')
                                call add(rv, a:opts.pattern)
                              else
                                call add(rv, '*')
                              endif
                            
                              if has_key(a:opts, 'nested') && a:opts.nested
                                call add(rv, 'nested')
                              endif
                            
                              return join(rv, ' ')
                            endfunction
                            
                            
    1              0.000002 function! s:GetFunctionPrefix(name, opts)
                              let res = "function! ".a:name."(...)"
                              if has_key(a:opts, 'range')
                                let res = res." range"
                              endif
                              return res."\n"
                            endfunction
                            
                            
    1              0.000001 function! s:StringifyOpts(opts, keys)
                              let rv = []
                              for key in a:keys
                                if has_key(a:opts, key)
                                  call add(rv, ' -'.key)
                                  let val = a:opts[key]
                                  if type(val) != type('') || val != ''
                                    call add(rv, '='.val)
                                  endif
                                endif
                              endfor
                              return join(rv, '')
                            endfunction
                            
                            
    1              0.000001 function! s:AddEval(rpcargs, opts)
                              if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
                              endif
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/rrhelper.vim
Sourced 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            " Vim plugin with helper function(s) for --remote-wait
                            " Maintainer: Flemming Madsen <fma@cci.dk>
                            " Last Change: 2008 May 29
                            
                            " Has this already been loaded?
    1              0.000006 if exists("loaded_rrhelper") || !has("clientserver")
    1              0.000001   finish
                            endif
                            let loaded_rrhelper = 1
                            
                            " Setup answers for a --remote-wait client who will assume
                            " a SetupRemoteReplies() function in the command server
                            
                            function SetupRemoteReplies()
                              let cnt = 0
                              let max = argc()
                            
                              let id = expand("<client>")
                              if id == 0
                                return
                              endif
                              while cnt < max
                                " Handle same file from more clients and file being more than once
                                " on the command line by encoding this stuff in the group name
                                let uniqueGroup = "RemoteReply_".id."_".cnt
                            
                                " Path separators are always forward slashes for the autocommand pattern.
                                " Escape special characters with a backslash.
                                let f = substitute(argv(cnt), '\\', '/', "g")
                                if exists('*fnameescape')
                                  let f = fnameescape(f)
                                else
                                  let f = escape(f, " \t\n*?[{`$\\%#'\"|!<")
                                endif
                                execute "augroup ".uniqueGroup
                                execute "autocmd ".uniqueGroup." BufUnload ". f ."  call DoRemoteReply('".id."', '".cnt."', '".uniqueGroup."', '". f ."')"
                                let cnt = cnt + 1
                              endwhile
                              augroup END
                            endfunc
                            
                            function DoRemoteReply(id, cnt, group, file)
                              call server2client(a:id, a:cnt)
                              execute 'autocmd! '.a:group.' BufUnload '.a:file
                              execute 'augroup! '.a:group
                            endfunc
                            
                            " vim: set sw=2 sts=2 :

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/shada.vim
Sourced 1 time
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_shada_plugin')
                              finish
                            endif
    1              0.000002 let g:loaded_shada_plugin = 1
                            
    1              0.000002 augroup ShaDaCommands
    1              0.000034   autocmd!
    1              0.000012   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b')))
                                    \ |setlocal filetype=shada
    1              0.000007   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
    1              0.000011   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |if writefile(shada#get_binstrings(getline(1, '$')),
                                                   \expand('<afile>'), 'b') == 0
                                    \ |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))
                                                           \? 0
                                                           \: stridx(&cpoptions, '+') != -1)
                                    \ |endif
    1              0.000008   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'b')
    1              0.000007   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'ab')
    1              0.000008   autocmd SourceCmd *.shada,*.shada.tmp.[a-z]
                                    \ :execute 'rshada' fnameescape(expand('<afile>'))
    1              0.000003 augroup END

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            
    1              0.000008 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
                            endif
    1              0.000002 let loaded_spellfile_plugin = 1
                            
    1              0.000007 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000005 if &cp || exists("g:loaded_tarPlugin")
                             finish
                            endif
    1              0.000002 let g:loaded_tarPlugin = "v29"
    1              0.000003 let s:keepcpo          = &cpo
    1              0.000004 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000001 augroup tar
    1              0.000036   au!
    1              0.000005   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000004   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000006   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000003   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000002   if has("unix")
    1              0.000004    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000003    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000003    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000006    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000001   endif
                            
    1              0.000003   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000005   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000006   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000001 augroup END
    1              0.000005 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000005 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2015 Sep 08
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
                            " TODO: {{{
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
    1              0.000003 if exists('g:loaded_2html_plugin')
                              finish
                            endif
    1              0.000002 let g:loaded_2html_plugin = 'vim7.4_v2'
                            
                            "
                            " Changelog: {{{
                            "   7.4_v2  (this version): Fix error raised when converting a diff containing
                            "                           an empty buffer. Jan Stocker: allow g:html_font to
                            "                           take a list so it is easier to specfiy fallback
                            "                           fonts in the generated CSS.
                            "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evalutated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
                            "}}}
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin was not already loaded
                            " - user commands are available. {{{
    1              0.000007 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000006   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000001 endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/tutor.vim
Sourced 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000005 if exists('g:loaded_tutor_mode_plugin') || &compatible
                                finish
                            endif
    1              0.000002 let g:loaded_tutor_mode_plugin = 1
                            
    1              0.000007 command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Sep 13, 2016
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000005 if &cp || exists("g:loaded_zipPlugin")
                             finish
                            endif
    1              0.000002 let g:loaded_zipPlugin = "v28"
    1              0.000003 let s:keepcpo          = &cpo
    1              0.000004 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000005 if !exists("g:zipPlugin_ext")
    1              0.000004  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000001 augroup zip
    1              0.000034  au!
    1              0.000005  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000004  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000003  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000003  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000002  if has("unix")
    1              0.000007   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000004   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000003   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000003   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000001  endif
                            
    1              0.000074  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000001 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000004 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/ultisnips/after/plugin/UltiSnips_after.vim
Sourced 1 time
Total time:   0.000094
 Self time:   0.000028

count  total (s)   self (s)
                            " Called after everything else to reclaim keys (Needed for Supertab)
                            
    1              0.000006 if exists("b:did_after_plugin_ultisnips_after") || !exists("g:_uspy")
                               finish
                            endif
    1              0.000004 let b:did_after_plugin_ultisnips_after = 1
                            
    1   0.000073   0.000007 call UltiSnips#map_keys#MapKeys()

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/indentLine/after/plugin/indentLine.vim
Sourced 1 time
Total time:   0.000410
 Self time:   0.000410

count  total (s)   self (s)
                            " Script Name: indentLine.vim
                            " Author:      Yggdroot <archofortune@gmail.com>
                            "
                            " Description: To show the indention levels with thin vertical lines
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000005 if !has("conceal") || exists("g:indentLine_loaded")
                                finish
                            endif
    1              0.000002 let g:indentLine_loaded = 1
                            
    1              0.000005 let g:indentLine_newVersion = get(g:,'indentLine_newVersion',v:version > 704 || v:version == 704 && has("patch792"))
                            
    1              0.000006 let g:indentLine_char = get(g:, 'indentLine_char', (&encoding ==# "utf-8" && &term isnot# "linux" ? '¦' : '|'))
    1              0.000005 let g:indentLine_first_char = get(g:, 'indentLine_first_char', (&encoding ==# "utf-8" && &term isnot# "linux" ? '¦' : '|'))
    1              0.000003 let g:indentLine_indentLevel = get(g:, 'indentLine_indentLevel', 20)
    1              0.000002 let g:indentLine_enabled = get(g:, 'indentLine_enabled', 1)
    1              0.000003 let g:indentLine_fileType = get(g:, 'indentLine_fileType', [])
    1              0.000003 let g:indentLine_fileTypeExclude = get(g:, 'indentLine_fileTypeExclude', [])
    1              0.000002 let g:indentLine_bufNameExclude = get(g:, 'indentLine_bufNameExclude', [])
    1              0.000003 let g:indentLine_bufTypeExclude = get(g:, 'indentLine_bufTypeExclude', [])
    1              0.000003 let g:indentLine_showFirstIndentLevel = get(g:, 'indentLine_showFirstIndentLevel', 0)
    1              0.000002 let g:indentLine_maxLines = get(g:, 'indentLine_maxLines', 3000)
    1              0.000002 let g:indentLine_setColors = get(g:, 'indentLine_setColors', 1)
    1              0.000002 let g:indentLine_setConceal = get(g:, 'indentLine_setConceal', 1)
    1              0.000003 let g:indentLine_defaultGroup = get(g:, 'indentLine_defaultGroup', "")
    1              0.000002 let g:indentLine_faster = get(g:, 'indentLine_faster', 0)
    1              0.000005 let g:indentLine_leadingSpaceChar = get(g:, 'indentLine_leadingSpaceChar', (&encoding ==# "utf-8" && &term isnot# "linux" ? '˰' : '.'))
    1              0.000003 let g:indentLine_leadingSpaceEnabled = get(g:, 'indentLine_leadingSpaceEnabled', 0)
    1              0.000013 let g:indentLine_mysyntaxfile = fnamemodify(expand("<sfile>"), ":p:h:h")."/syntax/indentLine.vim"
                            
                            "{{{1 function! s:InitColor()
    1              0.000002 function! s:InitColor()
                                if !g:indentLine_setColors
                                    return
                                endif
                            
                                let default_term_bg = "NONE"
                                let default_gui_bg  = "NONE"
                                if &background ==# "light"
                                    let default_term_fg = 249
                                    let default_gui_fg = "Grey70"
                                else
                                    let default_term_fg = 239
                                    let default_gui_fg = "Grey30"
                                endif
                            
                                if g:indentLine_defaultGroup != ""
                                    let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                    let default_term_fg = synIDattr(default_id, "fg", "term") == "" ? default_term_fg :  synIDattr(default_id, "fg", "term")
                                    let default_term_bg = synIDattr(default_id, "bg", "term") == "" ? default_term_bg :  synIDattr(default_id, "bg", "term")
                                    let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                    let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
                                endif
                            
                                if !exists("g:indentLine_color_term")
                                    let term_color = default_term_fg
                                else
                                    let term_color = g:indentLine_color_term
                                endif
                            
                                if !exists("g:indentLine_bgcolor_term")
                                    let term_bgcolor = default_term_bg
                                else
                                    let term_bgcolor = g:indentLine_bgcolor_term
                                endif
                            
                                if !exists("g:indentLine_color_gui")
                                    let gui_color = default_gui_fg
                                else
                                    let gui_color = g:indentLine_color_gui
                                endif
                            
                                if !exists("g:indentLine_bgcolor_gui")
                                    let gui_bgcolor = default_gui_bg
                                else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
                                endif
                            
                                execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
                                execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
                                if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
                                endif
                            endfunction
                            
                            "{{{1 function! s:SetConcealOption()
    1              0.000002 function! s:SetConcealOption()
                                if !g:indentLine_setConceal
                                    return
                                endif
                                if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
                                    let b:indentLine_ConcealOptionSet = 1
                                    let b:indentLine_original_concealcursor = &l:concealcursor
                                    let b:indentLine_original_conceallevel = &l:conceallevel
                                    let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
                                    let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
                                endif
                            endfunction
                            
    1              0.000001 function! s:ResetConcealOption()
                                if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    let &l:concealcursor = b:indentLine_original_concealcursor
                                    let &l:conceallevel = b:indentLine_original_conceallevel
                                    let b:indentLine_ConcealOptionSet = 0
                                endif
                            endfunction
                            
                            "{{{1 function! s:IndentLinesEnable()
    1              0.000001 function! s:IndentLinesEnable()
                                if g:indentLine_newVersion
                                    if &diff
                                        return
                                    endif
                            
                                    if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
                                    endif
                            
                                    if !exists("w:indentLine_indentLineId")
                                        let w:indentLine_indentLineId = []
                                    endif
                            
                                    call s:SetConcealOption()
                            
                                    if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
                                    endif
                            
                                    let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
                                    endfor
                            
                                    return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif
                            endfunction
                            
                            "{{{1 function! s:IndentLinesDisable()
    1              0.000001 function! s:IndentLinesDisable()
                                if g:indentLine_newVersion
                                    if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        for id in w:indentLine_indentLineId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_indentLineId = []
                                    endif
                            
                                    call s:ResetConcealOption()
                                    return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry
                            endfunction
                            
                            "{{{1 function! s:IndentLinesToggle()
    1              0.000001 function! s:IndentLinesToggle()
                                if g:indentLine_newVersion
                                    if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        let b:indentLine_enabled = 0
                                        call s:IndentLinesDisable()
                                    else
                                        let b:indentLine_enabled = 1
                                        call s:IndentLinesEnable()
                                    endif
                            
                                    return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    call s:IndentLinesDisable()
                                else
                                    call s:IndentLinesEnable()
                                endif
                            endfunction
                            
                            "{{{1 function! s:ResetWidth(...)
    1              0.000001 function! s:ResetWidth(...)
                                if 0 < a:0
                                    let &l:shiftwidth = a:1
                                endif
                            
                                let b:indentLine_enabled = 1
                                call s:IndentLinesDisable()
                                call s:IndentLinesEnable()
                            endfunction
                            
                            "{{{1 function! s:Filter()
    1              0.000001 function! s:Filter()
                                if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
                                endif
                            
                                if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
                                endif
                            
                                if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
                                endif
                            
                                for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
                                endfor
                            
                                return 1
                            endfunction
                            
                            "{{{1 function! s:Disable()
    1              0.000001 function! s:Disable()
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                elseif exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    return
                                elseif s:Filter() == 0
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
                                endif
                            endfunction
                            
                            "{{{1 function! s:Setup()
    1              0.000003 function! s:Setup()
                                if &filetype ==# ""
                                    call s:InitColor()
                                endif
                            
                                if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
                                    call s:IndentLinesEnable()
                                endif
                            
                                if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif
                            endfunction
                            
                            "{{{1 function! s:LeadingSpaceEnable()
    1              0.000001 function! s:LeadingSpaceEnable()
                                if g:indentLine_newVersion
                                    if &diff
                                        return
                                    endif
                            
                                    if exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled == 0
                                        return
                                    endif
                            
                                    if !exists("w:indentLine_leadingSpaceId")
                                        let w:indentLine_leadingSpaceId = []
                                    endif
                            
                                    call s:SetConcealOption()
                            
                                    call add(w:indentLine_leadingSpaceId, matchadd('Conceal', '\%(^\s*\)\@<= ', 0, -1, {'conceal': g:indentLine_leadingSpaceChar}))
                            
                                    if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        call s:ResetWidth()
                                    endif
                            
                                    return
                                endif
                            
                                if g:indentLine_faster
                                    echoerr 'LeadingSpace can not be shown when g:indentLine_faster == 1'
                                    return
                                endif
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                                let b:indentLine_leadingSpaceEnabled = 1
                                call s:SetConcealOption()
                                execute 'syntax match IndentLineLeadingSpace /\%(^\s*\)\@<= / containedin=ALLBUT,IndentLine conceal cchar=' . g:indentLine_leadingSpaceChar
                            endfunction
                            
                            "{{{1 function! s:LeadingSpaceDisable()
    1              0.000001 function! s:LeadingSpaceDisable()
                                if g:indentLine_newVersion
                                    if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
                                    endif
                            
                                    return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry
                            endfunction
                            
                            "{{{1 function! s:LeadingSpaceToggle()
    1              0.000001 function! s:LeadingSpaceToggle()
                                if g:indentLine_newVersion
                                    if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        let b:indentLine_leadingSpaceEnabled = 0
                                        call s:LeadingSpaceDisable()
                                    else
                                        let b:indentLine_leadingSpaceEnabled = 1
                                        call s:LeadingSpaceEnable()
                                    endif
                            
                                    return
                                endif
                            
                                if exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceDisable()
                                else
                                    call s:LeadingSpaceEnable()
                                endif
                            endfunction
                            
                            "{{{1 augroup indentLine
    1              0.000002 augroup indentLine
    1              0.000037     autocmd!
    1              0.000002     if g:indentLine_newVersion
    1              0.000009         autocmd BufRead,BufNewFile,ColorScheme,Syntax * call <SID>InitColor()
    1              0.000002         if exists("##WinNew")
    1              0.000006             autocmd WinNew * call <SID>Setup()
    1              0.000001         endif
    1              0.000003         autocmd BufWinEnter * call <SID>IndentLinesDisable() | call <SID>LeadingSpaceDisable() | call <SID>Setup()
    1              0.000003         autocmd FileType * call <SID>Disable()
    1              0.000001     else
                                    autocmd BufWinEnter * call <SID>Setup()
                                    autocmd User * if exists("b:indentLine_enabled") || exists("b:indentLine_leadingSpaceEnabled") |
                                                    \ call <SID>Setup() | endif
                                    autocmd BufRead,BufNewFile,ColorScheme,Syntax * call <SID>InitColor()
                                    autocmd BufUnload * let b:indentLine_enabled = 0 | let b:indentLine_leadingSpaceEnabled = 0
                                    autocmd SourcePre $VIMRUNTIME/syntax/nosyntax.vim doautocmd indentLine BufUnload
                                    autocmd FileChangedShellPost * doautocmd indentLine BufUnload | call <SID>Setup()
                                endif
    1              0.000001 augroup END
                            
                            "{{{1 commands
    1              0.000004 command! -nargs=? IndentLinesReset call <SID>ResetWidth(<f-args>)
    1              0.000003 command! IndentLinesToggle call <SID>IndentLinesToggle()
    1              0.000001 if g:indentLine_newVersion
    1              0.000004     command! IndentLinesEnable let b:indentLine_enabled = 1 | call <SID>IndentLinesEnable()
    1              0.000004     command! IndentLinesDisable let b:indentLine_enabled = 0 | call <SID>IndentLinesDisable()
    1              0.000004     command! LeadingSpaceEnable let b:indentLine_leadingSpaceEnabled = 1 | call <SID>LeadingSpaceEnable()
    1              0.000004     command! LeadingSpaceDisable let b:indentLine_leadingSpaceEnabled = 0 | call <SID>LeadingSpaceDisable()
    1              0.000001 else
                                command! IndentLinesEnable call <SID>IndentLinesEnable()
                                command! IndentLinesDisable call <SID>IndentLinesDisable()
                                command! LeadingSpaceEnable call <SID>LeadingSpaceEnable()
                                command! LeadingSpaceDisable call <SID>LeadingSpaceDisable()
                            endif
    1              0.000003 command! LeadingSpaceToggle call <SID>LeadingSpaceToggle()
                            
                            " vim:et:ts=4:sw=4:fdm=marker:fmr={{{,}}}
                            

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/tabular/after/plugin/TabularMaps.vim
Sourced 1 time
Total time:   0.002372
 Self time:   0.002372

count  total (s)   self (s)
                            " Copyright (c) 2016, Matthew J. Wozniski
                            " All rights reserved.
                            "
                            " Redistribution and use in source and binary forms, with or without
                            " modification, are permitted provided that the following conditions are met:
                            "     * Redistributions of source code must retain the above copyright notice,
                            "       this list of conditions and the following disclaimer.
                            "     * Redistributions in binary form must reproduce the above copyright
                            "       notice, this list of conditions and the following disclaimer in the
                            "       documentation and/or other materials provided with the distribution.
                            "     * The names of the contributors may not be used to endorse or promote
                            "       products derived from this software without specific prior written
                            "       permission.
                            "
                            " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
                            " OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
                            " OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
                            " NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
                            " INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
                            " LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
                            " OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                            " LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                            " NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
                            " EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            
    1              0.000006 if !exists(':Tabularize') || get(g:, 'no_default_tabular_maps', 0)
                              finish " Tabular.vim wasn't loaded or the default maps are unwanted
                            endif
                            
    1              0.000004 let s:save_cpo = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000616 AddTabularPattern!  assignment      /[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*=/l1r1
    1              0.000114 AddTabularPattern!  two_spaces      /  /l0
                            
    1              0.000325 AddTabularPipeline! multiple_spaces /  / map(a:lines, "substitute(v:val, '   *', '  ', 'g')") | tabular#TabularizeStrings(a:lines, '  ', 'l0')
                            
    1              0.000675 AddTabularPipeline! argument_list   /(.*)/ map(a:lines, 'substitute(v:val, ''\s*\([(,)]\)\s*'', ''\1'', ''g'')')
                                                                   \ | tabular#TabularizeStrings(a:lines, '[(,)]', 'l0')
                                                                   \ | map(a:lines, 'substitute(v:val, ''\(\s*\),'', '',\1 '', "g")')
                                                                   \ | map(a:lines, 'substitute(v:val, ''\s*)'', ")", "g")')
                            
    1              0.000002 function! SplitCDeclarations(lines)
                              let rv = []
                              for line in a:lines
                                " split the line into declaractions
                                let split = split(line, '\s*[,;]\s*')
                                " separate the type from the first declaration
                                let type = substitute(split[0], '\%(\%([&*]\s*\)*\)\=\k\+$', '', '')
                                " add the ; back on every declaration
                                call map(split, 'v:val . ";"')
                                " add the first element to the return as-is, and remove it from the list
                                let rv += [ remove(split, 0) ]
                                " transform the other elements by adding the type on at the beginning
                                call map(split, 'type . v:val')
                                " and add them all to the return
                                let rv += split
                              endfor
                              return rv
                            endfunction
                            
    1              0.000143 AddTabularPipeline! split_declarations /,.*;/ SplitCDeclarations(a:lines)
                            
    1              0.000112 AddTabularPattern! ternary_operator /^.\{-}\zs?\|:/l1
                            
    1              0.000103 AddTabularPattern! cpp_io /<<\|>>/l1
                            
    1              0.000102 AddTabularPattern! pascal_assign /:=/l1
                            
    1              0.000113 AddTabularPattern! trailing_c_comments /\/\*\|\*\/\|\/\//l1
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/tabular/autoload/tabular.vim
Sourced 1 time
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
                            " Tabular:     Align columnar data using regex-designated column boundaries
                            " Maintainer:  Matthew Wozniski (godlygeek@gmail.com)
                            " Date:        Thu, 03 May 2012 20:49:32 -0400
                            " Version:     1.0
                            "
                            " Long Description:
                            " Sometimes, it's useful to line up text.  Naturally, it's nicer to have the
                            " computer do this for you, since aligning things by hand quickly becomes
                            " unpleasant.  While there are other plugins for aligning text, the ones I've
                            " tried are either impossibly difficult to understand and use, or too simplistic
                            " to handle complicated tasks.  This plugin aims to make the easy things easy
                            " and the hard things possible, without providing an unnecessarily obtuse
                            " interface.  It's still a work in progress, and criticisms are welcome.
                            "
                            " License:
                            " Copyright (c) 2012, Matthew J. Wozniski
                            " All rights reserved.
                            "
                            " Redistribution and use in source and binary forms, with or without
                            " modification, are permitted provided that the following conditions are met:
                            "     * Redistributions of source code must retain the above copyright notice,
                            "       this list of conditions and the following disclaimer.
                            "     * Redistributions in binary form must reproduce the above copyright
                            "       notice, this list of conditions and the following disclaimer in the
                            "       documentation and/or other materials provided with the distribution.
                            "     * The names of the contributors may not be used to endorse or promote
                            "       products derived from this software without specific prior written
                            "       permission.
                            "
                            " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
                            " OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
                            " OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
                            " NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
                            " INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
                            " LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
                            " OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
                            " LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
                            " NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
                            " EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            
                            " Stupid vimscript crap                                                   {{{1
    1              0.000005 let s:savecpo = &cpo
    1              0.000004 set cpo&vim
                            
                            " Private Functions                                                       {{{1
                            
                            " Return the number of bytes in a string after expanding tabs to spaces.  {{{2
                            " This expansion is done based on the current value of 'tabstop'
    1              0.000003 if exists('*strdisplaywidth')
                              " Needs vim 7.3
    1              0.000005   let s:Strlen = function("strdisplaywidth")
    1              0.000003 else
                              function! s:Strlen(string)
                                " Implement the tab handling part of strdisplaywidth for vim 7.2 and
                                " earlier - not much that can be done about handling doublewidth
                                " characters.
                                let rv = 0
                                let i = 0
                            
                                for char in split(a:string, '\zs')
                                  if char == "\t"
                                    let rv += &ts - i
                                    let i = 0
                                  else
                                    let rv += 1
                                    let i = (i + 1) % &ts
                                  endif
                                endfor
                            
                                return rv
                              endfunction
                            endif
                            
                            " Align a string within a field                                           {{{2
                            " These functions do not trim leading and trailing spaces.
                            
                            " Right align 'string' in a field of size 'fieldwidth'
    1              0.000002 function! s:Right(string, fieldwidth)
                              let spaces = a:fieldwidth - s:Strlen(a:string)
                              return matchstr(a:string, '^\s*') . repeat(" ", spaces) . substitute(a:string, '^\s*', '', '')
                            endfunction
                            
                            " Left align 'string' in a field of size 'fieldwidth'
    1              0.000003 function! s:Left(string, fieldwidth)
                              let spaces = a:fieldwidth - s:Strlen(a:string)
                              return a:string . repeat(" ", spaces)
                            endfunction
                            
                            " Center align 'string' in a field of size 'fieldwidth'
    1              0.000001 function! s:Center(string, fieldwidth)
                              let spaces = a:fieldwidth - s:Strlen(a:string)
                              let right = spaces / 2
                              let left = right + (right * 2 != spaces)
                              return repeat(" ", left) . a:string . repeat(" ", right)
                            endfunction
                            
                            " Remove spaces around a string                                           {{{2
                            
                            " Remove all trailing spaces from a string.
    1              0.000001 function! s:StripTrailingSpaces(string)
                              return matchstr(a:string, '^.\{-}\ze\s*$')
                            endfunction
                            
                            " Remove all leading spaces from a string.
    1              0.000001 function! s:StripLeadingSpaces(string)
                              return matchstr(a:string, '^\s*\zs.*$')
                            endfunction
                            
                            " Split a string into fields and delimiters                               {{{2
                            " Like split(), but include the delimiters as elements
                            " All odd numbered elements are delimiters
                            " All even numbered elements are non-delimiters (including zero)
    1              0.000002 function! s:SplitDelim(string, delim)
                              let rv = []
                              let beg = 0
                            
                              let len = len(a:string)
                              let searchoff = 0
                            
                              while 1
                                let mid = match(a:string, a:delim, beg + searchoff, 1)
                                if mid == -1 || mid == len
                                  break
                                endif
                            
                                let matchstr = matchstr(a:string, a:delim, beg + searchoff, 1)
                                let length = strlen(matchstr)
                            
                                if length == 0 && beg == mid
                                  " Zero-length match for a zero-length delimiter - advance past it
                                  let searchoff += 1
                                  continue
                                endif
                            
                                if beg == mid
                                  let rv += [ "" ]
                                else
                                  let rv += [ a:string[beg : mid-1] ]
                                endif
                            
                                let rv += [ matchstr ]
                            
                                let beg = mid + length
                                let searchoff = 0
                              endwhile
                            
                              let rv += [ strpart(a:string, beg) ]
                            
                              return rv
                            endfunction
                            
                            " Replace lines from `start' to `start + len - 1' with the given strings. {{{2
                            " If more lines are needed to show all strings, they will be added.
                            " If there are too few strings to fill all lines, lines will be removed.
    1              0.000002 function! s:SetLines(start, len, strings)
                              if a:start > line('$') + 1 || a:start < 1
                                throw "Invalid start line!"
                              endif
                            
                              if len(a:strings) > a:len
                                let fensave = &fen
                                let view = winsaveview()
                                call append(a:start + a:len - 1, repeat([''], len(a:strings) - a:len))
                                call winrestview(view)
                                let &fen = fensave
                              elseif len(a:strings) < a:len
                                let fensave = &fen
                                let view = winsaveview()
                                sil exe (a:start + len(a:strings)) . ',' .  (a:start + a:len - 1) . 'd_'
                                call winrestview(view)
                                let &fen = fensave
                              endif
                            
                              call setline(a:start, a:strings)
                            endfunction
                            
                            " Runs the given commandstring argument as an expression.                 {{{2
                            " The commandstring expression is expected to reference the a:lines argument.
                            " If the commandstring expression returns a list the items of that list will
                            " replace the items in a:lines, otherwise the expression is assumed to have
                            " modified a:lines itself.
    1              0.000002 function! s:FilterString(lines, commandstring)
                              exe 'let rv = ' . a:commandstring
                            
                              if type(rv) == type(a:lines) && rv isnot a:lines
                                call filter(a:lines, 0)
                                call extend(a:lines, rv)
                              endif
                            endfunction
                            
                            " Public API                                                              {{{1
                            
    1              0.000003 if !exists("g:tabular_default_format")
    1              0.000002   let g:tabular_default_format = "l1"
    1              0.000001 endif
                            
    1              0.000002 let s:formatelempat = '\%([lrc]\d\+\)'
                            
    1              0.000002 function! tabular#ElementFormatPattern()
                              return s:formatelempat
                            endfunction
                            
                            " Given a list of strings and a delimiter, split each string on every
                            " occurrence of the delimiter pattern, format each element according to either
                            " the provided format (optional) or the default format, and join them back
                            " together with enough space padding to guarantee that the nth delimiter of
                            " each string is aligned.
    1              0.000002 function! tabular#TabularizeStrings(strings, delim, ...)
                              if a:0 > 1
                                echoerr "TabularizeStrings accepts only 2 or 3 arguments (got ".(a:0+2).")"
                                return 1
                              endif
                            
                              let formatstr = (a:0 ? a:1 : g:tabular_default_format)
                            
                              if formatstr !~? s:formatelempat . '\+'
                                echoerr "Tabular: Invalid format \"" . formatstr . "\" specified!"
                                return 1
                              endif
                            
                              let format = split(formatstr, s:formatelempat . '\zs')
                            
                              let lines = map(a:strings, 's:SplitDelim(v:val, a:delim)')
                            
                              " Strip spaces
                              "   - Only from non-delimiters; spaces in delimiters must have been matched
                              "     intentionally
                              "   - Don't strip leading spaces from the first element; we like indenting.
                              for line in lines
                                if len(line) == 1 && s:do_gtabularize
                                  continue " Leave non-matching lines unchanged for GTabularize
                                endif
                            
                                if line[0] !~ '^\s*$'
                                  let line[0] = s:StripTrailingSpaces(line[0])
                                endif
                                if len(line) >= 3
                                  for i in range(2, len(line)-1, 2)
                                    let line[i] = s:StripLeadingSpaces(s:StripTrailingSpaces(line[i]))
                                  endfor
                                endif
                              endfor
                            
                              " Find the max length of each field
                              let maxes = []
                              for line in lines
                                if len(line) == 1 && s:do_gtabularize
                                  continue " non-matching lines don't affect field widths for GTabularize
                                endif
                            
                                for i in range(len(line))
                                  if i == len(maxes)
                                    let maxes += [ s:Strlen(line[i]) ]
                                  else
                                    let maxes[i] = max( [ maxes[i], s:Strlen(line[i]) ] )
                                  endif
                                endfor
                              endfor
                            
                              let lead_blank = empty(filter(copy(lines), 'v:val[0] =~ "\\S"'))
                            
                              " Concatenate the fields, according to the format pattern.
                              for idx in range(len(lines))
                                let line = lines[idx]
                            
                                if len(line) == 1 && s:do_gtabularize
                                  let lines[idx] = line[0] " GTabularize doesn't change non-matching lines
                                  continue
                                endif
                            
                                for i in range(len(line))
                                  let how = format[i % len(format)][0]
                                  let pad = format[i % len(format)][1:-1]
                            
                                  if how =~? 'l'
                                    let field = s:Left(line[i], maxes[i])
                                  elseif how =~? 'r'
                                    let field = s:Right(line[i], maxes[i])
                                  elseif how =~? 'c'
                                    let field = s:Center(line[i], maxes[i])
                                  endif
                            
                                  let line[i] = field . (lead_blank && i == 0 ? '' : repeat(" ", pad))
                                endfor
                            
                                let lines[idx] = s:StripTrailingSpaces(join(line, ''))
                              endfor
                            endfunction
                            
                            " Apply 0 or more filters, in sequence, to selected text in the buffer    {{{2
                            " The lines to be filtered are determined as follows:
                            "   If the function is called with a range containing multiple lines, then
                            "     those lines will be used as the range.
                            "   If the function is called with no range or with a range of 1 line, then
                            "     if GTabularize mode is being used,
                            "       the range will not be adjusted
                            "     if "includepat" is not specified,
                            "       that 1 line will be filtered,
                            "     if "includepat" is specified and that line does not match it,
                            "       no lines will be filtered
                            "     if "includepat" is specified and that line does match it,
                            "       all contiguous lines above and below the specified line matching the
                            "       pattern will be filtered.
                            "
                            " The remaining arguments must each be a filter to apply to the text.
                            " Each filter must either be a String evaluating to a function to be called.
    1              0.000002 function! tabular#PipeRange(includepat, ...) range
                              exe a:firstline . ',' . a:lastline
                                  \ . 'call tabular#PipeRangeWithOptions(a:includepat, a:000, {})'
                            endfunction
                            
                            " Extended version of tabular#PipeRange, which
                            " 1) Takes the list of filters as an explicit list rather than as varargs
                            " 2) Supports passing a dictionary of options to control the routine.
                            "    Currently, the only supported option is 'mode', which determines whether
                            "    to behave as :Tabularize or as :GTabularize
                            " This allows me to add new features here without breaking API compatibility
                            " in the future.
    1              0.000002 function! tabular#PipeRangeWithOptions(includepat, filterlist, options) range
                              let top = a:firstline
                              let bot = a:lastline
                            
                              let s:do_gtabularize = (get(a:options, 'mode', '') ==# 'GTabularize')
                            
                              if !s:do_gtabularize
                                " In the default mode, apply range extension logic
                                if a:includepat != '' && top == bot
                                  if top < 0 || top > line('$') || getline(top) !~ a:includepat
                                    return
                                  endif
                                  while top > 1 && getline(top-1) =~ a:includepat
                                    let top -= 1
                                  endwhile
                                  while bot < line('$') && getline(bot+1) =~ a:includepat
                                    let bot += 1
                                  endwhile
                                endif
                              endif
                            
                              let lines = map(range(top, bot), 'getline(v:val)')
                            
                              for filter in a:filterlist
                                if type(filter) != type("")
                                  echoerr "PipeRange: Bad filter: " . string(filter)
                                endif
                            
                                call s:FilterString(lines, filter)
                            
                                unlet filter
                              endfor
                            
                              call s:SetLines(top, bot - top + 1, lines)
                            endfunction
                            
                            " Part of the public interface so interested pipelines can query this and
                            " adjust their behavior appropriately.
    1              0.000001 function! tabular#DoGTabularize()
                              return s:do_gtabularize
                            endfunction
                            
    1              0.000002 function! s:SplitDelimTest(string, delim, expected)
                              let result = s:SplitDelim(a:string, a:delim)
                            
                              if result !=# a:expected
                                echomsg 'Test failed!'
                                echomsg '  string=' . string(a:string) . '  delim=' . string(a:delim)
                                echomsg '  Returned=' . string(result)
                                echomsg '  Expected=' . string(a:expected)
                              endif
                            endfunction
                            
    1              0.000003 function! tabular#SplitDelimUnitTest()
                              let assignment = '[|&+*/%<>=!~-]\@<!\([<>!=]=\|=\~\)\@![|&+*/%<>=!~-]*='
                              let two_spaces = '  '
                              let ternary_operator = '^.\{-}\zs?\|:'
                              let cpp_io = '<<\|>>'
                              let pascal_assign = ':='
                              let trailing_c_comments = '\/\*\|\*\/\|\/\/'
                            
                              call s:SplitDelimTest('a+=b',    assignment, ['a', '+=', 'b'])
                              call s:SplitDelimTest('a-=b',    assignment, ['a', '-=', 'b'])
                              call s:SplitDelimTest('a!=b',    assignment, ['a!=b'])
                              call s:SplitDelimTest('a==b',    assignment, ['a==b'])
                              call s:SplitDelimTest('a&=b',    assignment, ['a', '&=', 'b'])
                              call s:SplitDelimTest('a|=b',    assignment, ['a', '|=', 'b'])
                              call s:SplitDelimTest('a=b=c',   assignment, ['a', '=', 'b', '=', 'c'])
                            
                              call s:SplitDelimTest('a  b  c', two_spaces, ['a', '  ', 'b', '  ', 'c'])
                              call s:SplitDelimTest('a b   c', two_spaces, ['a b', '  ', ' c'])
                              call s:SplitDelimTest('ab    c', two_spaces, ['ab', '  ', '', '  ', 'c'])
                            
                              call s:SplitDelimTest('a?b:c',   ternary_operator, ['a', '?', 'b', ':', 'c'])
                            
                              call s:SplitDelimTest('a<<b<<c', cpp_io, ['a', '<<', 'b', '<<', 'c'])
                            
                              call s:SplitDelimTest('a:=b=c',  pascal_assign, ['a', ':=', 'b=c'])
                            
                              call s:SplitDelimTest('x//foo',  trailing_c_comments, ['x', '//', 'foo'])
                              call s:SplitDelimTest('x/*foo*/',trailing_c_comments, ['x', '/*', 'foo', '*/', ''])
                            
                              call s:SplitDelimTest('#ab#cd#ef', '[^#]*', ['#', 'ab', '#', 'cd', '#', 'ef', ''])
                              call s:SplitDelimTest('#ab#cd#ef', '#\zs',  ['#', '', 'ab#', '', 'cd#', '', 'ef'])
                            endfunction
                            
                            " Stupid vimscript crap, part 2                                           {{{1
    1              0.000005 let &cpo = s:savecpo
    1              0.000002 unlet s:savecpo
                            
                            " vim:set sw=2 sts=2 fdm=marker:

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/lightline.vim/autoload/lightline.vim
Sourced 1 time
Total time:   0.000778
 Self time:   0.000778

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: autoload/lightline.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2018/06/22 08:50:00.
                            " =============================================================================
                            
    1              0.000009 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000003 let s:_ = 1
                            
    1              0.000003 function! lightline#update() abort
                              if s:_
                                call lightline#init()
                                call lightline#colorscheme()
                              endif
                              if !s:lightline.enable.statusline
                                return
                              endif
                              let w = winnr()
                              let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
                              for n in range(1, winnr('$'))
                                call setwinvar(n, '&statusline', s[n!=w])
                                call setwinvar(n, 'lightline', n!=w)
                              endfor
                            endfunction
                            
    1              0.000002 function! lightline#update_once() abort
                              if !exists('w:lightline') || w:lightline
                                call lightline#update()
                              endif
                            endfunction
                            
    1              0.000001 function! lightline#update_disable() abort
                              if !s:lightline.enable.statusline
                                return
                              endif
                              call setwinvar(0, '&statusline', '')
                            endfunction
                            
    1              0.000001 function! lightline#enable() abort
                              call lightline#colorscheme()
                              call lightline#update()
                              if s:lightline.enable.tabline
                                set tabline=%!lightline#tabline()
                              endif
                              augroup lightline
                                autocmd!
                                autocmd WinEnter,BufWinEnter,FileType,SessionLoadPost * call lightline#update()
                                autocmd SessionLoadPost * call lightline#highlight()
                                autocmd ColorScheme * if !has('vim_starting') || expand('<amatch>') !=# 'macvim'
                                      \ | call lightline#update() | call lightline#highlight() | endif
                                autocmd CursorMoved,BufUnload * call lightline#update_once()
                              augroup END
                              augroup lightline-disable
                                autocmd!
                              augroup END
                              augroup! lightline-disable
                            endfunction
                            
    1              0.000002 function! lightline#disable() abort
                              let [&statusline, &tabline] = [get(s:, '_statusline', ''), get(s:, '_tabline', '')]
                              for t in range(1, tabpagenr('$'))
                                for n in range(1, tabpagewinnr(t, '$'))
                                  call settabwinvar(t, n, '&statusline', '')
                                endfor
                              endfor
                              augroup lightline
                                autocmd!
                              augroup END
                              augroup! lightline
                              augroup lightline-disable
                                autocmd!
                                autocmd WinEnter * call lightline#update_disable()
                              augroup END
                            endfunction
                            
    1              0.000001 function! lightline#toggle() abort
                              if exists('#lightline')
                                call lightline#disable()
                              else
                                call lightline#enable()
                              endif
                            endfunction
                            
    1              0.000223 let s:_lightline = {
                                  \   'active': {
                                  \     'left': [['mode', 'paste'], ['readonly', 'filename', 'modified']],
                                  \     'right': [['lineinfo'], ['percent'], ['fileformat', 'fileencoding', 'filetype']]
                                  \   },
                                  \   'inactive': {
                                  \     'left': [['filename']],
                                  \     'right': [['lineinfo'], ['percent']]
                                  \   },
                                  \   'tabline': {
                                  \     'left': [['tabs']],
                                  \     'right': [['close']]
                                  \   },
                                  \   'tab': {
                                  \     'active': ['tabnum', 'filename', 'modified'],
                                  \     'inactive': ['tabnum', 'filename', 'modified']
                                  \   },
                                  \   'component': {
                                  \     'mode': '%{lightline#mode()}',
                                  \     'absolutepath': '%F', 'relativepath': '%f', 'filename': '%t', 'modified': '%M', 'bufnum': '%n',
                                  \     'paste': '%{&paste?"PASTE":""}', 'readonly': '%R', 'charvalue': '%b', 'charvaluehex': '%B',
                                  \     'spell': '%{&spell?&spelllang:""}', 'fileencoding': '%{&fenc!=#""?&fenc:&enc}', 'fileformat': '%{&ff}',
                                  \     'filetype': '%{&ft!=#""?&ft:"no ft"}', 'percent': '%3p%%', 'percentwin': '%P',
                                  \     'lineinfo': '%3l:%-2v', 'line': '%l', 'column': '%c', 'close': '%999X X ', 'winnr': '%{winnr()}'
                                  \   },
                                  \   'component_visible_condition': {
                                  \     'modified': '&modified||!&modifiable', 'readonly': '&readonly', 'paste': '&paste', 'spell': '&spell'
                                  \   },
                                  \   'component_function': {},
                                  \   'component_function_visible_condition': {},
                                  \   'component_expand': {
                                  \     'tabs': 'lightline#tabs'
                                  \   },
                                  \   'component_type': {
                                  \     'tabs': 'tabsel', 'close': 'raw'
                                  \   },
                                  \   'component_raw': {},
                                  \   'tab_component': {},
                                  \   'tab_component_function': {
                                  \     'filename': 'lightline#tab#filename', 'modified': 'lightline#tab#modified',
                                  \     'readonly': 'lightline#tab#readonly', 'tabnum': 'lightline#tab#tabnum'
                                  \   },
                                  \   'colorscheme': 'default',
                                  \   'mode_map': {
                                  \     'n': 'NORMAL', 'i': 'INSERT', 'R': 'REPLACE', 'v': 'VISUAL', 'V': 'V-LINE', "\<C-v>": 'V-BLOCK',
                                  \     'c': 'COMMAND', 's': 'SELECT', 'S': 'S-LINE', "\<C-s>": 'S-BLOCK', 't': 'TERMINAL'
                                  \   },
                                  \   'separator': { 'left': '', 'right': '' },
                                  \   'subseparator': { 'left': '|', 'right': '|' },
                                  \   'tabline_separator': {},
                                  \   'tabline_subseparator': {},
                                  \   'enable': { 'statusline': 1, 'tabline': 1 },
                                  \   '_mode_': {
                                  \     'n': 'normal', 'i': 'insert', 'R': 'replace', 'v': 'visual', 'V': 'visual', "\<C-v>": 'visual',
                                  \     'c': 'command', 's': 'select', 'S': 'select', "\<C-s>": 'select', 't': 'terminal'
                                  \   },
                                  \   'mode_fallback': { 'replace': 'insert', 'terminal': 'insert', 'select': 'visual' },
                                  \   'palette': {},
                                  \   'winwidth': winwidth(0),
                                  \ }
    1              0.000004 function! lightline#init() abort
                              let s:lightline = deepcopy(get(g:, 'lightline', {}))
                              for [key, value] in items(s:_lightline)
                                if type(value) == 4
                                  if !has_key(s:lightline, key)
                                    let s:lightline[key] = {}
                                  endif
                                  call extend(s:lightline[key], value, 'keep')
                                elseif !has_key(s:lightline, key)
                                  let s:lightline[key] = value
                                endif
                                unlet value
                              endfor
                              call extend(s:lightline.tabline_separator, s:lightline.separator, 'keep')
                              call extend(s:lightline.tabline_subseparator, s:lightline.subseparator, 'keep')
                              let s:lightline.tabline_configured = has_key(get(get(g:, 'lightline', {}), 'component_expand', {}), 'tabs')
                              for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
                                if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
                                  let s:lightline.tabline_configured = 1
                                  break
                                endif
                              endfor
                              if !exists('s:_statusline')
                                let s:_statusline = &statusline
                              endif
                              if !exists('s:_tabline')
                                let s:_tabline = &tabline
                              endif
                              if s:lightline.enable.tabline
                                set tabline=%!lightline#tabline()
                              else
                                let &tabline = get(s:, '_tabline', '')
                              endif
                              for f in values(s:lightline.component_function)
                                silent! call call(f, [])
                              endfor
                              for f in values(s:lightline.tab_component_function)
                                silent! call call(f, [1])
                              endfor
                              let s:mode = ''
                            endfunction
                            
    1              0.000002 function! lightline#colorscheme() abort
                              try
                                let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
                              catch
                                call lightline#error('Could not load colorscheme ' . s:lightline.colorscheme . '.')
                                let s:lightline.colorscheme = 'default'
                                let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
                              finally
                                if has('win32') && !has('gui_running') && &t_Co < 256
                                  for u in values(s:lightline.palette)
                                    for v in values(u)
                                      for _  in v
                                        let [_[2], _[3]] = [lightline#colortable#gui2cui(_[0], _[2]), lightline#colortable#gui2cui(_[1], _[3])]
                                      endfor
                                    endfor
                                  endfor
                                endif
                                let s:highlight = {}
                                call lightline#highlight('normal')
                                call lightline#link()
                                let s:_ = 0
                              endtry
                            endfunction
                            
    1              0.000001 function! lightline#palette() abort
                              return s:lightline.palette
                            endfunction
                            
    1              0.000001 function! lightline#mode() abort
                              return get(s:lightline.mode_map, mode(), '')
                            endfunction
                            
    1              0.000002 let s:mode = ''
    1              0.000002 function! lightline#link(...) abort
                              let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
                              if s:mode == mode
                                return ''
                              endif
                              let s:mode = mode
                              if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
                              endif
                              let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
                              for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
                                for [i, t] in map(range(0, l), '[v:val, 0]') + types
                                  if i != l
                                    exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
                                  endif
                                  for [j, s] in map(range(0, l), '[v:val, 0]') + types
                                    if i + 1 == j || t || s && i != l
                                      exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
                                    endif
                                  endfor
                                endfor
                              endfor
                              exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
                              return ''
                            endfunction
                            
    1              0.000003 function! s:term(p) abort
                              return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
                            endfunction
                            
    1              0.000003 if exists('*uniq')
    1              0.000004   let s:uniq = function('uniq')
    1              0.000001 else
                              function! s:uniq(xs) abort
                                let i = len(a:xs) - 1
                                while i > 0
                                  if a:xs[i] ==# a:xs[i - 1]
                                    call remove(a:xs, i)
                                  endif
                                  let i -= 1
                                endwhile
                                return a:xs
                              endfunction
                            endif
                            
    1              0.000002 function! lightline#highlight(...) abort
                              let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
                              let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
                              let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
                              let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
                              let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
                              for mode in modes
                                let s:highlight[mode] = 1
                                let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
                                let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
                                let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
                                let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
                                let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
                                let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
                                for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
                                  for [i, t] in map(range(0, l), '[v:val, 0]') + types
                                    if i < l || i < 1
                                      let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
                                      exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
                                    endif
                                    for [j, s] in map(range(0, l), '[v:val, 0]') + types
                                      if i + 1 == j || t || s && i != l
                                        let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
                                        exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
                                      endif
                                    endfor
                                  endfor
                                endfor
                                exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
                              endfor
                            endfunction
                            
    1              0.000003 function! s:subseparator(components, subseparator, expanded) abort
                              let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
                              let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" :
                                    \ has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") :
                                    \ has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
                              return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
                            endfunction
                            
    1              0.000002 function! lightline#concatenate(xs, right) abort
                              let separator = a:right ? s:lightline.subseparator.right : s:lightline.subseparator.left
                              return join(filter(copy(a:xs), 'v:val !=# ""'), ' ' . separator . ' ')
                            endfunction
                            
    1              0.000002 function! lightline#statusline(inactive) abort
                              if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
                              endif
                              return s:line(0, a:inactive)
                            endfunction
                            
    1              0.000002 function! s:normalize(result) abort
                              if type(a:result) == 3
                                return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
                              elseif type(a:result) == 1
                                return [a:result]
                              else
                                return [string(a:result)]
                              endif
                            endfunction
                            
    1              0.000002 function! s:evaluate_expand(component) abort
                              try
                                let result = eval(a:component . '()')
                                if type(result) == 1 && result ==# ''
                                  return []
                                endif
                              catch
                                return []
                              endtry
                              return map(type(result) == 3 ? (result + [[], [], []])[:2] : [[], [result], []], 'filter(s:normalize(v:val), "v:val !=# ''''")')
                            endfunction
                            
    1              0.000002 function! s:convert(name, index) abort
                              if has_key(s:lightline.component_expand, a:name)
                                let type = get(s:lightline.component_type, a:name, a:index)
                                let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
                                return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]),
                                      \ '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '"]'), 'v:val[0] != []')
                              else
                                return [[[a:name], 0, a:index]]
                              endif
                            endfunction
                            
    1              0.000002 function! s:flatten_twice(xss) abort
                              let ys = []
                              for xs in a:xss
                                for x in xs
                                  let ys += x
                                endfor
                              endfor
                              return ys
                            endfunction
                            
    1              0.000004 if v:version > 702 || v:version == 702 && has('patch295')
    1              0.000004   let s:map = function('map')
    1              0.000001 else
                              function! s:map(xs, f) abort
                                let ys = []
                                for i in range(len(a:xs))
                                  call extend(ys, map(a:xs[(i):(i)], substitute(a:f, 'v:key', i, 'g')))
                                endfor
                                return ys
                              endfunction
                            endif
                            
    1              0.000001 function! s:expand(components) abort
                              let components = []
                              let expanded = []
                              let indices = []
                              let previndex = -1
                              let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
                              for [component, expand, index] in xs
                                if previndex != index
                                  call add(indices, index)
                                  call add(components, [])
                                  call add(expanded, [])
                                endif
                                call extend(components[-1], component)
                                call extend(expanded[-1], repeat([expand], len(component)))
                                let previndex = index
                              endfor
                              call add(indices, string(len(a:components)))
                              return [components, expanded, indices]
                            endfunction
                            
    1              0.000002 function! s:line(tabline, inactive) abort
                              let _ = a:tabline ? '' : '%{lightline#link()}'
                              if s:lightline.palette == {}
                                call lightline#colorscheme()
                              endif
                              let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
                              let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
                              let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
                              let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
                              let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
                              let [lt, lc, ll] = s:expand(copy(l_))
                              let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
                              let [rt, rc, rl] = s:expand(copy(r_))
                              for i in range(len(lt))
                                let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
                                for j in range(len(lt[i]))
                                  let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
                                  let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
                                  if j < len(lt[i]) - 1 && s.left !=# ''
                                    let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
                                  endif
                                endfor
                                let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
                                let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
                              endfor
                              let _ .= '%#LightlineMiddle_' . mode . '#%='
                              for i in reverse(range(len(rt)))
                                let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
                                let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
                                let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
                                for j in range(len(rt[i]))
                                  let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
                                  let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
                                  if j < len(rt[i]) - 1 && s.right !=# ''
                                    let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
                                  endif
                                endfor
                              endfor
                              return _
                            endfunction
                            
    1              0.000002 let s:tabnr = -1
    1              0.000001 let s:tabcnt = -1
    1              0.000001 let s:tabline = ''
    1              0.000002 function! lightline#tabline() abort
                              if !has_key(s:highlight, 'tabline')
                                call lightline#highlight('tabline')
                              endif
                              if s:lightline.tabline_configured || s:tabnr != tabpagenr() || s:tabcnt != tabpagenr('$')
                                let s:tabnr = tabpagenr()
                                let s:tabcnt = tabpagenr('$')
                                let s:tabline = s:line(1, 0)
                              endif
                              return s:tabline
                            endfunction
                            
    1              0.000002 function! lightline#tabs() abort
                              let [x, y, z] = [[], [], []]
                              let nr = tabpagenr()
                              let cnt = tabpagenr('$')
                              for i in range(1, cnt)
                                call add(i < nr ? x : i == nr ? y : z, (i > nr + 3 ? '%<' : '') . '%'. i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
                              endfor
                              let abbr = '...'
                              let n = min([max([s:lightline.winwidth / 40, 2]), 8])
                              if len(x) > n && len(z) > n
                                let x = extend(add(x[:n/2-1], abbr), x[-(n+1)/2:])
                                let z = extend(add(z[:(n+1)/2-1], abbr), z[-n/2:])
                              elseif len(x) + len(z) > 2 * n
                                if len(x) > n
                                  let x = extend(add(x[:(2*n-len(z))/2-1], abbr), x[-(2*n-len(z)+1)/2:])
                                elseif len(z) > n
                                  let z = extend(add(z[:(2*n-len(x)+1)/2-1], abbr), z[-(2*n-len(x))/2:])
                                endif
                              endif
                              return [x, y, z]
                            endfunction
                            
    1              0.000002 function! lightline#onetab(n, active) abort
                              let _ = []
                              for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
                                if has_key(s:lightline.tab_component_function, name)
                                  call add(_, call(s:lightline.tab_component_function[name], [a:n]))
                                else
                                  call add(_, get(s:lightline.tab_component, name, ''))
                                endif
                              endfor
                              return join(filter(_, 'v:val !=# ""'), ' ')
                            endfunction
                            
    1              0.000002 function! lightline#error(msg) abort
                              echohl ErrorMsg
                              echomsg 'lightline.vim: '.a:msg
                              echohl None
                            endfunction
                            
    1              0.000006 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/lightline.vim/autoload/lightline/tab.vim
Sourced 1 time
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: autoload/lightline/tab.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2016/05/07 22:31:02.
                            " =============================================================================
                            
    1              0.000007 let s:save_cpo = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000003 function! lightline#tab#filename(n) abort
                              let buflist = tabpagebuflist(a:n)
                              let winnr = tabpagewinnr(a:n)
                              let _ = expand('#'.buflist[winnr - 1].':t')
                              return _ !=# '' ? _ : '[No Name]'
                            endfunction
                            
    1              0.000002 function! lightline#tab#modified(n) abort
                              let winnr = tabpagewinnr(a:n)
                              return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'
                            endfunction
                            
    1              0.000002 function! lightline#tab#readonly(n) abort
                              let winnr = tabpagewinnr(a:n)
                              return gettabwinvar(a:n, winnr, '&readonly') ? 'RO' : ''
                            endfunction
                            
    1              0.000002 function! lightline#tab#tabnum(n) abort
                              return a:n
                            endfunction
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/lightline.vim/autoload/lightline/colorscheme/default.vim
Sourced 1 time
Total time:   0.002688
 Self time:   0.000144

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: autoload/lightline/colorscheme/default.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2013/08/22 06:05:52.
                            " =============================================================================
                            
    1   0.002678   0.000134 let g:lightline#colorscheme#default#palette = g:lightline#colorscheme#powerline#palette

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/lightline.vim/autoload/lightline/colorscheme/powerline.vim
Sourced 1 time
Total time:   0.002524
 Self time:   0.000213

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: autoload/lightline/colorscheme/powerline.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2013/09/07 15:54:41.
                            " =============================================================================
                            
    1              0.000006 let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
    1              0.000004 let s:p.normal.left = [ ['darkestgreen', 'brightgreen', 'bold'], ['white', 'gray4'] ]
    1              0.000007 let s:p.normal.right = [ ['gray5', 'gray10'], ['gray9', 'gray4'], ['gray8', 'gray2'] ]
    1              0.000003 let s:p.inactive.right = [ ['gray1', 'gray5'], ['gray4', 'gray1'], ['gray4', 'gray0'] ]
    1              0.000003 let s:p.inactive.left = s:p.inactive.right[1:]
    1              0.000003 let s:p.insert.left = [ ['darkestcyan', 'white', 'bold'], ['white', 'darkblue'] ]
    1              0.000004 let s:p.insert.right = [ [ 'darkestcyan', 'mediumcyan' ], [ 'mediumcyan', 'darkblue' ], [ 'mediumcyan', 'darkestblue' ] ]
    1              0.000003 let s:p.replace.left = [ ['white', 'brightred', 'bold'], ['white', 'gray4'] ]
    1              0.000003 let s:p.visual.left = [ ['darkred', 'brightorange', 'bold'], ['white', 'gray4'] ]
    1              0.000004 let s:p.normal.middle = [ [ 'gray7', 'gray2' ] ]
    1              0.000002 let s:p.insert.middle = [ [ 'mediumcyan', 'darkestblue' ] ]
    1              0.000002 let s:p.replace.middle = s:p.normal.middle
    1              0.000001 let s:p.replace.right = s:p.normal.right
    1              0.000002 let s:p.tabline.left = [ [ 'gray9', 'gray4' ] ]
    1              0.000004 let s:p.tabline.tabsel = [ [ 'gray9', 'gray1' ] ]
    1              0.000002 let s:p.tabline.middle = [ [ 'gray2', 'gray8' ] ]
    1              0.000002 let s:p.tabline.right = [ [ 'gray9', 'gray3' ] ]
    1              0.000002 let s:p.normal.error = [ [ 'gray9', 'brightestred' ] ]
    1              0.000002 let s:p.normal.warning = [ [ 'gray1', 'yellow' ] ]
                            
    1   0.002451   0.000140 let g:lightline#colorscheme#powerline#palette = lightline#colorscheme#fill(s:p)

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/lightline.vim/autoload/lightline/colorscheme.vim
Sourced 1 time
Total time:   0.000319
 Self time:   0.000319

count  total (s)   self (s)
                            " =============================================================================
                            " Filename: autoload/lightline/colorscheme.vim
                            " Author: itchyny
                            " License: MIT License
                            " Last Change: 2018/09/01 22:48:24.
                            " =============================================================================
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000037 let s:cuicolor = {
                                  \ 'black'          : 16,
                                  \ 'white'          : 231,
                                  \
                                  \ 'darkestgreen'   : 22,
                                  \ 'darkgreen'      : 28,
                                  \ 'mediumgreen'    : 70,
                                  \ 'brightgreen'    : 148,
                                  \
                                  \ 'darkestcyan'    : 23,
                                  \ 'mediumcyan'     : 117,
                                  \
                                  \ 'darkestblue'    : 24,
                                  \ 'darkblue'       : 31,
                                  \
                                  \ 'darkestred'     : 52,
                                  \ 'darkred'        : 88,
                                  \ 'mediumred'      : 124,
                                  \ 'brightred'      : 160,
                                  \ 'brightestred'   : 196,
                                  \
                                  \ 'darkestpurple'  : 55,
                                  \ 'mediumpurple'   : 98,
                                  \ 'brightpurple'   : 189,
                                  \
                                  \ 'brightorange'   : 208,
                                  \ 'brightestorange': 214,
                                  \
                                  \ 'gray0'          : 233,
                                  \ 'gray1'          : 235,
                                  \ 'gray2'          : 236,
                                  \ 'gray3'          : 239,
                                  \ 'gray4'          : 240,
                                  \ 'gray5'          : 241,
                                  \ 'gray6'          : 244,
                                  \ 'gray7'          : 245,
                                  \ 'gray8'          : 247,
                                  \ 'gray9'          : 250,
                                  \ 'gray10'         : 252,
                                  \
                                  \ 'yellow'         : 136,
                                  \ 'orange'         : 166,
                                  \ 'red'            : 160,
                                  \ 'magenta'        : 125,
                                  \ 'violet'         : 61,
                                  \ 'blue'           : 33,
                                  \ 'cyan'           : 37,
                                  \ 'green'          : 64,
                                  \ }
                            
    1              0.000037 let s:guicolor = {
                                  \ 'black'          : '#000000',
                                  \ 'white'          : '#ffffff',
                                  \
                                  \ 'darkestgreen'   : '#005f00',
                                  \ 'darkgreen'      : '#008700',
                                  \ 'mediumgreen'    : '#5faf00',
                                  \ 'brightgreen'    : '#afdf00',
                                  \
                                  \ 'darkestcyan'    : '#005f5f',
                                  \ 'mediumcyan'     : '#87dfff',
                                  \
                                  \ 'darkestblue'    : '#005f87',
                                  \ 'darkblue'       : '#0087af',
                                  \
                                  \ 'darkestred'     : '#5f0000',
                                  \ 'darkred'        : '#870000',
                                  \ 'mediumred'      : '#af0000',
                                  \ 'brightred'      : '#df0000',
                                  \ 'brightestred'   : '#ff0000',
                                  \
                                  \ 'darkestpurple'  : '#5f00af',
                                  \ 'mediumpurple'   : '#875fdf',
                                  \ 'brightpurple'   : '#dfdfff',
                                  \
                                  \ 'brightorange'   : '#ff8700',
                                  \ 'brightestorange': '#ffaf00',
                                  \
                                  \ 'gray0'          : '#121212',
                                  \ 'gray1'          : '#262626',
                                  \ 'gray2'          : '#303030',
                                  \ 'gray3'          : '#4e4e4e',
                                  \ 'gray4'          : '#585858',
                                  \ 'gray5'          : '#606060',
                                  \ 'gray6'          : '#808080',
                                  \ 'gray7'          : '#8a8a8a',
                                  \ 'gray8'          : '#9e9e9e',
                                  \ 'gray9'          : '#bcbcbc',
                                  \ 'gray10'         : '#d0d0d0',
                                  \
                                  \ 'yellow'         : '#b58900',
                                  \ 'orange'         : '#cb4b16',
                                  \ 'red'            : '#dc322f',
                                  \ 'magenta'        : '#d33682',
                                  \ 'violet'         : '#6c71c4',
                                  \ 'blue'           : '#268bd2',
                                  \ 'cyan'           : '#2aa198',
                                  \ 'green'          : '#859900',
                                  \ }
                            
    1              0.000003 function! s:convert(rgb) abort
                              let rgb = map(matchlist(a:rgb, '#\(..\)\(..\)\(..\)')[1:3], '0 + ("0x".v:val)')
                              if len(rgb) == 0
                                return 0
                              endif
                              if rgb[0] == 0xc0 && rgb[1] == 0xc0 && rgb[2] == 0xc0
                                return 7
                              elseif rgb[0] == 0x80 && rgb[1] == 0x80 && rgb[2] == 0x80
                                return 8
                              elseif (rgb[0] == 0x80 || rgb[0] == 0x00) && (rgb[1] == 0x80 || rgb[1] == 0x00) && (rgb[2] == 0x80 || rgb[2] == 0x00)
                                return (rgb[0] / 0x80) + (rgb[1] / 0x80) * 2 + (rgb[1] / 0x80) * 4
                              elseif abs(rgb[0]-rgb[1]) < 3 && abs(rgb[1]-rgb[2]) < 3 && abs(rgb[2]-rgb[0]) < 3
                                return s:black((rgb[0] + rgb[1] + rgb[2]) / 3)
                              else
                                return 16 + ((s:nr(rgb[0]) * 6) + s:nr(rgb[1])) * 6 + s:nr(rgb[2])
                              endif
                            endfunction
                            
    1              0.000002 function! s:black(x) abort
                              if a:x < 0x04
                                return 16
                              elseif a:x > 0xf4
                                return 231
                              elseif index([0x00, 0x5f, 0x87, 0xaf, 0xdf, 0xff], a:x) >= 0
                                let l = a:x / 0x30
                                return ((l * 6) + l) * 6 + l + 16
                              else
                                return 232 + (a:x < 8 ? 0 : a:x < 0x60 ? (a:x-8)/10 : a:x < 0x76 ? (a:x-0x60)/6+9 : (a:x-8)/10)
                              endif
                            endfunction
                            
    1              0.000002 function! s:nr(x) abort
                              return a:x < 0x2f ? 0 : a:x < 0x73 ? 1 : a:x < 0x9b ? 2 : a:x < 0xc7 ? 3 : a:x < 0xef ? 4 : 5
                            endfunction
                            
    1              0.000002 function! s:rgb(r, g, b) abort
                              return printf('#%02x%02x%02x', a:r, a:g, a:b)
                            endfunction
                            
    1              0.000001 function! s:upconvert(nr) abort
                              let x = a:nr * 1
                              if x < 7
                                let [b, rg] = [x / 4, x % 4]
                                let [g, r] = [rg / 2, rg % 2]
                                return s:rgb(r * 0x80, g * 0x80, b * 0x80)
                              elseif x == 7
                                return s:rgb(0xc0, 0xc0, 0xc0)
                              elseif x == 8
                                return s:rgb(0x80, 0x80, 0x80)
                              elseif x < 16
                                let y = x - 8
                                let [b, rg] = [y / 4, y % 4]
                                let [g, r] = [rg / 2, rg % 2]
                                return s:rgb(r * 0xff, g * 0xff, b * 0xff)
                              elseif x < 232
                                let y = x - 16
                                let [rg, b] = [y / 6, y % 6]
                                let [r, g] = [rg / 6, rg % 6]
                                let l = [0x00, 0x5f, 0x87, 0xaf, 0xdf, 0xff]
                                return s:rgb(l[r], l[g], l[b])
                              elseif x < 241
                                let k = (x - 232) * 10 + 8
                                return s:rgb(k, k, k)
                              elseif x < 243
                                let k = (x - 241) * 6 + 0x60
                                return s:rgb(k, k, k)
                              else
                                let k = (x - 232) * 10 + 8
                                return s:rgb(k, k, k)
                              endif
                            endfunction
                            
    1              0.000002 function! lightline#colorscheme#fill(p) abort
                              for k in values(a:p)
                                for l in values(k)
                                  for m in l
                                    if len(m) < 4
                                      if type(m[0]) == 1 && type(m[1]) == 1
                                        if m[0] =~# '^\d\+$' && m[1] =~# '^\d\+$'
                                          call insert(m, s:upconvert(m[1]), 0)
                                          call insert(m, s:upconvert(m[1]), 0)
                                        else
                                          call insert(m, get(s:cuicolor, m[0], s:convert(m[0])), 2)
                                          call insert(m, get(s:cuicolor, m[1], s:convert(m[1])), 3)
                                          let m[0] = get(s:guicolor, m[0], m[0])
                                          let m[1] = get(s:guicolor, m[1], m[1])
                                        endif
                                      elseif type(m[0]) == 0 && type(m[1]) == 0
                                          call insert(m, s:upconvert(m[1]), 0)
                                          call insert(m, s:upconvert(m[1]), 0)
                                      endif
                                    endif
                                  endfor
                                endfor
                              endfor
                              return a:p
                            endfunction
                            
    1              0.000002 function! lightline#colorscheme#flatten(p) abort
                              for k in values(a:p)
                                for l in values(k)
                                  for m in range(len(l))
                                    let attr = ''
                                    if len(l[m]) == 3 && type(l[m][2]) == 1
                                      let attr = l[m][2]
                                    endif
                                    let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
                                    if !empty(attr)
                                      call add(l[m], attr)
                                    endif
                                  endfor
                                endfor
                              endfor
                              return a:p
                            endfunction
                            
    1              0.000007 if has('gui_running') || (has('termguicolors') && &termguicolors)
                              function! lightline#colorscheme#background() abort
                                return &background
                              endfunction
                            else
                              " &background is set inappropriately when the colorscheme sets ctermbg of the Normal group
    1              0.000004   function! lightline#colorscheme#background() abort
                                let bg_color = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if bg_color !=# ''
                                  if bg_color < 16
                                    return &background
                                  elseif 232 <= bg_color && bg_color < 244
                                    return 'dark'
                                  elseif 244 <= bg_color
                                    return 'light'
                                  endif
                                endif
                                let fg_color = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                                if fg_color !=# ''
                                  if fg_color < 8 || 232 <= fg_color && fg_color < 244
                                    return 'light'
                                  elseif 8 <= fg_color && fg_color < 16 || 244 <= fg_color
                                    return 'dark'
                                  endif
                                endif
                                return &background
                              endfunction
    1              0.000001 endif
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/deoplete.nvim/autoload/deoplete/init.vim
Sourced 1 time
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: init.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000004 if !exists('s:is_handler_enabled')
    1              0.000004   let s:is_handler_enabled = 0
    1              0.000001 endif
                            
    1              0.000006 let s:is_windows = ((has('win32') || has('win64')) ? v:true : v:false)
                            
    1              0.000003 function! deoplete#init#_is_handler_enabled() abort
                              return s:is_handler_enabled
                            endfunction
                            
    1              0.000002 function! deoplete#init#_initialize() abort
                              if exists('g:deoplete#_initialized')
                                return 1
                              endif
                            
                              let g:deoplete#_initialized = v:false
                            
                              call s:init_internal_variables()
                              call deoplete#init#_custom_variables()
                            
                              if deoplete#init#_channel()
                                return 1
                              endif
                            
                              call deoplete#mapping#_init()
                            endfunction
    1              0.000002 function! deoplete#init#_channel() abort
                              if !exists('g:deoplete#_serveraddr')
                                return 1
                              endif
                            
                              let python3 = get(g:, 'python3_host_prog', 'python3')
                              if !executable(python3)
                                call deoplete#util#print_error(
                                      \ string(python3) . ' is not executable.')
                                call deoplete#util#print_error(
                                      \ 'You need to set g:python3_host_prog.')
                              endif
                            
                              try
                                if deoplete#util#has_yarp()
                                  let g:deoplete#_yarp = yarp#py3('deoplete')
                                  call g:deoplete#_yarp.notify('deoplete_init')
                                else
                                  " rplugin.vim may not be loaded on VimEnter
                                  if !exists('g:loaded_remote_plugins')
                                    runtime! plugin/rplugin.vim
                                  endif
                            
                                  call _deoplete_init()
                                endif
                              catch
                                call deoplete#util#print_error(v:exception)
                                call deoplete#util#print_error(v:throwpoint)
                            
                                if !has('python3')
                                  call deoplete#util#print_error(
                                        \ 'deoplete requires Python3 support("+python3").')
                                endif
                            
                                if deoplete#util#has_yarp()
                                  echomsg string(expand('<sfile>'))
                                  if !exists('*yarp#py3')
                                    call deoplete#util#print_error(
                                          \ 'deoplete requires nvim-yarp plugin.')
                                  endif
                                else
                                  call deoplete#util#print_error(
                                      \ 'deoplete failed to load. '
                                      \ .'Try the :UpdateRemotePlugins command and restart Neovim. '
                                      \ .'See also :checkhealth.')
                                endif
                            
                                return 1
                              endtry
                            endfunction
    1              0.000002 function! deoplete#init#_channel_initialized() abort
                              return get(g:, 'deoplete#_initialized', v:false)
                            endfunction
    1              0.000002 function! deoplete#init#_enable_handler() abort
                              call deoplete#handler#_init()
                              let s:is_handler_enabled = 1
                            endfunction
    1              0.000002 function! deoplete#init#_disable_handler() abort
                              augroup deoplete
                                autocmd!
                              augroup END
                              let s:is_handler_enabled = 0
                            endfunction
                            
    1              0.000002 function! s:init_internal_variables() abort
                              call deoplete#init#_prev_completion()
                              let g:deoplete#_context = {}
                              let g:deoplete#_rank = {}
                              if !exists('g:deoplete#_logging')
                                let g:deoplete#_logging = {}
                              endif
                              unlet! g:deoplete#_initialized
                              try
                                let g:deoplete#_serveraddr =
                                      \ deoplete#util#has_yarp() ?
                                      \ neovim_rpc#serveraddr() : v:servername
                                if g:deoplete#_serveraddr ==# ''
                                  " Use NVIM_LISTEN_ADDRESS
                                  let g:deoplete#_serveraddr = $NVIM_LISTEN_ADDRESS
                                endif
                              catch
                                if deoplete#util#has_yarp() && !exists('*neovim_rpc#serveraddr')
                                  call deoplete#util#print_error(
                                        \ 'deoplete requires vim-hug-neovim-rpc plugin in Vim.')
                                endif
                              endtry
                            endfunction
    1              0.000002 function! deoplete#init#_custom_variables() abort
                              if get(g:, 'deoplete#disable_auto_complete', v:false)
                                call deoplete#custom#option('auto_complete', v:false)
                              endif
                              call s:check_custom_option(
                                    \ 'g:deoplete#auto_complete_delay',
                                    \ 'auto_complete_delay')
                              call s:check_custom_option(
                                    \ 'g:deoplete#auto_refresh_delay',
                                    \ 'auto_refresh_delay')
                              call s:check_custom_option(
                                    \ 'g:deoplete#camel_case',
                                    \ 'camel_case')
                              call s:check_custom_option(
                                    \ 'g:deoplete#delimiters',
                                    \ 'delimiters')
                              call s:check_custom_option(
                                    \ 'g:deoplete#ignore_case',
                                    \ 'ignore_case')
                              call s:check_custom_option(
                                    \ 'g:deoplete#ignore_sources',
                                    \ 'ignore_sources')
                              call s:check_custom_option(
                                    \ 'g:deoplete#keyword_patterns',
                                    \ 'keyword_patterns')
                              call s:check_custom_option(
                                    \ 'g:deoplete#max_list',
                                    \ 'max_list')
                              call s:check_custom_option(
                                    \ 'g:deoplete#num_processes',
                                    \ 'num_processes')
                              call s:check_custom_option(
                                    \ 'g:deoplete#auto_complete_start_length',
                                    \ 'min_pattern_length')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_on_insert_enter',
                                    \ 'on_insert_enter')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_profile',
                                    \ 'profile')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_refresh_always',
                                    \ 'refresh_always')
                              call s:check_custom_option(
                                    \ 'g:deoplete#skip_chars',
                                    \ 'skip_chars')
                              call s:check_custom_option(
                                    \ 'g:deoplete#sources',
                                    \ 'sources')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_smart_case',
                                    \ 'smart_case')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_yarp',
                                    \ 'yarp')
                            
                              " Source variables
                              call s:check_custom_var('file',
                                    \ 'g:deoplete#file#enable_buffer_path',
                                    \ 'enable_buffer_path')
                              call s:check_custom_var('omni',
                                    \ 'g:deoplete#omni#input_patterns',
                                    \ 'input_patterns')
                              call s:check_custom_var('omni',
                                    \ 'g:deoplete#omni#functions',
                                    \ 'functions')
                            endfunction
                            
    1              0.000002 function! deoplete#init#_context(event, sources) abort
                              let input = deoplete#util#get_input(a:event)
                            
                              let [filetype, filetypes, same_filetypes] =
                                    \ deoplete#util#get_context_filetype(input, a:event)
                            
                              let sources = deoplete#util#convert2list(a:sources)
                              if a:event !=# 'Manual' && empty(sources)
                                " Use default sources
                                let sources = deoplete#custom#_get_filetype_option(
                                      \ 'sources', filetype, [])
                              endif
                            
                              let event = (deoplete#util#get_prev_event() ==# 'Refresh') ?
                                    \ 'Manual' : a:event
                            
                              let width = winwidth(0) - col('.') + len(matchstr(input, '\w*$'))
                              let max_width = (width * 2 / 3)
                            
                              let bufnr = expand('<abuf>') !=# '' ? expand('<abuf>') : bufnr('%')
                              let bufname = bufname(bufnr)
                              let bufpath = fnamemodify(bufname, ':p')
                              if !filereadable(bufpath) || getbufvar(bufnr, '&buftype') =~# 'nofile'
                                let bufpath = ''
                              endif
                            
                              return {
                                    \ 'changedtick': b:changedtick,
                                    \ 'event': event,
                                    \ 'input': input,
                                    \ 'is_windows': s:is_windows,
                                    \ 'next_input': deoplete#util#get_next_input(a:event),
                                    \ 'complete_str': '',
                                    \ 'encoding': &encoding,
                                    \ 'position': getpos('.'),
                                    \ 'filetype': filetype,
                                    \ 'filetypes': filetypes,
                                    \ 'same_filetypes': same_filetypes,
                                    \ 'ignorecase': deoplete#custom#_get_option('ignore_case'),
                                    \ 'smartcase': deoplete#custom#_get_option('smart_case'),
                                    \ 'camelcase': deoplete#custom#_get_option('camel_case'),
                                    \ 'delay': deoplete#custom#_get_option('auto_complete_delay'),
                                    \ 'sources': sources,
                                    \ 'max_abbr_width': max_width,
                                    \ 'max_kind_width': max_width,
                                    \ 'max_menu_width': max_width,
                                    \ 'bufnr': bufnr,
                                    \ 'bufname': bufname,
                                    \ 'bufpath': bufpath,
                                    \ 'cwd': getcwd(),
                                    \ 'vars': filter(copy(g:),
                                    \       "stridx(v:key, 'deoplete#') == 0
                                    \        && v:key !=# 'deoplete#_yarp'"),
                                    \ 'bufvars': filter(copy(b:), "stridx(v:key, 'deoplete_') == 0"),
                                    \ 'custom': deoplete#custom#_get(),
                                    \ 'omni__omnifunc': &l:omnifunc,
                                    \ 'dict__dictionary': &l:dictionary,
                                    \ }
                            endfunction
                            
    1              0.000003 function! s:check_custom_var(source_name, old_var, new_var) abort
                              if exists(a:old_var)
                                call deoplete#custom#var(a:source_name, a:new_var, eval(a:old_var))
                              endif
                            endfunction
    1              0.000002 function! s:check_custom_option(old_var, new_var) abort
                              if exists(a:old_var)
                                call deoplete#custom#option(a:new_var, eval(a:old_var))
                              endif
                            endfunction
                            
    1              0.000002 function! deoplete#init#_option() abort
                              " Note: HTML omni func use search().
                              return {
                                    \ 'auto_complete': v:true,
                                    \ 'auto_complete_delay': 50,
                                    \ 'auto_refresh_delay': 50,
                                    \ 'camel_case': v:false,
                                    \ 'complete_method': 'complete',
                                    \ 'delimiters': ['/'],
                                    \ 'ignore_case': &ignorecase,
                                    \ 'ignore_sources': {},
                                    \ 'max_list': 500,
                                    \ 'num_processes': s:is_windows ? 1 : 4,
                                    \ 'keyword_patterns': {'_': '[a-zA-Z_]\k*'},
                                    \ 'omni_patterns': {
                                    \  'html': ['<', '</', '<[^>]*\s[[:alnum:]-]*'],
                                    \  'xhtml': ['<', '</', '<[^>]*\s[[:alnum:]-]*'],
                                    \  'xml': ['<', '</', '<[^>]*\s[[:alnum:]-]*'],
                                    \ },
                                    \ 'on_insert_enter': v:true,
                                    \ 'on_text_changed_i': v:true,
                                    \ 'profile': v:false,
                                    \ 'min_pattern_length': 2,
                                    \ 'refresh_always': v:true,
                                    \ 'skip_chars': ['(', ')'],
                                    \ 'smart_case': &smartcase,
                                    \ 'sources': {},
                                    \ 'trigger_key': v:char,
                                    \ 'yarp': v:false,
                                    \ }
                            endfunction
    1              0.000002 function! deoplete#init#_prev_completion() abort
                              let g:deoplete#_prev_completion = {
                                    \ 'event': '',
                                    \ 'input': '',
                                    \ 'candidates': [],
                                    \ }
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/deoplete.nvim/autoload/deoplete/util.vim
Sourced 1 time
Total time:   0.000362
 Self time:   0.000362

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: util.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000003 function! deoplete#util#print_error(string, ...) abort
                              let name = a:0 ? a:1 : 'deoplete'
                              echohl Error | echomsg printf('[%s] %s', name,
                                    \ deoplete#util#string(a:string)) | echohl None
                            endfunction
    1              0.000002 function! deoplete#util#print_warning(string) abort
                              echohl WarningMsg | echomsg '[deoplete] '
                                    \ . deoplete#util#string(a:string) | echohl None
                            endfunction
    1              0.000002 function! deoplete#util#print_debug(string) abort
                              echomsg '[deoplete] ' . deoplete#util#string(a:string)
                            endfunction
                            
    1              0.000002 function! deoplete#util#convert2list(expr) abort
                              return type(a:expr) ==# v:t_list ? a:expr : [a:expr]
                            endfunction
    1              0.000002 function! deoplete#util#string(expr) abort
                              return type(a:expr) ==# v:t_string ? a:expr : string(a:expr)
                            endfunction
                            
    1              0.000002 function! deoplete#util#get_input(event) abort
                              let mode = mode()
                              if a:event ==# 'InsertEnter'
                                let mode = 'i'
                              endif
                              let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?
                                    \      getline('.') :
                                    \      matchstr(getline('.'),
                                    \         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)
                                    \         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
                              if input =~# '^.\{-}\ze\S\+$'
                                let complete_str = matchstr(input, '\S\+$')
                                let input = matchstr(input, '^.\{-}\ze\S\+$')
                              else
                                let complete_str = ''
                              endif
                            
                              if a:event ==# 'InsertCharPre'
                                let complete_str .= v:char
                              endif
                            
                              return input . complete_str
                            endfunction
    1              0.000002 function! deoplete#util#get_next_input(event) abort
                              return getline('.')[len(deoplete#util#get_input(a:event)) :]
                            endfunction
    1              0.000001 function! deoplete#util#get_prev_event() abort
                              return get(g:deoplete#_context, 'event', '')
                            endfunction
                            
    1              0.000002 function! deoplete#util#vimoption2python(option) abort
                              return '[\w' . s:vimoption2python(a:option) . ']'
                            endfunction
    1              0.000002 function! deoplete#util#vimoption2python_not(option) abort
                              return '[^\w' . s:vimoption2python(a:option) . ']'
                            endfunction
    1              0.000002 function! s:vimoption2python(option) abort
                              let has_dash = 0
                              let patterns = []
                              for pattern in split(a:option, ',')
                                if pattern =~# '\d\+'
                                  let pattern = substitute(pattern, '\d\+',
                                        \ '\=nr2char(submatch(0))', 'g')
                                endif
                            
                                if pattern ==# ''
                                  " ,
                                  call add(patterns, ',')
                                elseif pattern ==# '\'
                                  call add(patterns, '\\')
                                elseif pattern ==# '-'
                                  let has_dash = 1
                                else
                                  call add(patterns, pattern)
                                endif
                              endfor
                            
                              " Dash must be last.
                              if has_dash
                                call add(patterns, '-')
                              endif
                            
                              return join(deoplete#util#uniq(patterns), '')
                            endfunction
                            
    1              0.000002 function! deoplete#util#uniq(list) abort
                              let list = map(copy(a:list), '[v:val, v:val]')
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(list[i][1])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return map(list, 'v:val[0]')
                            endfunction
                            
    1              0.000002 function! deoplete#util#get_syn_names() abort
                              if col('$') >= 200
                                return []
                              endif
                            
                              let names = []
                              try
                                " Note: synstack() seems broken in concealed text.
                                for id in synstack(line('.'), (mode() ==# 'i' ? col('.')-1 : col('.')))
                                  let name = synIDattr(id, 'name')
                                  call add(names, name)
                                  if synIDattr(synIDtrans(id), 'name') !=# name
                                    call add(names, synIDattr(synIDtrans(id), 'name'))
                                  endif
                                endfor
                              catch
                                " Ignore error
                              endtry
                              return names
                            endfunction
                            
    1              0.000002 function! deoplete#util#neovim_version() abort
                              redir => v
                              silent version
                              redir END
                              return split(v, '\n')[0]
                            endfunction
                            
    1              0.000002 function! deoplete#util#has_yarp() abort
                              return !has('nvim') || deoplete#custom#_get_option('yarp')
                            endfunction
                            
    1              0.000002 function! deoplete#util#get_context_filetype(input, event) abort
                              if !exists('s:context_filetype')
                                let s:context_filetype = {}
                            
                                " Force context_filetype call.
                                try
                                  call context_filetype#get_filetype()
                                catch
                                  " Ignore error
                                endtry
                              endif
                            
                              if empty(s:context_filetype)
                                    \ || s:context_filetype.prev_filetype !=# &filetype
                                    \ || s:context_filetype.line != line('.')
                                    \ || s:context_filetype.bufnr != bufnr('%')
                                    \ || (a:input =~# '\W$' &&
                                    \     substitute(a:input, '\s\zs\s\+$', '', '') !=#
                                    \     substitute(s:context_filetype.input, '\s\zs\s\+$', '', ''))
                                    \ || (a:input =~# '\w$' &&
                                    \     substitute(a:input, '\w\+$', '', '') !=#
                                    \     substitute(s:context_filetype.input, '\w\+$', '', ''))
                                    \ || a:event ==# 'InsertEnter'
                            
                                let s:context_filetype.line = line('.')
                                let s:context_filetype.bufnr = bufnr('%')
                                let s:context_filetype.input = a:input
                                let s:context_filetype.prev_filetype = &filetype
                                let s:context_filetype.filetype =
                                      \ (exists('*context_filetype#get_filetype') ?
                                      \   context_filetype#get_filetype() :
                                      \   (&filetype ==# '' ? 'nothing' : &filetype))
                                let s:context_filetype.filetypes =
                                      \ exists('*context_filetype#get_filetypes') ?
                                      \   context_filetype#get_filetypes() :
                                      \   &filetype ==# '' ? ['nothing'] :
                                      \                     deoplete#util#uniq([&filetype]
                                      \                          + split(&filetype, '\.'))
                                let s:context_filetype.same_filetypes =
                                      \ exists('*context_filetype#get_same_filetypes') ?
                                      \   context_filetype#get_same_filetypes() : []
                              endif
                              return [ s:context_filetype.filetype,
                                    \  s:context_filetype.filetypes, s:context_filetype.same_filetypes]
                            endfunction
                            
    1              0.000002 function! deoplete#util#get_keyword_pattern(filetype, keyword_patterns) abort
                              if empty(a:keyword_patterns)
                                let patterns = deoplete#custom#_get_filetype_option(
                                    \   'keyword_patterns', a:filetype, '')
                              else
                                let filetype = has_key(a:keyword_patterns, a:filetype) ? a:filetype : '_'
                                let patterns = get(a:keyword_patterns, filetype, '')
                              endif
                              let pattern = join(deoplete#util#convert2list(patterns), '|')
                            
                              " Convert keyword.
                              let k_pattern = deoplete#util#vimoption2python(
                                    \ &l:iskeyword . (&l:lisp ? ',-' : ''))
                              return substitute(pattern, '\\k', '\=k_pattern', 'g')
                            endfunction
                            
    1              0.000002 function! deoplete#util#rpcnotify(event, context) abort
                              if !deoplete#init#_channel_initialized()
                                return ''
                              endif
                            
                              let a:context['rpc'] = a:event
                            
                              if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:event, a:context)
                              else
                                call rpcnotify(g:deoplete#_channel_id, a:event, a:context)
                              endif
                            
                              return ''
                            endfunction
                            
                            " Compare versions.  Return values is the distance between versions.  Each
                            " version integer (from right to left) is an ascending power of 100.
                            "
                            " Example:
                            " '0.1.10' is (1 * 100) + 10, or 110.
                            " '1.2.3' is (1 * 10000) + (2 * 100) + 3, or 10203.
                            "
                            " Returns:
                            " <0 if a < b
                            " >0 if a > b
                            " 0 if versions are equal.
    1              0.000002 function! deoplete#util#versioncmp(a, b) abort
                              let a = map(split(a:a, '\.'), 'str2nr(v:val)')
                              let b = map(split(a:b, '\.'), 'str2nr(v:val)')
                              let l = min([len(a), len(b)])
                              let d = 0
                            
                              " Only compare the parts that are common to both versions.
                              for i in range(l)
                                let d += (a[i] - b[i]) * pow(100, l - i - 1)
                              endfor
                            
                              return d
                            endfunction
                            
    1              0.000002 function! deoplete#util#split(string) abort
                              return split(a:string, '\s*,\s*')
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/deoplete.nvim/autoload/deoplete/custom.vim
Sourced 1 time
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: custom.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000003 function! deoplete#custom#_init() abort
                              let s:custom = {}
                              let s:custom.source = {}
                              let s:custom.source._ = {}
                              let s:custom.option = deoplete#init#_option()
                            endfunction
    1              0.000002 function! deoplete#custom#_init_buffer() abort
                              let b:custom = {}
                              let b:custom.option = {}
                              let b:custom.source_vars = {}
                            endfunction
                            
    1              0.000002 function! deoplete#custom#_get() abort
                              if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
                              return s:custom
                            endfunction
    1              0.000002 function! deoplete#custom#_get_buffer() abort
                              if !exists('b:custom')
                                call deoplete#custom#_init_buffer()
                              endif
                            
                              return b:custom
                            endfunction
                            
    1              0.000002 function! deoplete#custom#_get_source(source_name) abort
                              let custom = deoplete#custom#_get().source
                            
                              if !has_key(custom, a:source_name)
                                let custom[a:source_name] = {}
                              endif
                            
                              return custom[a:source_name]
                            endfunction
    1              0.000002 function! deoplete#custom#_get_option(name) abort
                              let custom = extend(copy(deoplete#custom#_get().option),
                                    \ deoplete#custom#_get_buffer().option)
                              return custom[a:name]
                            endfunction
    1              0.000002 function! deoplete#custom#_get_filetype_option(name, filetype, default) abort
                              let buffer_option = deoplete#custom#_get_buffer().option
                              if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
                              endif
                            
                              let option = deoplete#custom#_get_option(a:name)
                              let filetype = has_key(option, a:filetype) ? a:filetype : '_'
                              return get(option, filetype, a:default)
                            endfunction
    1              0.000002 function! deoplete#custom#_get_source_vars(name) abort
                              let global_vars = get(deoplete#custom#_get_source(a:name), 'vars', {})
                              let buffer_vars = get(deoplete#custom#_get_buffer().source_vars,
                                    \ a:name, {})
                              return extend(copy(global_vars), buffer_vars)
                            endfunction
                            
    1              0.000002 function! deoplete#custom#source(source_name, option_name, value) abort
                              let value = index([
                                    \ 'filetypes', 'disabled_syntaxes',
                                    \ 'matchers', 'sorters', 'converters'
                                    \ ], a:option_name) < 0 ? a:value :
                                    \ deoplete#util#convert2list(a:value)
                              for key in deoplete#util#split(a:source_name)
                                let custom_source = deoplete#custom#_get_source(key)
                                let custom_source[a:option_name] = value
                              endfor
                            endfunction
                            
    1              0.000002 function! deoplete#custom#var(source_name, var_name, value) abort
                              for key in deoplete#util#split(a:source_name)
                                let custom_source = deoplete#custom#_get_source(key)
                                let vars = get(custom_source, 'vars', {})
                                call s:set_value(vars, a:var_name, a:value)
                                call deoplete#custom#source(key, 'vars', vars)
                              endfor
                            endfunction
    1              0.000002 function! deoplete#custom#buffer_var(source_name, var_name, value) abort
                              let custom = deoplete#custom#_get_buffer().source_vars
                              for key in deoplete#util#split(a:source_name)
                                if !has_key(custom, key)
                                  let custom[key] = {}
                                endif
                                let vars = custom[key]
                                call s:set_value(vars, a:var_name, a:value)
                              endfor
                            endfunction
                            
    1              0.000002 function! deoplete#custom#option(name_or_dict, ...) abort
                              let custom = deoplete#custom#_get().option
                              call s:set_custom(custom, a:name_or_dict, get(a:000, 0, ''))
                            endfunction
    1              0.000002 function! deoplete#custom#buffer_option(name_or_dict, ...) abort
                              let custom = deoplete#custom#_get_buffer().option
                              call s:set_custom(custom, a:name_or_dict, get(a:000, 0, ''))
                            endfunction
                            
    1              0.000004 function! s:set_custom(dest, name_or_dict, value) abort
                              if type(a:name_or_dict) == v:t_dict
                                call extend(a:dest, a:name_or_dict)
                              else
                                call s:set_value(a:dest, a:name_or_dict, a:value)
                              endif
                            endfunction
    1              0.000002 function! s:set_value(dest, name, value) abort
                              if type(a:value) == v:t_dict && !empty(a:value)
                                if !has_key(a:dest, a:name)
                                  let a:dest[a:name] = {}
                                endif
                                call extend(a:dest[a:name], a:value)
                              else
                                let a:dest[a:name] = a:value
                              endif
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.3.1/share/nvim/runtime/autoload/provider.vim
Sourced 1 time
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
                            " Common functions for providers
                            
                            " Start the provider and perform a 'poll' request
                            "
                            " Returns a valid channel on success
    1              0.000005 function! provider#Poll(argv, orig_name, log_env) abort
                              let job = {'rpc': v:true, 'stderr_buffered': v:true}
                              try
                                let channel_id = jobstart(a:argv, job)
                                if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
                                  return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in get(job, 'stderr', [])
                                  echomsg row
                                endfor
                              endtry
                              throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/deoplete.nvim/autoload/deoplete/mapping.vim
Sourced 1 time
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: mapping.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000003 function! deoplete#mapping#_init() abort
                              " Note: The dummy function is needed for cpoptions bug in neovim
                              inoremap <expr><silent> <Plug>_ deoplete#mapping#_dummy_complete()
                            endfunction
                            
    1              0.000003 function! deoplete#mapping#_dummy_complete() abort
                              return "\<C-r>=deoplete#mapping#_complete()\<CR>"
                            endfunction
    1              0.000003 function! deoplete#mapping#_completefunc(findstart, base) abort
                              if a:findstart
                                return g:deoplete#_context.complete_position
                              else
                                return g:deoplete#_context.candidates
                              endif
                            endfunction
    1              0.000002 function! deoplete#mapping#_complete() abort
                              call complete(g:deoplete#_context.complete_position + 1,
                                    \ g:deoplete#_context.candidates)
                            
                              return ''
                            endfunction
    1              0.000002 function! deoplete#mapping#_set_completeopt() abort
                              if exists('g:deoplete#_saved_completeopt')
                                return
                              endif
                              let g:deoplete#_saved_completeopt = &completeopt
                              set completeopt-=longest
                              set completeopt+=menuone
                              set completeopt-=menu
                              if &completeopt !~# 'noinsert\|noselect'
                                set completeopt+=noselect
                              endif
                            endfunction
    1              0.000002 function! deoplete#mapping#_restore_completeopt() abort
                              if exists('g:deoplete#_saved_completeopt')
                                let &completeopt = g:deoplete#_saved_completeopt
                                unlet g:deoplete#_saved_completeopt
                              endif
                            endfunction
    1              0.000002 function! deoplete#mapping#_rpcrequest_wrapper(sources) abort
                              return deoplete#util#rpcnotify(
                                    \ 'deoplete_manual_completion_begin',
                                    \ deoplete#init#_context('Manual', a:sources))
                            endfunction
    1              0.000002 function! deoplete#mapping#_undo_completion() abort
                              if empty(v:completed_item)
                                return ''
                              endif
                            
                              let input = deoplete#util#get_input('')
                              if strridx(input, v:completed_item.word) !=
                                    \ len(input) - len(v:completed_item.word)
                                return ''
                              endif
                            
                              return deoplete#smart_close_popup() .
                                    \  repeat("\<C-h>", strchars(v:completed_item.word))
                            endfunction
    1              0.000002 function! deoplete#mapping#_complete_common_string() abort
                              if !deoplete#is_enabled()
                                return ''
                              endif
                            
                              " Get cursor word.
                              let complete_str = matchstr(deoplete#util#get_input(''), '\w*$')
                            
                              if complete_str ==# '' || !has_key(g:deoplete#_context, 'candidates')
                                return ''
                              endif
                            
                              let candidates = filter(copy(g:deoplete#_context.candidates),
                                    \ 'stridx(tolower(v:val.word), tolower(complete_str)) == 0')
                            
                              if empty(candidates)
                                return ''
                              endif
                            
                              let common_str = candidates[0].word
                              for candidate in candidates[1:]
                                while stridx(tolower(candidate.word), tolower(common_str)) != 0
                                  let common_str = common_str[: -2]
                                endwhile
                              endfor
                            
                              if common_str ==# '' || complete_str ==? common_str
                                return ''
                              endif
                            
                              return (pumvisible() ? "\<C-e>" : '')
                                    \ . repeat("\<BS>", strchars(complete_str)) . common_str
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/deoplete.nvim/autoload/deoplete/handler.vim
Sourced 1 time
Total time:   0.000337
 Self time:   0.000337

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: handler.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000003 function! deoplete#handler#_init() abort
                              augroup deoplete
                                autocmd!
                                autocmd InsertLeave * call s:on_insert_leave()
                                autocmd CompleteDone * call s:on_complete_done()
                                autocmd InsertLeave * call s:completion_timer_stop()
                              augroup END
                            
                              for event in ['InsertEnter', 'BufReadPost', 'BufWritePost', 'BufDelete']
                                call s:define_on_event(event)
                              endfor
                            
                              if deoplete#custom#_get_option('on_text_changed_i')
                                call s:define_completion_via_timer('TextChangedI')
                              endif
                              if deoplete#custom#_get_option('on_insert_enter')
                                call s:define_completion_via_timer('InsertEnter')
                              endif
                              if deoplete#custom#_get_option('refresh_always')
                                call s:define_completion_via_timer('InsertCharPre')
                              endif
                            
                              " Note: Vim 8 GUI(MacVim and Win32) is broken
                              " dummy timer call is needed before complete()
                              if !has('nvim') && has('gui_running')
                                    \ && (has('gui_macvim') || has('win32') || has('win64'))
                                let s:dummy_timer = timer_start(200, {timer -> 0}, {'repeat': -1})
                              endif
                            
                              if deoplete#util#has_yarp()
                                " To fix "RuntimeError: Event loop is closed" issue
                                " Note: Workaround
                                autocmd deoplete VimLeavePre * call s:kill_yarp()
                              endif
                            endfunction
                            
    1              0.000002 function! deoplete#handler#_do_complete() abort
                              let context = g:deoplete#_context
                              let event = get(context, 'event', '')
                              let modes = (event ==# 'InsertEnter') ? ['n', 'i'] : ['i']
                              if s:is_exiting() || index(modes, mode()) < 0
                                call s:completion_timer_stop()
                                return
                              endif
                            
                              if empty(get(context, 'candidates', []))
                                    \ || deoplete#util#get_input(context.event) !=# context.input
                                return
                              endif
                            
                              let prev = g:deoplete#_prev_completion
                              let prev.event = context.event
                              let prev.input = context.input
                              let prev.candidates = context.candidates
                            
                              if context.event ==# 'Manual'
                                let context.event = ''
                              elseif !exists('g:deoplete#_saved_completeopt')
                                call deoplete#mapping#_set_completeopt()
                              endif
                            
                              let complete_method = deoplete#custom#_get_option('complete_method')
                              if complete_method ==# 'complete'
                                call feedkeys("\<Plug>_", 'i')
                              elseif complete_method ==# 'completefunc'
                                let &l:completefunc = 'deoplete#mapping#_completefunc'
                                call feedkeys("\<C-x>\<C-u>", 'in')
                              elseif complete_method ==# 'omnifunc'
                                let &l:omnifunc = 'deoplete#mapping#_completefunc'
                                call feedkeys("\<C-x>\<C-o>", 'in')
                              endif
                            endfunction
                            
    1              0.000002 function! s:completion_timer_start(event) abort
                              if exists('s:completion_timer')
                                call s:completion_timer_stop()
                              endif
                            
                              let delay = max([20, deoplete#custom#_get_option('auto_complete_delay')])
                              let s:completion_timer = timer_start(
                                    \ delay, {-> s:completion_begin(a:event)})
                            endfunction
    1              0.000001 function! s:completion_timer_stop() abort
                              if !exists('s:completion_timer')
                                return
                              endif
                            
                              call timer_stop(s:completion_timer)
                              unlet s:completion_timer
                            endfunction
                            
    1              0.000002 function! deoplete#handler#_async_timer_start() abort
                              if exists('s:async_timer')
                                call deoplete#handler#_async_timer_stop()
                              endif
                            
                              let delay = deoplete#custom#_get_option('auto_refresh_delay')
                              if delay <= 0
                                return
                              endif
                            
                              let s:async_timer = { 'event': 'Async', 'changedtick': b:changedtick }
                              let s:async_timer.id = timer_start(
                                    \ max([20, delay]),
                                    \ function('s:completion_async'), {'repeat': -1})
                            endfunction
    1              0.000002 function! deoplete#handler#_async_timer_stop() abort
                              if exists('s:async_timer')
                                call timer_stop(s:async_timer.id)
                                unlet s:async_timer
                              endif
                            endfunction
    1              0.000002 function! s:completion_async(timer) abort
                              if mode() !=# 'i' || s:is_exiting()
                                call deoplete#handler#_async_timer_stop()
                                return
                              endif
                            
                              call s:completion_begin(s:async_timer.event)
                            endfunction
                            
    1              0.000001 function! s:completion_begin(event) abort
                              if s:is_skip(a:event)
                                call deoplete#mapping#_restore_completeopt()
                                let g:deoplete#_context.candidates = []
                                return
                              endif
                            
                              let context = deoplete#init#_context(a:event, [])
                              if context['event'] !=# 'Async'
                                call deoplete#init#_prev_completion()
                              endif
                            
                              if s:check_omnifunc(context)
                                return
                              endif
                            
                              call deoplete#util#rpcnotify(
                                    \ 'deoplete_auto_completion_begin', context)
                            endfunction
    1              0.000002 function! s:is_skip(event) abort
                              if s:is_skip_text(a:event)
                                return 1
                              endif
                            
                              let auto_complete = deoplete#custom#_get_option('auto_complete')
                            
                              if &paste
                                    \ || (a:event !=# 'Manual' && a:event !=# 'Async' && !auto_complete)
                                    \ || (&l:completefunc !=# '' && &l:buftype =~# 'nofile')
                                    \ || (a:event !=# 'InsertEnter' && mode() !=# 'i')
                                return 1
                              endif
                            
                              return 0
                            endfunction
    1              0.000001 function! s:is_skip_text(event) abort
                              let context = g:deoplete#_context
                              let input = deoplete#util#get_input(a:event)
                            
                              if has_key(context, 'input')
                                    \ && a:event !=# 'Manual'
                                    \ && a:event !=# 'Async'
                                    \ && input ==# context.input
                                return 1
                              endif
                            
                              let displaywidth = strdisplaywidth(input) + 1
                              if &l:formatoptions =~# '[tca]' && &l:textwidth > 0
                                    \     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]'
                                      \ || !empty(filter(deoplete#util#get_syn_names(),
                                      \                  "v:val ==# 'Comment'"))
                                  return 1
                                endif
                              endif
                            
                              let skip_chars = deoplete#custom#_get_option('skip_chars')
                            
                              return (!pumvisible() && virtcol('.') != displaywidth)
                                    \ || (a:event !=# 'Manual' && input !=# ''
                                    \     && index(skip_chars, input[-1:]) >= 0)
                            endfunction
    1              0.000002 function! s:check_omnifunc(context) abort
                              let prev = g:deoplete#_prev_completion
                              let blacklist = ['LanguageClient#complete']
                              if a:context.event ==# 'Manual'
                                    \ || &l:omnifunc ==# ''
                                    \ || index(blacklist, &l:omnifunc) >= 0
                                    \ || prev.input ==# a:context.input
                                return
                              endif
                            
                              for filetype in a:context.filetypes
                                for pattern in deoplete#util#convert2list(
                                      \ deoplete#custom#_get_filetype_option(
                                      \   'omni_patterns', filetype, ''))
                                  if pattern !=# '' && a:context.input =~# '\%('.pattern.'\)$'
                                    let g:deoplete#_context.candidates = []
                            
                                    let prev.event = a:context.event
                                    let prev.input = a:context.input
                                    let prev.candidates = []
                            
                                    call deoplete#mapping#_set_completeopt()
                                    call feedkeys("\<C-x>\<C-o>", 'in')
                                    return 1
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000002 function! s:define_on_event(event) abort
                              if !exists('##' . a:event)
                                return
                              endif
                            
                              execute 'autocmd deoplete' a:event
                                    \ '* if !&l:previewwindow | call deoplete#send_event('
                                    \ .string(a:event).') | endif'
                            endfunction
    1              0.000002 function! s:define_completion_via_timer(event) abort
                              if !exists('##' . a:event)
                                return
                              endif
                            
                              execute 'autocmd deoplete' a:event
                                    \ '* call s:completion_timer_start('.string(a:event).')'
                            endfunction
                            
    1              0.000001 function! s:on_insert_leave() abort
                              call deoplete#mapping#_restore_completeopt()
                              let g:deoplete#_context = {}
                              call deoplete#init#_prev_completion()
                            endfunction
                            
    1              0.000001 function! s:on_complete_done() abort
                              if get(v:completed_item, 'word', '') ==# ''
                                return
                              endif
                            
                              let word = v:completed_item.word
                              if !has_key(g:deoplete#_rank, word)
                                let g:deoplete#_rank[word] = 1
                              else
                                let g:deoplete#_rank[word] += 1
                              endif
                            
                              call deoplete#handler#_skip_next_completion()
                            endfunction
                            
    1              0.000002 function! deoplete#handler#_skip_next_completion() abort
                              if !exists('g:deoplete#_context')
                                return
                              endif
                            
                              let input = deoplete#util#get_input('CompleteDone')
                              if input[-1:] !=# '/'
                                let g:deoplete#_context.input = input
                              endif
                              call deoplete#init#_prev_completion()
                            endfunction
                            
    1              0.000001 function! s:is_exiting() abort
                              return exists('v:exiting') && v:exiting != v:null
                            endfunction
                            
    1              0.000001 function! s:kill_yarp() abort
                              if g:deoplete#_yarp.job_is_dead
                                return
                              endif
                            
                              let job = g:deoplete#_yarp.job
                              if !has('nvim') && !exists('g:yarp_jobstart')
                                " Get job object from vim-hug-neovim-rpc
                                let job = g:_neovim_rpc_jobs[job].job
                              endif
                            
                              if has('nvim')
                                call jobstop(job)
                              else
                                call job_stop(job, 'kill')
                              endif
                            
                              let g:deoplete#_yarp.job_is_dead = 1
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/neomake/autoload/neomake.vim
Sourced 1 time
Total time:   0.002440
 Self time:   0.002258

count  total (s)   self (s)
                            " vim: ts=4 sw=4 et
    1              0.000003 scriptencoding utf-8
                            
    1              0.000003 if !exists('s:make_id')
    1              0.000002     let s:make_id = 0
    1              0.000001 endif
                            " A map of make_id to options, e.g. cwd when jobs where started.
    1              0.000002 if !exists('s:make_info')
    1              0.000002     let s:make_info = {}
    1              0.000001 endif
    1              0.000002 if !exists('s:job_id')
    1              0.000001     let s:job_id = 1
    1              0.000001 endif
    1              0.000001 if !exists('s:jobs')
    1              0.000001     let s:jobs = {}
    1              0.000001 endif
    1              0.000002 if !exists('s:map_job_ids')
    1              0.000001     let s:map_job_ids = {}
    1              0.000001 endif
    1              0.000002 if !exists('s:action_queue')
    1              0.000002     let s:action_queue = []
    1              0.000001 endif
    1              0.000002 if !exists('s:action_queue_registered_events')
    1              0.000002     let s:action_queue_registered_events = []
    1              0.000001 endif
    1              0.000006 let s:action_queue_timer_timeouts = get(g:, 'neomake_action_queue_timeouts', {1: 100, 2: 200, 3: 500})
                            
                            " Errors by [maker_type][bufnr][lnum]
    1              0.000006 let s:current_errors = {'project': {}, 'file': {}}
                            " List of pending outputs by job ID.
    1              0.000002 let s:pending_outputs = {}
                            
    1              0.000003 if !has('nvim')
                                let s:kill_vim_timers = {}
                            endif
                            
                            " A list of references to keep when profiling.
                            " Workaround for https://github.com/vim/vim/issues/2350, where
                            " https://github.com/blueyed/vader.vim/commit/e66d91dea is not enough.
    1              0.000002 let s:hack_keep_refs_for_profiling = []
                            
                            " Can Neovim buffer output?
    1              0.000004 let s:nvim_can_buffer_output = has('nvim-0.3.0') ? 1 : 0
                            
                            " Private function to access script-local variables during tests.
    1              0.000002 function! neomake#_get_s() abort
                                return s:
                            endfunction
                            
                            " Sentinels.
    1              0.000002 let s:unset_list = []
    1              0.000001 let s:unset_dict = {}
    1              0.000002 let s:unset = {}
                            
    1              0.000005 let s:can_use_env_in_job_opts = has('patch-8.0.0902') && has('patch-8.0.1832')
                            
    1              0.000003 let s:is_testing = exists('g:neomake_test_messages')
                            
    1              0.000005 let s:async = has('nvim')
                                        \ || has('channel') && has('job') && has('patch-8.0.0027')
    1              0.000002 function! neomake#has_async_support() abort
                                return s:async
                            endfunction
                            
    1              0.000002 function! s:sort_jobs(a, b) abort
                                return a:a.id - a:b.id
                            endfunction
                            
    1              0.000002 function! neomake#GetJobs(...) abort
                                if empty(s:jobs)
                                    return []
                                endif
                                let jobs = copy(values(s:jobs))
                                if a:0
                                    call filter(jobs, 'index(a:1, v:val.id) != -1')
                                endif
                                return sort(jobs, function('s:sort_jobs'))
                            endfunction
                            
    1              0.000002 function! neomake#GetJob(job_id) abort
                                return s:jobs[a:job_id]
                            endfunction
                            
                            " Not documented, only used in tests for now.
    1              0.000001 function! neomake#GetStatus() abort
                                return {
                                            \ 'last_make_id': s:make_id,
                                            \ 'make_info': s:make_info,
                                            \ 'action_queue': s:action_queue,
                                            \ }
                            endfunction
                            
                            " neomake#GetMakeOptions: not documented, only used internally for now.
                            " More lax when not being used in tests to avoid errors, but fail during tests.
    1              0.000002 if s:is_testing
                                function! neomake#GetMakeOptions(...) abort
                                    let make_id = a:0 ? a:1 : s:make_id
                                    try
                                        let r = s:make_info[make_id]
                                    catch
                                        let msg = printf('GetMakeOptions failed: %s (in %s)', v:exception, v:throwpoint)
                                        call vader#log(msg)
                                        let g:neomake_test_errors += [msg]
                                        return {'verbosity': 3}
                                    endtry
                                    return r
                                endfunction
                            else
    1              0.000001     function! neomake#GetMakeOptions(...) abort
                                    let make_id = a:0 ? a:1 : s:make_id
                                    if !has_key(s:make_info, make_id)
                                        call neomake#log#warning('warning: missing make_info key: '.make_id.'.')
                                        return {'verbosity': get(g:, 'neomake_verbose', 1)}
                                    endif
                                    return s:make_info[make_id]
                                endfunction
    1              0.000001 endif
                            
    1              0.000001 function! neomake#ListJobs() abort
                                if !s:async
                                    echom 'This Vim version has no support for jobs.'
                                    return
                                endif
                                let jobs = neomake#GetJobs()
                                if empty(jobs)
                                    return
                                endif
                                echom 'make_id | job_id | name/maker'
                                for jobinfo in jobs
                                    let desc = !empty(jobinfo.maker.name) && jobinfo.name != jobinfo.maker.name
                                                \ ? jobinfo.name. ' ('.jobinfo.maker.name.')'
                                                \ : jobinfo.name
                                    echom printf('%7d | %6d | %s', jobinfo.make_id, jobinfo.id, desc)
                                endfor
                            endfunction
                            
    1              0.000002 function! neomake#CancelMake(make_id, ...) abort
                                if !has_key(s:make_info, a:make_id)
                                    call neomake#log#error('CancelMake: make not found: '.a:make_id.'.')
                                    return 0
                                endif
                                let make_info = s:make_info[a:make_id]
                                let make_info.canceled = 1
                                let make_info.make_id = a:make_id  " for logging.
                                call neomake#log#debug('Cancelling make.', make_info)
                                let bang = a:0 ? a:1 : 0
                                let jobs = filter(copy(values(s:jobs)), 'v:val.make_id == a:make_id')
                                for job in jobs
                                    call neomake#CancelJob(job.id, bang)
                                endfor
                                call s:clean_action_queue(make_info)
                                " Ensure that make gets cleaned really, e.g. if there were no jobs yet.
                                if has_key(s:make_info, a:make_id)
                                    call s:clean_make_info(make_info, bang)
                                endif
                                return 1
                            endfunction
                            
    1              0.000002 function! neomake#CancelAllMakes(...) abort
                                let bang = a:0 ? a:1 : 0
                                for make_id in keys(s:make_info)
                                    call neomake#CancelMake(make_id, bang)
                                endfor
                            endfunction
                            
                            " Remove any queued actions for a jobinfo or make_info object.
    1              0.000002 function! s:clean_action_queue(job_or_make_info) abort
                                let len_before = len(s:action_queue)
                                call filter(s:action_queue, 'v:val[1][1][0] != a:job_or_make_info')
                                let removed = len_before - len(s:action_queue)
                                if removed
                                    call s:clean_action_queue_augroup()
                                    call neomake#log#debug(printf(
                                                \ 'Removed %d action queue entries.',
                                                \ removed), a:job_or_make_info)
                                endif
                            endfunction
                            
                            " Returns 1 if a job was canceled, 0 otherwise.
    1              0.000002 function! neomake#CancelJob(job_id, ...) abort
                                let job_id = type(a:job_id) == type({}) ? a:job_id.id : +a:job_id
                                let remove_always = a:0 ? a:1 : 0
                                let jobinfo = get(s:jobs, job_id, {})
                                call neomake#log#debug('Cancelling job.', jobinfo)
                            
                                call s:clean_action_queue(empty(jobinfo) ? {'id': job_id} : jobinfo)
                            
                                if empty(jobinfo)
                                    call neomake#log#error('CancelJob: job not found: '.job_id.'.')
                                    return 0
                                endif
                            
                                if get(jobinfo, 'canceled', 0)
                                    call neomake#log#info('Job was canceled already.', jobinfo)
                                    if remove_always
                                        call s:CleanJobinfo(jobinfo)
                                    endif
                                    return 0
                                endif
                            
                                let ret = 0
                                if get(jobinfo, 'finished')
                                    call neomake#log#debug('Removing already finished job.', jobinfo)
                                elseif has_key(jobinfo, 'exit_code')
                                    call neomake#log#debug('Job exited already.', jobinfo)
                                elseif s:async
                                    let job = has('nvim') ? jobinfo.nvim_job : jobinfo.vim_job
                                    call neomake#log#debug(printf('Stopping job: %s.', job), jobinfo)
                                    if has('nvim')
                                        try
                                            call jobstop(job)
                                            let ret = 1
                                        catch /^Vim\%((\a\+)\)\=:\(E474\|E900\):/
                                            call neomake#log#info(printf(
                                                        \ 'jobstop failed: %s.', v:exception), jobinfo)
                                        endtry
                                    else
                                        " Use ch_status here, since job_status might be 'dead' already,
                                        " without the exit handler being called yet.
                                        if job_status(job) !=# 'run'
                                            call neomake#log#info(
                                                        \ 'job_stop: job was not running anymore.', jobinfo)
                                        else
                                            " NOTE: might be "dead" already, but that is fine.
                                            call job_stop(job)
                                            let ret = 1
                                            if job_status(job) ==# 'run'
                                                let timer = timer_start(1000, function('s:kill_vimjob_cb'))
                                                let s:kill_vim_timers[timer] = jobinfo
                                            endif
                                        endif
                                    endif
                                endif
                                let jobinfo.canceled = 1
                            
                                if ret == 0 || remove_always
                                    call s:CleanJobinfo(jobinfo)
                                endif
                                return ret
                            endfunction
                            
    1              0.000002 function! s:kill_vimjob_cb(timer) abort
                                let jobinfo = s:kill_vim_timers[a:timer]
                                let vim_job = jobinfo.vim_job
                                if job_status(vim_job) ==# 'run'
                                    call neomake#log#debug('Forcefully killing still running Vim job.', jobinfo)
                                    call job_stop(vim_job, 'kill')
                                endif
                                unlet s:kill_vim_timers[a:timer]
                            endfunction
                            
    1              0.000002 function! neomake#CancelJobs(bang) abort
                                call neomake#log#debug(printf('Cancelling %d jobs.', len(s:jobs)))
                                for job_id in keys(s:jobs)
                                    call neomake#CancelJob(job_id, a:bang)
                                endfor
                            endfunction
                            
    1              0.000002 function! s:handle_get_list_entries(jobinfo, ...) abort
                                if !a:0
                                    return s:pcall('s:handle_get_list_entries', [a:jobinfo])
                                endif
                                let jobinfo = a:jobinfo
                                let jobinfo.serialize = 0
                                let maker = jobinfo.maker
                                try
                                    let entries = maker.get_list_entries(jobinfo)
                                catch /^\%(Vim\%((\a\+)\)\=:\%(E48\|E523\)\)\@!/  " everything, but E48/E523 (sandbox / not allowed here)
                                    if v:exception ==# 'NeomakeTestsException'
                                        throw v:exception
                                    endif
                                    call neomake#log#exception(printf(
                                                \ 'Error during get_list_entries for %s: %s.',
                                                \ jobinfo.maker.name, v:exception), jobinfo)
                                    call s:CleanJobinfo(jobinfo)
                                    return 1
                                finally
                                    let jobinfo.finished = 1
                                endtry
                            
                                if type(entries) != type([])
                                    call neomake#log#error(printf('The get_list_entries method for maker %s did not return a list, but: %s.', jobinfo.maker.name, string(entries)[:100]), jobinfo)
                                elseif !empty(entries) && type(entries[0]) != type({})
                                    call neomake#log#error(printf('The get_list_entries method for maker %s did not return a list of dicts, but: %s.', jobinfo.maker.name, string(entries)[:100]), jobinfo)
                                else
                                    call s:ProcessEntries(jobinfo, entries)
                                endif
                                call s:CleanJobinfo(jobinfo)
                                return 1
                            endfunction
                            
    1              0.000002 function! s:MakeJob(make_id, options) abort
                                let job_id = s:job_id
                                let s:job_id += 1
                            
                                " Optional:
                                "  - serialize (default: 0 for async (and get_list_entries),
                                "                        1 for non-async)
                                "  - serialize_abort_on_error (default: 0)
                                "  - exit_callback (string/function, default: 0)
                                let jobinfo = extend(copy(g:neomake#jobinfo#base), extend({
                                    \ 'id': job_id,
                                    \ 'name': empty(get(a:options.maker, 'name', '')) ? 'neomake_'.job_id : a:options.maker.name,
                                    \ 'maker': a:options.maker,
                                    \ 'bufnr': a:options.bufnr,
                                    \ 'file_mode': a:options.file_mode,
                                    \ 'ft': a:options.ft,
                                    \ 'cwd': s:make_info[a:options.make_id].cwd,
                                    \ }, a:options))
                            
                                let maker = jobinfo.maker
                            
                                if has_key(maker, 'get_list_entries')
                                    call neomake#log#info(printf(
                                                \ '%s: getting entries via get_list_entries.',
                                                \ maker.name), jobinfo)
                                    let s:jobs[jobinfo.id] = jobinfo
                                    let s:make_info[a:make_id].active_jobs += [jobinfo]
                                    call s:handle_get_list_entries(jobinfo)
                                    return jobinfo
                                endif
                            
                                call extend(jobinfo, {
                                    \ 'output_stream': a:options.maker.output_stream,
                                    \ 'buffer_output': a:options.maker.buffer_output,
                                    \ }, 'keep')
                            
                                let error = ''
                                try
                                    " Change to job's cwd (before args, for relative filename).
                                    let cd_error = jobinfo.cd()
                                    if !empty(cd_error)
                                        throw printf("Neomake: %s: could not change to maker's cwd (%s): %s.",
                                                    \ maker.name, jobinfo.cd_from_setting, cd_error)
                                    endif
                                    let jobinfo.argv = maker._get_argv(jobinfo)
                            
                                    call neomake#utils#hook('NeomakeJobInit', {'jobinfo': jobinfo})
                            
                                    let start_msg = s:async ? 'Starting async job' : 'Starting'
                                    if type(jobinfo.argv) == type('')
                                        let start_msg .= ' [string]: '.jobinfo.argv
                                    else
                                        let start_msg .= ': '.join(map(copy(jobinfo.argv), 'neomake#utils#shellescape(v:val)'))
                                    endif
                                    call neomake#log#info(start_msg.'.', jobinfo)
                            
                                    let cwd = jobinfo.cwd
                                    let changed = !empty(jobinfo.cd_back_cmd)
                                    if changed
                                        call neomake#log#debug('cwd: '.cwd.' (changed).', jobinfo)
                                    else
                                        call neomake#log#debug('cwd: '.cwd.'.', jobinfo)
                                    endif
                            
                                    let base_job_opts = {}
                                    if has_key(jobinfo, 'filename')
                                        if s:can_use_env_in_job_opts
                                            let base_job_opts = {
                                                        \ 'env': {
                                                        \   'NEOMAKE_FILE': jobinfo.filename
                                                        \ }}
                                        else
                                            let save_env_file = exists('$NEOMAKE_FILE') ? $NEOMAKE_FILE : s:unset
                                            let $NEOMAKE_FILE = jobinfo.filename
                                        endif
                                    endif
                            
                                    " Lock maker to make sure it does not get changed accidentally, but
                                    " only with depth=1, so that a postprocess object can change itself.
                                    lockvar 1 maker
                                    if s:async
                                        if has('nvim')
                                            if jobinfo.buffer_output
                                                let opts = extend(base_job_opts, {
                                                            \ 'stdout_buffered': 1,
                                                            \ 'stderr_buffered': 1,
                                                            \ })
                                                if s:nvim_can_buffer_output == 1
                                                    let opts.on_exit = function('s:nvim_exit_handler_buffered')
                                                else
                                                    call extend(opts, {
                                                            \ 'on_stdout': function('s:nvim_output_handler'),
                                                            \ 'on_stderr': function('s:nvim_output_handler'),
                                                            \ })
                                                    let opts.on_exit = function('s:nvim_exit_handler')
                                                endif
                                                let jobinfo.jobstart_opts = opts
                                            else
                                                let opts = {
                                                            \ 'on_stdout': function('s:nvim_output_handler'),
                                                            \ 'on_stderr': function('s:nvim_output_handler'),
                                                            \ 'on_exit': function('s:nvim_exit_handler'),
                                                            \ }
                                            endif
                                            if has_key(maker, 'nvim_job_opts')
                                                call extend(opts, maker.nvim_job_opts)
                                            endif
                                            if !has('nvim-0.3.0')
                                                        \ && !neomake#utils#IsRunningWindows()
                                                        \ && !has_key(opts, 'detach')
                                                        \ && !has_key(opts, 'pty')
                                                " Always use detach to trigger setsid() with older Neovim.
                                                let opts.detach = 1
                                            endif
                                            try
                                                let job = jobstart(jobinfo.argv, opts)
                                            catch
                                                let error = printf('Failed to start Neovim job: %s: %s.',
                                                            \ string(jobinfo.argv), v:exception)
                                            endtry
                                            if empty(error)
                                                if job == 0
                                                    let error = printf('Failed to start Neovim job: %s: %s.',
                                                                \ 'Job table is full or invalid arguments given', string(jobinfo.argv))
                                                elseif job == -1
                                                    let error = printf('Failed to start Neovim job: %s: %s.',
                                                                \ 'Executable not found', string(jobinfo.argv))
                                                else
                                                    let s:map_job_ids[job] = jobinfo.id
                                                    let jobinfo.nvim_job = job
                                                    let s:jobs[jobinfo.id] = jobinfo
                            
                                                    if get(jobinfo, 'uses_stdin', 0)
                                                        call jobsend(job, s:make_info[a:make_id].buffer_lines)
                                                        call jobclose(job, 'stdin')
                                                    endif
                                                endif
                                            endif
                                        else
                                            " vim-async.
                                            let opts = extend(base_job_opts, {
                                                        \ 'out_cb': function('s:vim_output_handler_stdout'),
                                                        \ 'err_cb': function('s:vim_output_handler_stderr'),
                                                        \ 'close_cb': function('s:vim_exit_handler'),
                                                        \ 'mode': 'raw',
                                                        \ })
                                            if has_key(maker, 'vim_job_opts')
                                                call extend(opts, maker.vim_job_opts)
                                            endif
                                            try
                                                let job = job_start(jobinfo.argv, opts)
                                                " Get this as early as possible!
                                                let channel_id = ch_info(job)['id']
                                            catch
                                                " NOTE: not covered in tests. Vim seems to always return
                                                " a job. Might be able to trigger this using custom opts?!
                                                let error = printf('Failed to start Vim job: %s: %s.',
                                                            \ jobinfo.argv, v:exception)
                                            endtry
                                            if empty(error)
                                                let jobinfo.vim_job = job
                                                let s:map_job_ids[channel_id] = jobinfo.id
                                                let s:jobs[jobinfo.id] = jobinfo
                                                call neomake#log#debug(printf('Vim job: %s.',
                                                            \ string(job_info(job))), jobinfo)
                                                call neomake#log#debug(printf('Vim channel: %s.',
                                                            \ string(ch_info(job))), jobinfo)
                            
                                                if get(jobinfo, 'uses_stdin', 0)
                                                    call ch_sendraw(job, join(s:make_info[a:make_id].buffer_lines, "\n"))
                                                    call ch_close_in(job)
                                                endif
                                            endif
                                        endif
                            
                                        " Bail out on errors.
                                        if !empty(error)
                                            throw 'Neomake: '.error
                                        endif
                            
                                        call neomake#utils#hook('NeomakeJobStarted', {'jobinfo': jobinfo})
                                    else
                                        " vim-sync.
                                        " Use a temporary file to capture stderr.
                                        let stderr_file = tempname()
                                        let argv = jobinfo.argv . ' 2>'.stderr_file
                            
                                        try
                                            if get(jobinfo, 'uses_stdin', 0)
                                                " Pass stdin to system(), but only if non-empty.
                                                " Otherwise it might cause E677 (vim74-trusty at least).
                                                let stdin = join(s:make_info[a:make_id].buffer_lines, "\n")
                                                if !empty(stdin)
                                                    let output = system(argv, stdin)
                                                else
                                                    let output = system(argv)
                                                endif
                                            else
                                                let output = system(argv)
                                            endif
                                        catch /^Vim(let):E484:/
                                            throw printf('Neomake: Could not run %s: %s.', argv, v:exception)
                                        endtry
                            
                                        let jobinfo.id = job_id
                                        let s:jobs[job_id] = jobinfo
                                        let s:make_info[a:make_id].active_jobs += [jobinfo]
                            
                                        call s:output_handler(jobinfo, split(output, '\r\?\n', 1), 'stdout', 0)
                                        let stderr_output = readfile(stderr_file)
                                        if !empty(stderr_output)
                                            call s:output_handler(jobinfo, stderr_output, 'stderr', 1)
                                        endif
                                        call delete(stderr_file)
                            
                                        call s:exit_handler(jobinfo, v:shell_error)
                                        return jobinfo
                                    endif
                                finally
                                    call jobinfo.cd_back()
                                    if exists('save_env_file')
                                        call s:restore_env('NEOMAKE_FILE', save_env_file)
                                    endif
                                endtry
                                let s:make_info[a:make_id].active_jobs += [jobinfo]
                                return jobinfo
                            endfunction
                            
    1              0.000002 if !s:can_use_env_in_job_opts
    1              0.000002     function! s:restore_env(var, value) abort
                                    " Cannot unlet environment vars without patch 8.0.1832.
                                    exe printf('let $%s = %s', a:var, string(a:value is s:unset ? '' : a:value))
                                endfunction
    1              0.000001 endif
                            
    1   0.000326   0.000144 let s:command_maker_base = copy(g:neomake#core#command_maker_base)
                            " Check if a temporary file is used, and set it in s:make_info in case it is.
    1              0.000002 function! s:command_maker_base._get_tempfilename(jobinfo) abort dict
                                if has_key(self, 'supports_stdin')
                                    if type(self.supports_stdin) == type(function('tr'))
                                        let supports_stdin = self.supports_stdin(a:jobinfo)
                                    else
                                        let supports_stdin = self.supports_stdin
                                    endif
                                    if supports_stdin
                                        let a:jobinfo.uses_stdin = 1
                                        return get(self, 'tempfile_name', '-')
                                    endif
                                endif
                            
                                if has_key(self, 'tempfile_name')
                                    return self.tempfile_name
                                endif
                            
                                let tempfile_enabled = neomake#utils#GetSetting('tempfile_enabled', self, 1, a:jobinfo.ft, a:jobinfo.bufnr)
                                if !tempfile_enabled
                                    return ''
                                endif
                            
                                let make_id = a:jobinfo.make_id
                                if !has_key(s:make_info[make_id], 'tempfile_name')
                                    if !exists('s:pid')
                                        let s:pid = getpid()
                                    endif
                                    let slash = neomake#utils#Slash()
                                    let bufname = bufname(a:jobinfo.bufnr)
                                    if empty(bufname)
                                        let temp_file = tempname() . slash . 'neomaketmp.'.a:jobinfo.ft
                                    else
                                        " Use absolute path internally, which is important for removal.
                                        let orig_file = neomake#utils#fnamemodify(a:jobinfo.bufnr, ':p')
                                        if empty(orig_file)
                                            let dir = tempname()
                                            let filename = fnamemodify(bufname, ':t')
                                            let s:make_info[make_id].tempfile_dir = dir
                                        else
                                            let dir = fnamemodify(orig_file, ':h')
                                            if filewritable(dir) != 2
                                                let dir = tempname()
                                                let s:make_info[make_id].tempfile_dir = dir
                                                call neomake#log#debug('Using temporary directory for non-writable parent directory.')
                                            endif
                                            let filename = fnamemodify(orig_file, ':t')
                                                        \ .'@neomake_'.s:pid.'_'.make_id
                                            let ext = fnamemodify(orig_file, ':e')
                                            if !empty(ext)
                                                let filename .= '.'.ext
                                            endif
                                            " Use hidden files to make e.g. pytest not trying to import it.
                                            if filename[0] !=# '.'
                                                let filename = '.' . filename
                                            endif
                                        endif
                                        let temp_file = dir . slash . filename
                                    endif
                                    let s:make_info[make_id].tempfile_name = temp_file
                                endif
                                return s:make_info[make_id].tempfile_name
                            endfunction
                            
                            " Get the filename to use for a:jobinfo's make/buffer.
    1              0.000002 function! s:command_maker_base._get_fname_for_buffer(jobinfo) abort
                                let bufnr = a:jobinfo.bufnr
                                let bufname = bufname(bufnr)
                                let temp_file = ''
                                let _uses_stdin = neomake#utils#GetSetting('uses_stdin', a:jobinfo.maker, s:unset_dict, a:jobinfo.ft, bufnr)
                                if _uses_stdin isnot s:unset_dict
                                    let a:jobinfo.uses_stdin = _uses_stdin
                                    let uses_stdin = _uses_stdin
                                    call neomake#log#debug(printf('Using uses_stdin (%s) from setting.',
                                                \ a:jobinfo.uses_stdin), a:jobinfo)
                                    if a:jobinfo.uses_stdin
                                        let temp_file = neomake#utils#GetSetting('tempfile_name', a:jobinfo.maker, '-', a:jobinfo.ft, bufnr)
                                    endif
                                else
                                    if empty(bufname)
                                        let temp_file = self._get_tempfilename(a:jobinfo)
                                        if !get(a:jobinfo, 'uses_stdin', 0) && empty(temp_file)
                                            throw 'Neomake: no file name.'
                                        endif
                                        let used_for = 'unnamed'
                                    elseif getbufvar(bufnr, '&modified')
                                        let temp_file = self._get_tempfilename(a:jobinfo)
                                        if !get(a:jobinfo, 'uses_stdin', 0) && empty(temp_file)
                                            call neomake#log#debug('warning: buffer is modified. You might want to enable tempfiles.',
                                                        \ a:jobinfo)
                                        endif
                                        let used_for = 'modified'
                                    elseif !filereadable(bufname)
                                        let temp_file = self._get_tempfilename(a:jobinfo)
                                        if !get(a:jobinfo, 'uses_stdin', 0) && empty(temp_file)
                                            " Using ':p' as modifier is unpredictable as per doc, but OK.
                                            throw printf('Neomake: file is not readable (%s)', fnamemodify(bufname, ':p'))
                                        endif
                                        let used_for = 'unreadable'
                                    else
                                        let bufname = fnamemodify(bufname, ':.')
                                        let used_for = ''
                                    endif
                            
                                    let uses_stdin = get(a:jobinfo, 'uses_stdin', 0)
                            
                                    if !empty(used_for)
                                        if uses_stdin
                                            call neomake#log#debug(printf(
                                                        \ 'Using stdin for %s buffer (%s).', used_for, temp_file),
                                                        \ a:jobinfo)
                                        elseif !empty(temp_file)
                                            call neomake#log#debug(printf(
                                                        \ 'Using tempfile for %s buffer: "%s".', used_for, temp_file),
                                                        \ a:jobinfo)
                                        endif
                                    endif
                                endif
                            
                                let make_info = s:make_info[a:jobinfo.make_id]
                                " Handle stdin when supports_stdin sets self.tempfile_name = ''.
                                if uses_stdin
                                    if !has_key(make_info, 'buffer_lines')
                                        let make_info.buffer_lines = neomake#utils#get_buffer_lines(bufnr)
                                    endif
                                    let bufname = temp_file
                                elseif !empty(temp_file)
                                    " Use relative path for args.
                                    let bufname = fnamemodify(temp_file, ':.')
                                    let temp_file = fnamemodify(temp_file, ':p')
                                    if !has_key(make_info, 'tempfiles')
                                        let make_info.tempfiles = [temp_file]
                                        let make_info.created_dirs = s:create_dirs_for_file(temp_file)
                                        call neomake#utils#write_tempfile(bufnr, temp_file)
                                    elseif temp_file !=# make_info.tempfiles[0]
                                        call extend(make_info.created_dirs, s:create_dirs_for_file(temp_file))
                                        call writefile(readfile(make_info.tempfiles[0], 'b'), temp_file, 'b')
                                        call add(make_info.tempfiles, temp_file)
                                    endif
                                    let a:jobinfo.tempfile = temp_file
                                endif
                            
                                if !has_key(make_info, 'automake_tick')
                                    let tick = [getbufvar(a:jobinfo.bufnr, 'changedtick'),
                                                \  a:jobinfo.ft]
                                    let make_info.automake_tick = tick
                                    call neomake#log#debug('Setting neomake_automake_tick.', a:jobinfo)
                                    call setbufvar(a:jobinfo.bufnr, 'neomake_automake_tick', tick)
                                endif
                            
                                let a:jobinfo.filename = bufname
                                return bufname
                            endfunction
                            
    1              0.000002 function! s:create_dirs_for_file(fpath) abort
                                let created_dirs = []
                                let last_dir = a:fpath
                                while 1
                                    let temp_dir = fnamemodify(last_dir, ':h')
                                    if isdirectory(temp_dir) || last_dir ==# temp_dir
                                        break
                                    endif
                                    call insert(created_dirs, temp_dir)
                                    let last_dir = temp_dir
                                endwhile
                                for dir in created_dirs
                                    call mkdir(dir, '', 0700)
                                endfor
                                return created_dirs
                            endfunction
                            
    1              0.000003 function! s:command_maker_base._bind_args() abort dict
                                " Resolve args, which might be a function or dictionary.
                                if type(self.args) == type(function('tr'))
                                    " Deprecated: use InitForJob
                                    call neomake#log#warn_once(printf("Please use 'InitForJob' instead of 'args' for maker %s.", self.name),
                                                \ printf('deprecated-args-%s', self.name))
                                    let args = call(self.args, [])
                                elseif type(self.args) == type({})
                                    " Deprecated: use InitForJob
                                    call neomake#log#warn_once(printf("Please use 'InitForJob' instead of 'args.fn' for maker %s.", self.name),
                                                \ printf('deprecated-args-fn-%s', self.name))
                                    let args = call(self.args.fn, [], self.args)
                                else
                                    let args = copy(self.args)
                                endif
                                let self.args = args
                                return self
                            endfunction
                            
    1              0.000002 function! s:command_maker_base._get_argv(jobinfo) abort dict
                                let filename = self._get_fname_for_args(a:jobinfo)
                                let args_is_list = type(self.args) == type([])
                                if args_is_list
                                    let args = neomake#utils#ExpandArgs(self.args)
                                    if !empty(filename)
                                        call add(args, filename)
                                    endif
                                elseif !empty(filename)
                                    let args = copy(self.args)
                                    let args .= (empty(args) ? '' : ' ').neomake#utils#shellescape(filename)
                                else
                                    let args = self.args
                                endif
                                return neomake#compat#get_argv(self.exe, args, args_is_list)
                            endfunction
                            
    1              0.000002 function! s:GetMakerForFiletype(ft, maker_name) abort
                                for config_ft in neomake#utils#get_config_fts(a:ft)
                                    call neomake#utils#load_ft_makers(config_ft)
                                    let f = 'neomake#makers#ft#'.config_ft.'#'.a:maker_name
                                    if exists('*'.f)
                                        let maker = call(f, [])
                                        return maker
                                    endif
                                endfor
                                return s:unset_dict
                            endfunction
                            
    1              0.000002 function! neomake#get_maker_by_name(maker_name, ...) abort
                                let for_ft = a:0 ? a:1 : 0
                                let ft_config = for_ft is# 0 ? &filetype : for_ft
                                let bufnr = bufnr('%')
                                if a:maker_name !~# '\v^\w+$'
                                    throw printf('Neomake: Invalid maker name: "%s"', a:maker_name)
                                endif
                            
                                let maker = neomake#utils#GetSetting('maker', {'name': a:maker_name}, s:unset_dict, ft_config, bufnr)
                                if maker is# s:unset_dict
                                    if a:maker_name ==# 'makeprg'
                                        let maker = s:get_makeprg_maker()
                                    elseif for_ft isnot# 0
                                        let maker = s:GetMakerForFiletype(for_ft, a:maker_name)
                                    else
                                        call neomake#utils#load_global_makers()
                                        let f = 'neomake#makers#'.a:maker_name.'#'.a:maker_name
                                        if exists('*'.f)
                                            let maker = call(f, [])
                                        endif
                                    endif
                                endif
                                if type(maker) != type({})
                                    throw printf('Neomake: Got non-dict for maker %s: %s',
                                                \ a:maker_name, maker)
                                endif
                                if maker isnot# s:unset_dict && !has_key(maker, 'name')
                                    let maker.name = a:maker_name
                                endif
                                return maker
                            endfunction
                            
    1              0.000002 function! neomake#GetMaker(name_or_maker, ...) abort
                                let for_ft = a:0 ? a:1 : 0
                                let bufnr = bufnr('%')
                                if type(a:name_or_maker) == type({})
                                    let maker = a:name_or_maker
                                    if !has_key(maker, 'name')
                                        let maker.name = 'unnamed_maker'
                                    endif
                                else
                                    let maker = neomake#get_maker_by_name(a:name_or_maker, for_ft)
                                    if maker is# s:unset_dict
                                        if !a:0
                                            " Check &filetype if no args where provided.
                                            let maker = neomake#get_maker_by_name(a:name_or_maker, &filetype)
                                        endif
                                    endif
                                    if maker is# s:unset_dict
                                        if for_ft isnot# 0
                                            throw printf('Neomake: Maker not found (for %s): %s',
                                                        \ !empty(for_ft) ? 'filetype '.for_ft : 'empty filetype',
                                                        \ a:name_or_maker)
                                        else
                                            throw printf('Neomake: Maker not found (without filetype): %s',
                                                        \ a:name_or_maker)
                                        endif
                                    endif
                                endif
                                return neomake#create_maker_object(maker, a:0 ? a:1 : &filetype)
                            endfunction
                            
                            " NOTE: uses ft and bufnr for config only.
    1              0.000002 function! neomake#create_maker_object(maker, ft) abort
                                let [maker, ft, bufnr] = [a:maker, a:ft, bufnr('%')]
                            
                                " Create the maker object.
                                let GetEntries = neomake#utils#GetSetting('get_list_entries', maker, -1, ft, bufnr)
                                if GetEntries isnot# -1
                                    let maker = copy(maker)
                                    let maker.get_list_entries = GetEntries
                                else
                                    let maker = extend(copy(s:command_maker_base), copy(maker))
                                endif
                                if !has_key(maker, 'get_list_entries')
                                    " Set defaults for command/job based makers.
                                    let defaults = extend(
                                                \ copy(g:neomake#config#_defaults['maker_defaults']),
                                                \ neomake#config#get('maker_defaults'))
                                    call extend(defaults, {
                                        \ 'exe': maker.name,
                                        \ 'args': [],
                                        \ })
                                    if !has_key(maker, 'process_output') && !has_key(maker, 'process_json')
                                        call extend(defaults, {
                                            \ 'errorformat': &errorformat,
                                            \ })
                                    endif
                                    for [key, default] in items(defaults)
                                        let maker[key] = neomake#utils#GetSetting(key, {'name': maker.name}, get(maker, key, default), ft, bufnr, 1)
                                        unlet default  " for Vim without patch-7.4.1546
                                    endfor
                                endif
                                if v:profiling
                                    call add(s:hack_keep_refs_for_profiling, maker)
                                endif
                                return maker
                            endfunction
                            
    1              0.000003 if exists('*getcompletion')
    1              0.000002     function! s:get_makers_for_pattern(pattern) abort
                                    " Get function prefix based on pattern, until the first backslash.
                                    let prefix = substitute(a:pattern, '\v\\.*', '', '')
                            
                                    " NOTE: the pattern uses &ignorecase.
                                    let funcs = getcompletion(prefix.'[a-z]', 'function')
                                    call filter(funcs, 'v:val =~# a:pattern')
                                    " Remove prefix.
                                    call map(funcs, 'v:val['.len(prefix).':]')
                                    " Only keep lowercase function names.
                                    call filter(funcs, "v:val =~# '\\m^[a-z].*('")
                                    " Remove parenthesis and #.* (for project makers).
                                    return sort(map(funcs, "substitute(v:val, '\\v[(#].*', '', '')"))
                                endfunction
    1              0.000001 else
                                function! s:get_makers_for_pattern(pattern) abort
                                    let funcs_output = neomake#utils#redir('fun /'.a:pattern)
                                    return sort(map(split(funcs_output, '\n'),
                                                \ "substitute(v:val, '\\v^.*#(.*)\\(.*$', '\\1', '')"))
                                endfunction
                            endif
                            
    1              0.000002 function! neomake#GetMakers(ft) abort
                                " Get all makers for a given filetype.  This is used from completion.
                                " XXX: this should probably use a callback or some other more stable
                                " approach to get the list of makers (than looking at the lowercase
                                " functions)?!
                            
                                let makers = []
                                " Do not use 'b:neomake_jsx_javascript_foo_maker' twice for
                                " ft=jsx.javascript.
                                let used_vars = []
                                for ft in neomake#utils#get_config_fts(a:ft)
                                    call neomake#utils#load_ft_makers(ft)
                            
                                    " Add sorted list per filetype.
                                    let add = []
                            
                                    let maker_names = s:get_makers_for_pattern('neomake#makers#ft#'.ft.'#\l')
                                    for maker_name in maker_names
                                        if index(makers, maker_name) == -1 && index(add, maker_name) == -1
                                            let add += [maker_name]
                                        endif
                                    endfor
                            
                                    " Get makers from g:/b: variables.
                                    for v in sort(extend(keys(g:), keys(b:)))
                                        if index(used_vars, v) != -1
                                            continue
                                        endif
                                        let maker_name = matchstr(v, '\v^neomake_'.ft.'_\zs[0-9a-z_]+\ze_maker$')
                                        if !empty(maker_name)
                                                    \ && index(makers, maker_name) == -1
                                                    \ && index(add, maker_name) == -1
                                            let used_vars += [v]
                                            let add += [maker_name]
                                        endif
                                    endfor
                            
                                    " Get makers from new-style config.
                                    for [maker_name, val] in items(neomake#config#get('ft.'.ft))
                                        if has_key(val, 'maker')
                                                    \ && index(makers, maker_name) == -1
                                                    \ && index(add, maker_name) == -1
                                            let add += [maker_name]
                                        endif
                                    endfor
                            
                                    call sort(add)
                                    call extend(makers, add)
                                endfor
                                return makers
                            endfunction
                            
    1              0.000002 function! neomake#GetProjectMakers() abort
                                call neomake#utils#load_global_makers()
                                return s:get_makers_for_pattern('neomake#makers#\(ft#\)\@!\l')
                            endfunction
                            
    1              0.000002 function! neomake#GetEnabledMakers(...) abort
                                let file_mode = a:0
                                if !file_mode
                                    " If we have no filetype, use the global default makers.
                                    " This variable is also used for project jobs, so it has no
                                    " buffer local ('b:') counterpart for now.
                                    let enabled_makers = copy(get(g:, 'neomake_enabled_makers', []))
                                    if empty(enabled_makers)
                                        let makeprg_maker = s:get_makeprg_maker()
                                        if !empty(makeprg_maker)
                                            let makeprg_maker = neomake#GetMaker(makeprg_maker)
                                            let makeprg_maker.auto_enabled = 1
                                            let enabled_makers = [makeprg_maker]
                                        endif
                                    else
                                        call map(enabled_makers, "extend(neomake#GetMaker(v:val),
                                                    \ {'auto_enabled': 0}, 'error')")
                                    endif
                                else
                                    let enabled_makers = []
                                    let makers = neomake#utils#GetSetting('enabled_makers', {}, s:unset_list, a:1, bufnr('%'))
                                    if makers is# s:unset_list
                                        let auto_enabled = 1
                                        for config_ft in neomake#utils#get_config_fts(a:1)
                                            call neomake#utils#load_ft_makers(config_ft)
                                            let fnname = 'neomake#makers#ft#'.config_ft.'#EnabledMakers'
                                            if exists('*'.fnname)
                                                let makers = call(fnname, [])
                                                break
                                            endif
                                        endfor
                                    else
                                        let auto_enabled = 0
                                    endif
                            
                                    let makers = neomake#map_makers(makers, a:1, auto_enabled)
                                    for maker in makers
                                        let maker.auto_enabled = auto_enabled
                                        let enabled_makers += [maker]
                                    endfor
                                endif
                                return enabled_makers
                            endfunction
                            
    1              0.000002 let s:ignore_automake_events = 0
    1              0.000002 function! s:HandleLoclistQflistDisplay(jobinfo, loc_or_qflist, ...) abort
                                let open_val = a:0 ? a:1 : get(g:, 'neomake_open_list', 0)
                                if !open_val
                                    return
                                endif
                                let height = get(g:, 'neomake_list_height', 10)
                                if !height
                                    return
                                endif
                                let height = min([len(a:loc_or_qflist), height])
                                if a:jobinfo.file_mode
                                    call neomake#log#debug('Handling location list: executing lwindow.', a:jobinfo)
                                    let cmd = 'lwindow'
                                else
                                    call neomake#log#debug('Handling quickfix list: executing cwindow.', a:jobinfo)
                                    let cmd = 'cwindow'
                                endif
                                if open_val == 2
                                    let make_id = a:jobinfo.make_id
                                    let make_info = s:make_info[make_id]
                                    let s:ignore_automake_events += 1
                                    try
                                        call neomake#compat#save_prev_windows()
                            
                                        let win_count = winnr('$')
                                        exe cmd height
                                        let new_win_count = winnr('$')
                                        if win_count == new_win_count
                                            " No new window, adjust height eventually.
                                            let found = 0
                            
                                            if get(make_info, '_did_lwindow', 0)
                                                for w in range(1, winnr('$'))
                                                    if getwinvar(w, 'neomake_window_for_make_id') == make_id
                                                        let found = w
                                                        break
                                                    endif
                                                endfor
                                                if found
                                                    let cmd = printf('%dresize %d', found, height)
                                                    call neomake#log#debug(printf(
                                                                \ 'Resizing existing quickfix window: %s.',
                                                                \ cmd), a:jobinfo)
                                                    exe cmd
                                                else
                                                    call neomake#log#debug(
                                                                \ 'Could not find corresponding quickfix window.',
                                                                \ a:jobinfo)
                                                endif
                                            endif
                                        elseif new_win_count > win_count
                                            if &filetype !=# 'qf'
                                                call neomake#log#debug(printf(
                                                            \ 'WARN: unexpected filetype for new window: %s',
                                                            \ &filetype), a:jobinfo)
                                            else
                                                call neomake#log#debug(printf(
                                                            \ 'list window has been opened (old count: %d, new count: %d).',
                                                            \ win_count, new_win_count), a:jobinfo)
                                                let w:neomake_window_for_make_id = a:jobinfo.make_id
                                            endif
                                        else
                                            call neomake#log#debug(printf(
                                                        \ 'list window has been closed (old count: %d, new count: %d).',
                                                        \ win_count, new_win_count), a:jobinfo)
                                        endif
                                        call neomake#compat#restore_prev_windows()
                                        let make_info._did_lwindow = 1
                                    finally
                                        let s:ignore_automake_events -= 1
                                    endtry
                                else
                                    exe cmd height
                                endif
                            endfunction
                            
                            " Experimental/private wrapper.
    1              0.000002 function! neomake#_handle_list_display(jobinfo, ...) abort
                                if a:0
                                    let list = a:1
                                else
                                    let list = a:jobinfo.file_mode ? getloclist(0) : getqflist()
                                endif
                                call s:HandleLoclistQflistDisplay(a:jobinfo, list, 2)
                            endfunction
                            
                            " Queue an action to be processed later for autocmd a:event or through a timer
                            " for a:event=Timer.
                            " It will call a:data[0], with a:data[1] as args (where the first should be
                            " a jobinfo object).  The callback should return 1 if it was successful,
                            " with 0 it will be re-queued.
                            " When called recursively (queueing the same event/data again, it will be
                            " re-queued also).
    1              0.000002 function! s:queue_action(events, data) abort
                                let job_or_make_info = a:data[1][0]
                                if has_key(job_or_make_info, 'make_id')
                                    let jobinfo = job_or_make_info
                                    let log_context = jobinfo
                                else
                                    let make_info = job_or_make_info
                                    let log_context = make_info.options
                                endif
                                call neomake#log#debug(printf('Queueing action: %s for %s.',
                                            \ a:data[0], join(a:events, ', ')), log_context)
                            
                                for event in a:events
                                    if event ==# 'Timer'
                                        if !exists('jobinfo.action_queue_timer_tries')
                                            let job_or_make_info.action_queue_timer_tries = {'count': 1, 'data': a:data[0]}
                                        else
                                            let job_or_make_info.action_queue_timer_tries.count += 1
                                        endif
                                        if has_key(s:action_queue_timer_timeouts, job_or_make_info.action_queue_timer_tries.count)
                                            let timeout = s:action_queue_timer_timeouts[job_or_make_info.action_queue_timer_tries.count]
                                        else
                                            throw printf('Neomake: Giving up handling Timer callbacks after %d attempts. Please report this. See :messages for more information.', len(s:action_queue_timer_timeouts))
                                        endif
                                        if has('timers')
                                            if exists('s:action_queue_timer')
                                                call timer_stop(s:action_queue_timer)
                                            endif
                                            let s:action_queue_timer = timer_start(timeout, function('s:process_action_queue_timer_cb'))
                                            call neomake#log#debug(printf(
                                                        \ 'Retrying Timer event in %dms.', timeout), job_or_make_info)
                                        else
                                            call neomake#log#debug('Retrying Timer event on CursorHold(I).', job_or_make_info)
                                            if !exists('#neomake_event_queue#CursorHold')
                                                let s:action_queue_registered_events += ['CursorHold', 'CursorHoldI']
                                                augroup neomake_event_queue
                                                    exe 'autocmd CursorHold,CursorHoldI * call s:process_action_queue('''.event.''')'
                                                augroup END
                                            endif
                                        endif
                                    else
                                        if !exists('#neomake_event_queue#'.event)
                                            let s:action_queue_registered_events += [event]
                                            augroup neomake_event_queue
                                                exe 'autocmd '.event.' * call s:process_action_queue('''.event.''')'
                                            augroup END
                                        endif
                                    endif
                                endfor
                                call add(s:action_queue, [a:events, a:data])
                            endfunction
                            
    1              0.000002 function! s:process_action_queue_timer_cb(...) abort
                                call neomake#log#debug(printf(
                                            \ 'action queue: callback for Timer queue (%d).', s:action_queue_timer))
                                unlet s:action_queue_timer
                                call s:process_action_queue('Timer')
                            endfunction
                            
    1              0.000001 function! s:process_action_queue(event) abort
                                let queue = s:action_queue
                                let q_for_this_event = []
                                let i = 0
                                for [events, v] in queue
                                    if index(events, a:event) != -1
                                        call add(q_for_this_event, [i, v])
                                    endif
                                    let i += 1
                                endfor
                                call neomake#log#debug(printf('action queue: processing for %s (%d items, winnr: %d).',
                                            \ a:event, len(q_for_this_event), winnr()), {'bufnr': bufnr('%')})
                            
                                let processed = []
                                let removed = 0
                                let abort = 0
                                for [i, data] in q_for_this_event
                                    let job_or_make_info = data[1][0]
                                    let v = remove(queue, i - removed)
                                    let removed += 1
                                    if abort
                                        call add(queue, v)
                                        continue
                                    endif
                                    let log_context = has_key(job_or_make_info, 'make_id') ? job_or_make_info : job_or_make_info.options
                            
                                    call neomake#log#debug(printf('action queue: calling %s.',
                                                \ data[0]), log_context)
                                    try
                                        " Call the queued action.  On failure they should have requeued
                                        " themselves already.
                                        let rv = call(data[0], data[1])
                                    catch /^Neomake: /
                                        let error = substitute(v:exception, '^Neomake: ', '', '')
                                        call neomake#log#exception(error, log_context)
                            
                                        " Cancel job in case its action failed to get re-queued after X
                                        " attempts.
                                        if has_key(job_or_make_info, 'id')
                                            call neomake#CancelJob(job_or_make_info.id)
                                        endif
                                        continue
                                    endtry
                                    if rv is# 1
                                        let processed += [data]
                                    elseif a:event !=# 'Timer' && has_key(job_or_make_info, 'action_queue_timer_tries')
                                        call neomake#log#debug('s:process_action_queue: decrementing timer tries for non-Timer event.', job_or_make_info)
                                        let job_or_make_info.action_queue_timer_tries.count -= 1
                                    endif
                                endfor
                                call neomake#log#debug(printf('action queue: processed %d items.',
                                            \ len(processed)), {'bufnr': bufnr('%')})
                            
                                call s:clean_action_queue_augroup()
                            endfunction
                            
                            
    1              0.000003 if has('timers')
    1              0.000001     function! s:get_left_events() abort
                                    let r = {}
                                    for [events, _] in s:action_queue
                                        for event in events
                                            let r[event] = 1
                                        endfor
                                    endfor
                                    return keys(r)
                                endfunction
    1              0.000001 else
                                function! s:get_left_events() abort
                                    let r = {}
                                    for [events, _] in s:action_queue
                                        for event in events
                                            if event ==# 'Timer'
                                                let r['CursorHold'] = 1
                                                let r['CursorHoldI'] = 1
                                            else
                                                let r[event] = 1
                                            endif
                                        endfor
                                    endfor
                                    return keys(r)
                                endfunction
                            endif
                            
                            
    1              0.000001 function! s:clean_action_queue_augroup() abort
                                if empty(s:action_queue_registered_events)
                                    return
                                endif
                                let left_events = s:get_left_events()
                            
                                if empty(left_events)
                                    autocmd! neomake_event_queue
                                    augroup! neomake_event_queue
                                else
                                    let clean_events = []
                                    for event in s:action_queue_registered_events
                                        if index(left_events, event) == -1
                                            let clean_events += [event]
                                        endif
                                    endfor
                                    if !empty(clean_events)
                                        augroup neomake_event_queue
                                        for event in clean_events
                                            if exists('#neomake_event_queue#'.event)
                                                exe 'au! '.event
                                            endif
                                        endfor
                                        augroup END
                                    endif
                                endif
                                let s:action_queue_registered_events = left_events
                            endfunction
                            
                            " Get a maker for &makeprg.
                            " This could be cached, but needs to take into account / set &errorformat,
                            " and other settings that are handled by neomake#GetMaker.
    1              0.000001 function! s:get_makeprg_maker() abort
                                if empty(&makeprg)
                                    return {}
                                elseif &makeprg =~# '\s'
                                    let maker = neomake#utils#MakerFromCommand(&makeprg)
                                else
                                    let maker = neomake#utils#MakerFromCommand([&makeprg])
                                endif
                                let maker.name = 'makeprg'
                                " Do not append file.  &makeprg should contain %/# for this instead.
                                let maker.append_file = 0
                                return neomake#GetMaker(maker)
                            endfunction
                            
    1              0.000001 function! s:Make(options) abort
                                let is_automake = !empty(expand('<abuf>'))
                                if is_automake
                                    if s:ignore_automake_events
                                        call neomake#log#debug(printf(
                                                    \ 'Ignoring Make through autocommand due to s:ignore_automake_events=%d.', s:ignore_automake_events), {'winnr': winnr()})
                                        return []
                                    endif
                                    let disabled = neomake#config#get_with_source('disabled', 0)
                                    if disabled[0]
                                        call neomake#log#debug(printf(
                                                    \ 'Make through autocommand disabled via %s.', disabled[1]))
                                        return []
                                    endif
                                endif
                            
                                let s:make_id += 1
                                let make_id = s:make_id
                                let options = extend(copy(a:options), {
                                            \ 'file_mode': 1,
                                            \ 'bufnr': bufnr('%'),
                                            \ 'ft': &filetype,
                                            \ 'make_id': make_id,
                                            \ }, 'keep')
                                let bufnr = options.bufnr
                                let file_mode = options.file_mode
                            
                                let s:make_info[make_id] = {
                                            \ 'cwd': getcwd(),
                                            \ 'verbosity': get(g:, 'neomake_verbose', 1),
                                            \ 'active_jobs': [],
                                            \ 'finished_jobs': [],
                                            \ 'options': options,
                                            \ }
                                let make_info = s:make_info[make_id]
                                if &verbose
                                    let make_info.verbosity += &verbose
                                    call neomake#log#debug(printf(
                                                \ 'Adding &verbose (%d) to verbosity level: %d.',
                                                \ &verbose, make_info.verbosity), options)
                                endif
                                if make_info.verbosity >= 3
                                    call neomake#log#debug(printf(
                                                \ 'Calling Make with options %s.',
                                                \ string(filter(copy(options), "index(['bufnr', 'make_id'], v:key) == -1"))), {'make_id': make_id, 'bufnr': bufnr})
                                endif
                            
                                " Use pre-compiled jobs (used with automake).
                                if has_key(options, 'jobs')
                                    let jobs = map(copy(options.jobs), "extend(v:val, {'make_id': make_id})")
                                    unlet options.jobs
                                else
                                    if has_key(options, 'enabled_makers')
                                        if file_mode
                                            let makers = neomake#map_makers(options.enabled_makers, options.ft, 0)
                                        else
                                            let makers = neomake#map_makers(options.enabled_makers, -1, 0)
                                        endif
                                        unlet options.enabled_makers
                                    else
                                        let makers = call('neomake#GetEnabledMakers', file_mode ? [options.ft] : [])
                                        if empty(makers)
                                            if file_mode
                                                let msg = printf('Nothing to make: no enabled file mode makers (filetype=%s).', options.ft)
                                                if is_automake
                                                    call neomake#log#debug(msg, options)
                                                else
                                                    call neomake#log#warning(msg, options)
                                                endif
                                                unlet s:make_info[make_id]
                                                return []
                                            endif
                                        endif
                                    endif
                                    let jobs = neomake#core#create_jobs(options, makers)
                                endif
                            
                                if empty(jobs)
                                    call neomake#log#debug('Nothing to make: no valid makers.', options)
                                    call s:clean_make_info(make_info)
                                    return []
                                endif
                            
                                let maker_info = join(map(copy(jobs),
                                            \ "v:val.maker.name . (get(v:val.maker, 'auto_enabled', 0) ? ' (auto)' : '')"), ', ')
                                call neomake#log#debug(printf(
                                            \ 'Running makers: %s.', maker_info), options)
                            
                                let make_info.jobs_queue = jobs
                            
                                if file_mode
                                    " XXX: this clears counts for job's buffer only, but we add counts for
                                    " the entry's buffers, which might be different!
                                    call neomake#statusline#ResetCountsForBuf(bufnr)
                                    if g:neomake_place_signs
                                        call neomake#signs#Reset(bufnr, 'file')
                                    endif
                                else
                                    call neomake#statusline#ResetCountsForProject()
                                    if g:neomake_place_signs
                                        call neomake#signs#ResetProject()
                                    endif
                                endif
                            
                                let w:neomake_make_ids = add(get(w:, 'neomake_make_ids', []), make_id)
                            
                                " Cancel any already running jobs for the makers from these jobs.
                                if !empty(s:jobs)
                                    " @vimlint(EVL102, 1, l:job)
                                    for job in jobs
                                        let running_already = values(filter(copy(s:jobs),
                                                    \ 'v:val.maker == job.maker'
                                                    \ .' && v:val.bufnr == job.bufnr'
                                                    \ ." && !get(v:val, 'canceled')"))
                                        if !empty(running_already)
                                            let jobinfo = running_already[0]
                                            call neomake#log#info(printf(
                                                        \ 'Cancelling already running job (%d.%d) for the same maker.',
                                                        \ jobinfo.make_id, jobinfo.id), {'make_id': make_id})
                                            call neomake#CancelJob(jobinfo.id, 1)
                                        endif
                                    endfor
                                endif
                            
                                " Start all jobs in the queue (until serialized).
                                let jobinfos = []
                                while 1
                                    if empty(make_info.jobs_queue)
                                        break
                                    endif
                                    let jobinfo = s:handle_next_job({})
                                    if empty(jobinfo)
                                        break
                                    endif
                                    call add(jobinfos, jobinfo)
                                    if jobinfo.serialize
                                        " Break and continue through exit handler.
                                        break
                                    endif
                                endwhile
                                return jobinfos
                            endfunction
                            
    1              0.000002 function! s:AddExprCallback(jobinfo, prev_list) abort
                                if s:need_to_postpone_loclist(a:jobinfo)
                                    return s:queue_action(['BufEnter', 'WinEnter'], ['s:AddExprCallback',
                                                \ [a:jobinfo, a:prev_list] + a:000])
                                endif
                                let maker = a:jobinfo.maker
                                let file_mode = a:jobinfo.file_mode
                                let list = file_mode ? getloclist(0) : getqflist()
                                let prev_index = len(a:prev_list)
                                let index = prev_index-1
                                let Postprocess = neomake#utils#GetSetting('postprocess', maker, [], a:jobinfo.ft, a:jobinfo.bufnr)
                                if type(Postprocess) != type([])
                                    let postprocessors = [Postprocess]
                                else
                                    let postprocessors = Postprocess
                                endif
                                let debug = neomake#utils#get_verbosity(a:jobinfo) >= 3 || !empty(get(g:, 'neomake_logfile'))
                                let maker_name = maker.name
                                let make_info = s:make_info[a:jobinfo.make_id]
                                let default_type = 'unset'
                            
                                let entries = []
                                let changed_entries = {}
                                let removed_entries = []
                                let different_bufnrs = {}
                                let llen = len(list)
                                let bufnr_from_temp = {}
                                let bufnr_from_stdin = {}
                                let tempfile_bufnrs = has_key(make_info, 'tempfiles') ? map(copy(make_info.tempfiles), 'bufnr(v:val)') : []
                                let uses_stdin = get(a:jobinfo, 'uses_stdin', 0)
                                while index < llen - 1
                                    let index += 1
                                    let entry = list[index]
                                    let entry.maker_name = maker_name
                            
                                    let before = copy(entry)
                                    " Handle unlisted buffers via tempfiles and uses_stdin.
                                    if file_mode && entry.bufnr && entry.bufnr != a:jobinfo.bufnr
                                                \ && (!empty(tempfile_bufnrs) || uses_stdin)
                                        let map_bufnr = index(tempfile_bufnrs, entry.bufnr)
                                        if map_bufnr != -1
                                            let entry.bufnr = a:jobinfo.bufnr
                                            let map_bufnr = tempfile_bufnrs[map_bufnr]
                                            if !has_key(bufnr_from_temp, map_bufnr)
                                                let bufnr_from_temp[map_bufnr] = []
                                            endif
                                            let bufnr_from_temp[map_bufnr] += [index+1]
                                        elseif uses_stdin
                                            if !buflisted(entry.bufnr) && bufexists(entry.bufnr)
                                                if !has_key(bufnr_from_stdin, entry.bufnr)
                                                    let bufnr_from_stdin[entry.bufnr] = []
                                                endif
                                                let bufnr_from_stdin[entry.bufnr] += [index+1]
                                                let entry.bufnr = a:jobinfo.bufnr
                                            endif
                                        endif
                                    endif
                                    if debug && entry.bufnr && entry.bufnr != a:jobinfo.bufnr
                                        if !has_key(different_bufnrs, entry.bufnr)
                                            let different_bufnrs[entry.bufnr] = 1
                                        else
                                            let different_bufnrs[entry.bufnr] += 1
                                        endif
                                    endif
                                    if !empty(postprocessors)
                                        let g:neomake_postprocess_context = {'jobinfo': a:jobinfo}
                                        try
                                            for F in postprocessors
                                                if type(F) == type({})
                                                    call call(F.fn, [entry], F)
                                                else
                                                    call call(F, [entry], maker)
                                                endif
                                                unlet! F  " vim73
                                            endfor
                                        finally
                                            unlet! g:neomake_postprocess_context  " Might be unset already with sleep in postprocess.
                                        endtry
                                    endif
                                    if entry != before
                                        let changed_entries[index] = entry
                                        if debug
                                            call neomake#log#debug(printf(
                                              \ 'Modified list entry %d (postprocess): %s.',
                                              \ index + 1,
                                              \ string(neomake#utils#diff_dict(before, entry))),
                                              \ a:jobinfo)
                                        endif
                                    endif
                            
                                    if entry.valid <= 0
                                        if entry.valid < 0 || maker.remove_invalid_entries
                                            call insert(removed_entries, index)
                                            let entry_copy = copy(entry)
                                            call neomake#log#debug(printf(
                                                        \ 'Removing invalid entry: %s (%s).',
                                                        \ remove(entry_copy, 'text'),
                                                        \ string(entry_copy)), a:jobinfo)
                                            continue
                                        endif
                                    endif
                            
                                    if empty(entry.type) && entry.valid
                                        if default_type ==# 'unset'
                                            let default_type = neomake#utils#GetSetting('default_entry_type', maker, 'W', a:jobinfo.ft, a:jobinfo.bufnr)
                                        endif
                                        if !empty(default_type)
                                            let entry.type = default_type
                                            let changed_entries[index] = entry
                                        endif
                                    endif
                                    call add(entries, entry)
                                endwhile
                            
                                " Add marker for custom quickfix to the first (new) entry.
                                if neomake#quickfix#is_enabled() && !empty(entries)
                                    let config = {
                                                \ 'name': maker_name,
                                                \ 'short': get(a:jobinfo.maker, 'short_name', maker_name[:3]),
                                                \ }
                                    let marker_entry = copy(entries[0])
                                    let marker_entry.text .= printf(' nmcfg:%s', string(config))
                                    let changed_entries[prev_index] = marker_entry
                                endif
                            
                                if !empty(changed_entries) || !empty(removed_entries)
                                    let list = file_mode ? getloclist(0) : getqflist()
                                    if !empty(changed_entries)
                                        for k in keys(changed_entries)
                                            let list[k] = changed_entries[k]
                                        endfor
                                    endif
                                    if !empty(removed_entries)
                                        for k in removed_entries
                                            call remove(list, k)
                                        endfor
                                    endif
                                    if file_mode
                                        call setloclist(0, list, 'r')
                                    else
                                        call setqflist(list, 'r')
                                    endif
                                endif
                            
                                if !empty(bufnr_from_temp) || !empty(bufnr_from_stdin)
                                    if !has_key(make_info, '_wipe_unlisted_buffers')
                                        let make_info._wipe_unlisted_buffers = []
                                    endif
                                    let make_info._wipe_unlisted_buffers += keys(bufnr_from_stdin) + keys(bufnr_from_stdin)
                                    if !empty(bufnr_from_temp)
                                        for [tempbuf, entries_idx] in items(bufnr_from_temp)
                                            call neomake#log#debug(printf(
                                                        \ 'Used bufnr from temporary buffer %d (%s) for %d entries: %s.',
                                                        \ tempbuf,
                                                        \ bufname(+tempbuf),
                                                        \ len(entries_idx),
                                                        \ join(entries_idx, ', ')), a:jobinfo)
                                        endfor
                                    endif
                                    if !empty(bufnr_from_stdin)
                                        for [tempbuf, entries_idx] in items(bufnr_from_stdin)
                                            call neomake#log#debug(printf(
                                                        \ 'Used bufnr from stdin buffer %d (%s) for %d entries: %s.',
                                                        \ tempbuf,
                                                        \ bufname(+tempbuf),
                                                        \ len(entries_idx),
                                                        \ join(entries_idx, ', ')), a:jobinfo)
                                        endfor
                                    endif
                                endif
                                if !empty(different_bufnrs)
                                    call neomake#log#debug(printf('WARN: seen entries with bufnr different from jobinfo.bufnr (%d): %s, current bufnr: %d.', a:jobinfo.bufnr, string(different_bufnrs), bufnr('%')))
                                endif
                            
                                return s:ProcessEntries(a:jobinfo, entries, a:prev_list)
                            endfunction
                            
    1              0.000002 function! s:already_queued_actions(jobinfo) abort
                                " Check if there are any queued actions for this job.
                                let queued_actions = []
                                for [_, v] in s:action_queue
                                    if v[1][0] == a:jobinfo
                                        let queued_actions += [v[0]]
                                    endif
                                endfor
                                return queued_actions
                            endfunction
                            
    1              0.000001 function! s:CleanJobinfo(jobinfo, ...) abort
                                if get(a:jobinfo, 'pending_output', 0) && !get(a:jobinfo, 'canceled', 0)
                                    call neomake#log#debug(
                                                \ 'Output left to be processed, not cleaning job yet.', a:jobinfo)
                                    return
                                endif
                            
                                let queued_actions = s:already_queued_actions(a:jobinfo)
                                if !empty(queued_actions)
                                    call neomake#log#debug(printf(
                                                \ 'Skipping cleaning of job info because of queued actions: %s.',
                                                \ join(queued_actions, ', ')), a:jobinfo)
                                    return s:queue_action(['WinEnter'], ['s:CleanJobinfo', [a:jobinfo]])
                                endif
                            
                                call neomake#log#debug('Cleaning jobinfo.', a:jobinfo)
                                let a:jobinfo.finished = 1
                            
                                if !has_key(s:make_info, a:jobinfo.make_id)
                                    return
                                endif
                                let make_info = s:make_info[a:jobinfo.make_id]
                                call filter(make_info.active_jobs, 'v:val != a:jobinfo')
                            
                                if has_key(s:jobs, get(a:jobinfo, 'id', -1))
                                    call remove(s:jobs, a:jobinfo.id)
                                    call filter(s:map_job_ids, 'v:val != a:jobinfo.id')
                            
                                    if has_key(s:pending_outputs, a:jobinfo.id)
                                        unlet s:pending_outputs[a:jobinfo.id]
                                    endif
                                endif
                            
                                if exists('s:kill_vim_timers')
                                    for [timer, job] in items(s:kill_vim_timers)
                                        if job == a:jobinfo
                                            call timer_stop(+timer)
                                            unlet s:kill_vim_timers[timer]
                                            break
                                        endif
                                    endfor
                                endif
                            
                                if !get(a:jobinfo, 'canceled', 0)
                                            \ && !get(a:jobinfo, 'failed_to_start', 0)
                                    let make_info.finished_jobs += [a:jobinfo]
                                    call neomake#utils#hook('NeomakeJobFinished', {'jobinfo': a:jobinfo})
                                endif
                            
                                " Trigger cleanup (and autocommands) if all jobs have finished.
                                if empty(make_info.active_jobs) && empty(make_info.jobs_queue)
                                    call s:clean_make_info(make_info)
                                    return 1
                                endif
                            endfunction
                            
    1              0.000002 function! s:clean_make_info(make_info, ...) abort
                                let make_id = a:make_info.options.make_id
                                let bang = a:0 ? a:1 : 0
                                if !bang && !empty(a:make_info.active_jobs)
                                    call neomake#log#debug(printf(
                                                \ 'Skipping cleaning of make info: %d active jobs.',
                                                \ len(a:make_info.active_jobs)), a:make_info.options)
                                    return
                                endif
                            
                                " Assert: there should be no queued actions for jobs or makes.
                                if s:is_testing
                                    let queued = []
                                    for [_, v] in s:action_queue
                                        if has_key(v[1][0], 'make_id')
                                            let jobinfo = v[1][0]
                                            if jobinfo.make_id == make_id && v[0] !=# 's:CleanJobinfo'
                                                let queued += ['job '.jobinfo.id]
                                            endif
                                        else
                                            if v[1][0] == a:make_info
                                                let queued += ['make '.make_id]
                                            endif
                                        endif
                                    endfor
                                    if !empty(queued)
                                        throw 'action queue is not empty: '.string(queued)
                                    endif
                                endif
                            
                                if exists('*neomake#statusline#make_finished')
                                    call neomake#statusline#make_finished(a:make_info)
                                endif
                            
                                if !empty(a:make_info.finished_jobs)
                                    " Clean old signs after all jobs have finished, so that they can be
                                    " reused, avoiding flicker and keeping them for longer in general.
                                    if g:neomake_place_signs
                                        if a:make_info.options.file_mode
                                            call neomake#signs#CleanOldSigns(a:make_info.options.bufnr, 'file')
                                        else
                                            call neomake#signs#CleanAllOldSigns('project')
                                        endif
                                    endif
                                    call s:clean_for_new_make(a:make_info)
                                    call neomake#EchoCurrentError(1)
                                    if get(a:make_info, 'canceled', 0)
                                        call neomake#log#debug('Skipping final processing for canceled make.', a:make_info)
                                        call s:do_clean_make_info(a:make_info)
                                    else
                                        call s:handle_locqf_list_for_finished_jobs(a:make_info)
                                    endif
                                else
                                    call s:do_clean_make_info(a:make_info)
                                endif
                            endfunction
                            
    1              0.000001 function! s:do_clean_make_info(make_info) abort
                                call neomake#log#debug('Cleaning make info.', a:make_info.options)
                                let make_id = a:make_info.options.make_id
                            
                                " Remove make_id from its window.
                                let [t, w] = s:GetTabWinForMakeId(make_id)
                                let make_ids = neomake#compat#gettabwinvar(t, w, 'neomake_make_ids', [])
                                let idx = index(make_ids, make_id)
                                if idx != -1
                                    call remove(make_ids, idx)
                                    call settabwinvar(t, w, 'neomake_make_ids', make_ids)
                                endif
                            
                                " Clean up temporary files and buffers.
                                let wipe_unlisted_buffers = get(a:make_info, '_wipe_unlisted_buffers', [])
                                let tempfiles = get(a:make_info, 'tempfiles')
                                if !empty(tempfiles)
                                    for tempfile in tempfiles
                                        let delete_ret = delete(tempfile)
                                        if delete_ret == 0
                                            call neomake#log#debug(printf('Removing temporary file: "%s".',
                                                        \ tempfile))
                                        else
                                            call neomake#log#warning(printf('Failed to remove temporary file: "%s" (%d).',
                                                        \ tempfile, delete_ret))
                                        endif
                                        let bufnr_tempfile = bufnr(tempfile)
                                        if bufnr_tempfile != -1 && !buflisted(bufnr_tempfile)
                                            let wipe_unlisted_buffers += [bufnr_tempfile]
                                        endif
                                    endfor
                            
                                    " Only delete the dir, if Vim supports it.
                                    if v:version >= 705 || (v:version == 704 && has('patch1107'))
                                        for dir in reverse(copy(get(a:make_info, 'created_dirs')))
                                            call delete(dir, 'd')
                                        endfor
                                    endif
                                endif
                                if !empty(wipe_unlisted_buffers)
                                    if !empty(wipe_unlisted_buffers)
                                        call neomake#compat#uniq(sort(wipe_unlisted_buffers))
                                    endif
                                    call neomake#log#debug(printf('Wiping out %d unlisted/remapped buffers: %s.',
                                                \ len(wipe_unlisted_buffers),
                                                \ string(wipe_unlisted_buffers)))
                                    exe (&report < 2 ? 'silent ' : '').'bwipeout '.join(wipe_unlisted_buffers)
                                endif
                            
                                let buf_prev_makes = getbufvar(a:make_info.options.bufnr, 'neomake_automake_make_ids')
                                if !empty(buf_prev_makes)
                                    call filter(buf_prev_makes, 'v:val != make_id')
                                    call setbufvar(a:make_info.options.bufnr, 'neomake_automake_make_ids', buf_prev_makes)
                                endif
                            
                                unlet s:make_info[make_id]
                            endfunction
                            
    1              0.000002 function! s:handle_locqf_list_for_finished_jobs(make_info) abort
                                let file_mode = a:make_info.options.file_mode
                                let create_list = !get(a:make_info, 'created_locqf_list', 0)
                            
                                let open_val = get(g:, 'neomake_open_list', 0)
                                let height = open_val ? get(g:, 'neomake_list_height', 10) : 0
                                if height
                                    let close_list = create_list || empty(file_mode ? getloclist(0) : getqflist())
                                else
                                    let close_list = 0
                                endif
                            
                                if file_mode
                                    if create_list && !bufexists(a:make_info.options.bufnr)
                                        call neomake#log#info('No buffer found for location list!', a:make_info.options)
                                        let create_list = 0
                                        let close_list = 0
                                    elseif (create_list || close_list)
                                        if index(get(w:, 'neomake_make_ids', []), a:make_info.options.make_id) == -1
                                            call neomake#log#debug(
                                                        \ 'Postponing final location list handling (in another window).',
                                                        \ {'make_id': a:make_info.options.make_id, 'winnr': winnr()})
                                            return s:queue_action(['WinEnter'], ['s:handle_locqf_list_for_finished_jobs',
                                                        \ [a:make_info] + a:000])
                                        endif
                            
                                        " TODO: merge with s:need_to_postpone_output_processing.
                                        if neomake#compat#in_completion()
                                            call neomake#log#debug(
                                                        \ 'Postponing final location list handling during completion.',
                                                        \ a:make_info.options)
                                            return s:queue_action(['CompleteDone'], ['s:handle_locqf_list_for_finished_jobs',
                                                        \ [a:make_info] + a:000])
                                        endif
                                        let mode = neomake#compat#get_mode()
                                        if index(['n', 'i'], mode) == -1
                                            call neomake#log#debug(printf(
                                                        \ 'Postponing final location list handling for mode "%s".', mode),
                                                        \ a:make_info.options)
                                            return s:queue_action(['Timer'], ['s:handle_locqf_list_for_finished_jobs',
                                                        \ [a:make_info] + a:000])
                                        endif
                                    endif
                                endif
                            
                                " Close empty list.
                                if close_list
                                    if file_mode
                                        call neomake#log#debug('Handling location list: executing lclose.', {'winnr': winnr()})
                                        lclose
                                    else
                                        call neomake#log#debug('Handling quickfix list: executing cclose.')
                                        cclose
                                    endif
                                endif
                            
                                if create_list
                                    if file_mode
                                        call neomake#log#debug('Cleaning location list.', {'make_id': a:make_info.options.make_id})
                                        call setloclist(0, [])
                                    else
                                        call neomake#log#debug('Cleaning quickfix list.', {'make_id': a:make_info.options.make_id})
                                        call setqflist([])
                                    endif
                                endif
                            
                                let hook_context = {
                                            \ 'make_id': a:make_info.options.make_id,
                                            \ 'options': a:make_info.options,
                                            \ 'finished_jobs': a:make_info.finished_jobs,
                                            \ }
                                call neomake#utils#hook('NeomakeFinished', hook_context)
                                call s:do_clean_make_info(a:make_info)
                                return 1
                            endfunction
                            
    1              0.000002 function! neomake#VimLeave() abort
                                call neomake#log#debug('Calling VimLeave.')
                                for make_id in keys(s:make_info)
                                    call neomake#CancelMake(make_id)
                                endfor
                            endfunction
                            
                            " Create a location/quickfix list once per make run.
                            " Returns the current list (empty if it was created).
    1              0.000001 function! s:create_locqf_list(jobinfo) abort
                                let make_info = s:make_info[a:jobinfo.make_id]
                                if get(make_info, 'created_locqf_list', 0)
                                    return a:jobinfo.file_mode ? getloclist(0) : getqflist()
                                endif
                                let make_info.created_locqf_list = 1
                            
                                let file_mode = make_info.options.file_mode
                                if file_mode
                                    call neomake#log#debug('Creating location list.', a:jobinfo)
                                    call setloclist(0, [])
                                else
                                    call neomake#log#debug('Creating quickfix list.', a:jobinfo)
                                    call setqflist([])
                                endif
                                return []
                            endfunction
                            
    1              0.000001 function! s:clean_for_new_make(make_info) abort
                                if get(a:make_info, 'cleaned_for_make', 0)
                                    return
                                endif
                                let file_mode = a:make_info.options.file_mode
                                " XXX: needs to handle buffers for list entries?!
                                " See "get_list_entries: minimal example (from doc)" in
                                " tests/makers.vader.
                                if file_mode
                                    let bufnr = a:make_info.options.bufnr
                                    if has_key(s:current_errors['file'], bufnr)
                                        unlet s:current_errors['file'][bufnr]
                                    endif
                                    call neomake#highlights#ResetFile(bufnr)
                                    call neomake#log#debug('File-level errors cleaned.',
                                                \ {'make_id': a:make_info.options.make_id, 'bufnr': bufnr})
                                else
                                    " TODO: test
                                    for buf in keys(s:current_errors.project)
                                        unlet s:current_errors['project'][buf]
                                        call neomake#highlights#ResetProject(+buf)
                                    endfor
                                endif
                                let a:make_info.cleaned_for_make = 1
                            endfunction
                            
                            " Change to a job's cwd, if any.
                            " Returns: a list:
                            "  - error (empty for success)
                            "  - directory changed into (empty if skipped)
                            "  - command to change back to the current workding dir (might be empty)
                            
                            " Call a:fn with a:args and queue it, in case if fails with E48/E523.
    1              0.000001 function! s:pcall(fn, args) abort
                                let jobinfo = a:args[0]
                                try
                                    return call(a:fn, a:args + [1])
                                catch /^\%(Vim\%((\a\+)\)\=:\%(E48\|E523\)\)/  " only E48/E523 (sandbox / not allowed here)
                                    call neomake#log#debug('Error during pcall: '.v:exception.'.', jobinfo)
                                    call neomake#log#debug(printf('(in %s)', v:throwpoint), jobinfo)
                                    " Might throw in case of X failed attempts.
                                    call s:queue_action(['Timer', 'WinEnter'], [a:fn, a:args])
                                endtry
                                return 0
                            endfunction
                            
                            " Do we need to replace (instead of append) the location/quickfix list, for
                            " :lwindow to not open it with only invalid entries?!
                            " Without patch-7.4.379 this does not work though, and a new list needs to
                            " be created (which is not done).
                            " @vimlint(EVL108, 1)
    1              0.000013 let s:needs_to_replace_qf_for_lwindow = has('patch-7.4.379')
                                        \ && (!has('patch-7.4.1752') || (has('nvim') && !has('nvim-0.2.0')))
                            " @vimlint(EVL108, 0)
                            
    1              0.000002 function! s:ProcessEntries(jobinfo, entries, ...) abort
                                if s:need_to_postpone_loclist(a:jobinfo)
                                    return s:queue_action(['BufEnter', 'WinEnter'], ['s:ProcessEntries',
                                                \ [a:jobinfo, a:entries] + a:000])
                                endif
                                if !a:0 || type(a:[len(a:000)]) != 0
                                    return s:pcall('s:ProcessEntries', [a:jobinfo, a:entries] + a:000)
                                endif
                                let file_mode = a:jobinfo.file_mode
                            
                                call neomake#log#debug(printf(
                                            \ 'Processing %d entries.', len(a:entries)), a:jobinfo)
                            
                                if a:0 > 1
                                    " Via errorformat processing, where the list has been set already.
                                    let prev_list = a:1
                                    let new_list = file_mode ? getloclist(0) : getqflist()
                                else
                                    " Fix entries with get_list_entries/process_output/process_json.
                                    let maker_name = a:jobinfo.maker.name
                                    call map(a:entries, 'extend(v:val, {'
                                                \ . "'bufnr': str2nr(get(v:val, 'bufnr', 0)),"
                                                \ . "'lnum': str2nr(v:val.lnum),"
                                                \ . "'col': str2nr(get(v:val, 'col', 0)),"
                                                \ . "'vcol': str2nr(get(v:val, 'vcol', 0)),"
                                                \ . "'type': get(v:val, 'type', 'E'),"
                                                \ . "'nr': get(v:val, 'nr', -1),"
                                                \ . "'maker_name': maker_name,"
                                                \ . '})')
                            
                                    let cd_error = a:jobinfo.cd()
                                    if !empty(cd_error)
                                        call neomake#log#debug(printf(
                                                    \ "Could not change to job's cwd (%s): %s.",
                                                    \ a:jobinfo.cd_from_setting, cd_error), a:jobinfo)
                                    endif
                            
                                    let prev_list = s:create_locqf_list(a:jobinfo)
                            
                                    try
                                        let list_entries = a:entries
                                        " Add marker for custom quickfix to the first (new) entry.
                                        if neomake#quickfix#is_enabled() && !empty(a:entries)
                                            let config = {
                                                        \ 'name': maker_name,
                                                        \ 'short': get(a:jobinfo.maker, 'short_name', maker_name[:3]),
                                                        \ }
                                            let marker_entry = copy(a:entries[0])
                                            let marker_entry.text .= printf(' nmcfg:%s', string(config))
                                            let list_entries = [marker_entry] + a:entries[1:]
                                        endif
                            
                                        if file_mode
                                            if s:needs_to_replace_qf_for_lwindow
                                                call setloclist(0, prev_list + list_entries, 'r')
                                            else
                                                call setloclist(0, list_entries, 'a')
                                            endif
                                        else
                                            if s:needs_to_replace_qf_for_lwindow
                                                call setqflist(prev_list + list_entries, 'r')
                                            else
                                                call setqflist(list_entries, 'a')
                                            endif
                                        endif
                                    finally
                                        call a:jobinfo.cd_back()
                                    endtry
                                    let new_list = file_mode ? getloclist(0) : getqflist()
                                    let parsed_entries = new_list[len(prev_list):]
                                    let idx = 0
                                    for e in parsed_entries
                                        if a:entries[idx].bufnr != e.bufnr
                                            call neomake#log#debug(printf(
                                                        \ 'Updating entry bufnr: %s => %s.',
                                                        \ a:entries[idx].bufnr, e.bufnr))
                                            let a:entries[idx].bufnr = e.bufnr
                                        endif
                                        let idx += 1
                                    endfor
                                endif
                                call s:clean_for_new_make(s:make_info[a:jobinfo.make_id])
                            
                                let counts_changed = 0
                                let maker_type = file_mode ? 'file' : 'project'
                                let do_highlight = get(g:, 'neomake_highlight_columns', 1)
                                            \ || get(g:, 'neomake_highlight_lines', 0)
                                let signs_by_bufnr = {}
                                let debug = neomake#utils#get_verbosity(a:jobinfo) >= 3 || !empty(get(g:, 'neomake_logfile'))
                                let entries_with_lnum_by_bufnr = {}
                                let skipped_without_bufnr = []
                                let skipped_without_lnum = []
                            
                                let idx = -1
                                for entry in a:entries
                                    let idx += 1
                                    if !file_mode
                                        if neomake#statusline#AddQflistCount(entry)
                                            let counts_changed = 1
                                        endif
                                    endif
                            
                                    if !entry.bufnr
                                        if debug
                                            let skipped_without_bufnr += [idx]
                                        endif
                                        continue
                                    endif
                            
                                    if file_mode
                                        if neomake#statusline#AddLoclistCount(entry.bufnr, entry)
                                            let counts_changed = 1
                                        endif
                                    endif
                            
                                    if !entry.lnum
                                        if debug
                                            let skipped_without_lnum += [idx]
                                        endif
                                        continue
                                    endif
                            
                                    if !has_key(entries_with_lnum_by_bufnr, entry.bufnr)
                                        let entries_with_lnum_by_bufnr[entry.bufnr] = []
                                        let signs_by_bufnr[entry.bufnr] = []
                                        if !exists('s:current_errors[maker_type][entry.bufnr]')
                                            let s:current_errors[maker_type][entry.bufnr] = {}
                                        endif
                                    endif
                            
                                    if do_highlight || g:neomake_place_signs
                                        " NOTE: only lnum/type required for signs.  Similar for do_highlight?!
                                        call add(entries_with_lnum_by_bufnr[entry.bufnr], entry)
                                    endif
                            
                                    " Track all errors by buffer and line
                                    if !has_key(s:current_errors[maker_type][entry.bufnr], entry.lnum)
                                        let s:current_errors[maker_type][entry.bufnr][entry.lnum] = [entry]
                                    else
                                        call add(s:current_errors[maker_type][entry.bufnr][entry.lnum], entry)
                                    endif
                                endfor
                            
                                " Handle placing signs and highlights.
                                for [b, entries] in items(entries_with_lnum_by_bufnr)
                                    if g:neomake_place_signs
                                        call neomake#signs#PlaceSigns(b, entries, maker_type)
                                    endif
                                    if do_highlight
                                        for entry in entries
                                            call neomake#highlights#AddHighlight(entry, maker_type)
                                        endfor
                                    endif
                                endfor
                            
                                if !empty(skipped_without_bufnr)
                                    call neomake#log#debug(printf('Skipped %d entries without bufnr: %s.',
                                                \ len(skipped_without_bufnr),
                                                \ string(map(skipped_without_bufnr, 'a:entries[v:val]'))), a:jobinfo)
                                endif
                            
                                if !empty(skipped_without_lnum)
                                    call neomake#log#debug(printf(
                                                \ 'Could not place signs for %d entries without line number: %s.',
                                                \ len(skipped_without_lnum),
                                                \ string(map(skipped_without_lnum, 'a:entries[v:val]'))), a:jobinfo)
                                endif
                            
                                if !counts_changed
                                    let counts_changed = new_list != prev_list
                                endif
                                if counts_changed
                                    call neomake#utils#hook('NeomakeCountsChanged', {'reset': 0, 'jobinfo': a:jobinfo})
                                endif
                            
                                if !empty(new_list)
                                    call s:HandleLoclistQflistDisplay(a:jobinfo, new_list)
                                endif
                                call neomake#highlights#ShowHighlights()
                                return 1
                            endfunction
                            
    1              0.000002 function! s:ProcessJobOutput(jobinfo, lines, source, ...) abort
                                if s:need_to_postpone_loclist(a:jobinfo)
                                    return s:queue_action(['BufEnter', 'WinEnter'], ['s:ProcessJobOutput',
                                                \ [a:jobinfo, a:lines, a:source]])
                                endif
                                if !a:0
                                    return s:pcall('s:ProcessJobOutput', [a:jobinfo, a:lines, a:source])
                                endif
                            
                                let maker = a:jobinfo.maker
                                let file_mode = a:jobinfo.file_mode
                                call neomake#log#debug(printf(
                                            \ '%s: processing %d lines of output.',
                                            \ maker.name, len(a:lines)), a:jobinfo)
                                try
                                    if has_key(maker, 'process_json') || has_key(maker, 'process_output')
                                        if has_key(maker, 'process_json')
                                            let method = 'process_json'
                                            let output = join(a:lines, "\n")
                                            try
                                                let json = neomake#compat#json_decode(output)
                                            catch
                                                let error = printf(
                                                            \ 'Failed to decode JSON: %s (output: %s).',
                                                            \ substitute(v:exception, '^Neomake: ', '', ''), string(output))
                                                call neomake#log#exception(error, a:jobinfo)
                                                return
                                            endtry
                                            call neomake#log#debug(printf(
                                                        \ "Calling maker's process_json method with %d JSON entries.",
                                                        \ len(json)), a:jobinfo)
                                            let entries = call(maker.process_json, [{
                                                        \ 'json': json,
                                                        \ 'source': a:source,
                                                        \ 'jobinfo': a:jobinfo}], maker)
                                        else
                                            call neomake#log#debug(printf(
                                                        \ "Calling maker's process_output method with %d lines of output on %s.",
                                                        \ len(a:lines), a:source), a:jobinfo)
                                            let method = 'process_output'
                                            let entries = call(maker.process_output, [{
                                                        \ 'output': a:lines,
                                                        \ 'source': a:source,
                                                        \ 'jobinfo': a:jobinfo}], maker)
                                        endif
                                        if type(entries) != type([])
                                            call neomake#log#error(printf('The %s method for maker %s did not return a list, but: %s.',
                                                        \ method, maker.name, string(entries)[:100]), a:jobinfo)
                                            return 0
                                        elseif !empty(entries) && type(entries[0]) != type({})
                                            call neomake#log#error(printf('The %s method for maker %s did not return a list of dicts, but: %s.',
                                                        \ method, maker.name, string(entries)[:100]), a:jobinfo)
                                            return 0
                                        endif
                                        return s:ProcessEntries(a:jobinfo, entries)
                                    endif
                            
                                    " Old-school handling through errorformat.
                                    if has_key(maker, 'mapexpr')
                                        let l:neomake_bufname = bufname(a:jobinfo.bufnr)
                                        " @vimlint(EVL102, 1, l:neomake_bufdir)
                                        let l:neomake_bufdir = fnamemodify(neomake_bufname, ':h')
                                        " @vimlint(EVL102, 1, l:neomake_output_source)
                                        let l:neomake_output_source = a:source
                                        call map(a:lines, maker.mapexpr)
                                    endif
                            
                                    let cd_error = a:jobinfo.cd()
                                    if !empty(cd_error)
                                        call neomake#log#debug(printf(
                                                    \ "Could not change to job's cwd (%s): %s.",
                                                    \ a:jobinfo.cd_from_setting, cd_error), a:jobinfo)
                                    endif
                            
                                    let prev_list = s:create_locqf_list(a:jobinfo)
                            
                                    if exists('g:loaded_qf')
                                        let vimqf_var = file_mode ? 'qf_auto_open_loclist' : 'qf_auto_open_quickfix'
                                        let vimqf_val = get(g:, vimqf_var, s:unset_dict)
                                        if vimqf_val isnot# 0
                                            let restore_vimqf = [vimqf_var, vimqf_val]
                                            let g:[vimqf_var] = 0
                                        endif
                                    endif
                                    let olderrformat = &errorformat
                                    let &errorformat = maker.errorformat
                                    try
                                        if file_mode
                                            laddexpr a:lines
                                        else
                                            caddexpr a:lines
                                        endif
                                    finally
                                        let &errorformat = olderrformat
                                        call a:jobinfo.cd_back()
                                        if exists('restore_vimqf')
                                            if restore_vimqf[1] is# s:unset_dict
                                                unlet g:[restore_vimqf[0]]
                                            else
                                                let g:[restore_vimqf[0]] = restore_vimqf[1]
                                            endif
                                        endif
                                    endtry
                            
                                    call s:AddExprCallback(a:jobinfo, prev_list)
                                catch /^\%(Vim\%((\a\+)\)\=:\%(E48\|E523\)\)\@!/  " everything, but E48/E523 (sandbox / not allowed here)
                                    if v:exception ==# 'NeomakeTestsException'
                                        throw v:exception
                                    endif
                                    call neomake#log#exception(printf(
                                                \ 'Error during output processing for %s: %s.',
                                                \ a:jobinfo.maker.name, v:exception), a:jobinfo)
                                    return
                                endtry
                                return 1
                            endfunction
                            
    1              0.000002 function! s:process_pending_output(jobinfo, lines, source, ...) abort
                                let retry_events = s:need_to_postpone_output_processing(a:jobinfo)
                                if empty(retry_events)
                                    if s:ProcessPendingOutput(a:jobinfo, a:lines, a:source)
                                        return 1
                                    endif
                                    if a:0
                                        let retry_events = a:1
                                    else
                                        let retry_events = ['BufEnter', 'WinEnter']
                                    endif
                                endif
                                let a:jobinfo.pending_output = 1
                                call s:queue_action(retry_events, ['s:process_pending_output', [a:jobinfo, a:lines, a:source, retry_events]])
                            endfunction
                            
    1              0.000002 function! s:ProcessPendingOutput(jobinfo, lines, source) abort
                                if a:jobinfo.file_mode
                                    let window_make_ids = get(w:, 'neomake_make_ids', [])
                                    if index(window_make_ids, a:jobinfo.make_id) == -1
                                        if !bufexists(a:jobinfo.bufnr)
                                            call neomake#log#info('No buffer found for output!', a:jobinfo)
                                            return 1
                                        endif
                            
                                        if a:jobinfo.bufnr != bufnr('%')
                                            call neomake#log#debug('Skipped pending job output for another buffer.', a:jobinfo)
                                            return 0
                                        elseif s:GetTabWinForMakeId(a:jobinfo.make_id) != [-1, -1]
                                            call neomake#log#debug('Skipped pending job output (not in origin window).', a:jobinfo)
                                            return 0
                                        else
                                            call neomake#log#debug("Processing pending output for job's buffer in new window.", a:jobinfo)
                                            let w:neomake_make_ids = add(get(w:, 'neomake_make_ids', []), a:jobinfo.make_id)
                                        endif
                                    endif
                                endif
                            
                                call s:ProcessJobOutput(a:jobinfo, a:lines, a:source)
                                if get(a:jobinfo, 'pending_output', 0)
                                    call neomake#log#debug('Processed pending output.', a:jobinfo)
                                    let a:jobinfo.pending_output = 0
                                    call s:CleanJobinfo(a:jobinfo)
                                endif
                                return 1
                            endfunction
                            
    1              0.000002 function! s:add_pending_output(jobinfo, source, lines) abort
                                if !exists('s:pending_outputs[a:jobinfo.id]')
                                    let s:pending_outputs[a:jobinfo.id] = {}
                                endif
                                if !exists('s:pending_outputs[a:jobinfo.id][a:source]')
                                    let s:pending_outputs[a:jobinfo.id][a:source] = []
                                endif
                                call extend(s:pending_outputs[a:jobinfo.id][a:source], a:lines)
                            endfunction
                            
                            " Get tabnr and winnr for a given make ID.
    1              0.000001 function! s:GetTabWinForMakeId(make_id) abort
                                for t in [tabpagenr()] + range(1, tabpagenr()-1) + range(tabpagenr()+1, tabpagenr('$'))
                                    for w in range(1, tabpagewinnr(t, '$'))
                                        if index(neomake#compat#gettabwinvar(t, w, 'neomake_make_ids', []), a:make_id) != -1
                                            return [t, w]
                                        endif
                                    endfor
                                endfor
                                return [-1, -1]
                            endfunction
                            
                            " Do we need to postpone location list processing (creation and :laddexpr)?
    1              0.000001 function! s:need_to_postpone_loclist(jobinfo) abort
                                if !a:jobinfo.file_mode
                                    return 0
                                endif
                                if index(get(w:, 'neomake_make_ids', []), a:jobinfo.make_id) != -1
                                    return 0
                                endif
                                call neomake#log#debug('Postponing location list processing.', a:jobinfo)
                                return 1
                            endfunction
                            
                            " XXX: merge with s:handle_locqf_list_for_finished_jobs.
    1              0.000004 let s:has_getcmdwintype = exists('*getcmdwintype')
    1              0.000002 function! s:need_to_postpone_output_processing(jobinfo) abort
                                " We can only process output (change the location/quickfix list) in
                                " certain modes, otherwise e.g. the visual selection gets lost.
                                if neomake#compat#in_completion()
                                    call neomake#log#debug('Not processing output during completion.', a:jobinfo)
                                    return ['CompleteDone']
                                endif
                                let mode = neomake#compat#get_mode()
                                if index(['n', 'i'], mode) == -1
                                    call neomake#log#debug('Not processing output for mode "'.mode.'".', a:jobinfo)
                                    return ['BufEnter', 'WinEnter', 'InsertLeave', 'CursorHold', 'CursorHoldI']
                                endif
                                if s:has_getcmdwintype && !empty(getcmdwintype())
                                    call neomake#log#debug('Not processing output from command-line window "'.getcmdwintype().'".', a:jobinfo)
                                    return ['InsertLeave', 'CursorHold', 'CursorHoldI']
                                endif
                                " TODO: should be done in neomake#utils#hook directly instead, involves refactoring.
                                if exists('g:neomake_hook_context')
                                    call neomake#log#debug('Not processing output during active hook processing.', a:jobinfo)
                                    return ['Timer', 'BufEnter', 'WinEnter', 'InsertLeave', 'CursorHold', 'CursorHoldI']
                                endif
                                return []
                            endfunction
                            
    1              0.000002 function! s:RegisterJobOutput(jobinfo, lines, source) abort
                                " Allow to filter output (storing the setting on the jobinfo lazily).
                                if !has_key(a:jobinfo, 'filter_output')
                                    let a:jobinfo.filter_output = neomake#utils#GetSetting('filter_output', a:jobinfo.maker, '', a:jobinfo.ft, a:jobinfo.bufnr)
                                endif
                                if !empty(a:jobinfo.filter_output)
                                    call call(a:jobinfo.filter_output, [
                                                \ a:lines, {'source': a:source, 'jobinfo': a:jobinfo}],
                                                \ a:jobinfo.maker)
                                endif
                            
                                if empty(a:lines)
                                    return
                                endif
                            
                                if a:jobinfo.output_stream !=# 'both' && a:jobinfo.output_stream !=# a:source
                                    if !has_key(a:jobinfo, 'unexpected_output')
                                        let a:jobinfo.unexpected_output = {}
                                    endif
                                    if !has_key(a:jobinfo.unexpected_output, a:source)
                                        let a:jobinfo.unexpected_output[a:source] = []
                                    endif
                                    let a:jobinfo.unexpected_output[a:source] += a:lines
                                    return
                                endif
                            
                                call s:process_pending_output(a:jobinfo, a:lines, a:source)
                            endfunction
                            
    1              0.000002 function! s:vim_output_handler(channel, output, event_type) abort
                                let channel_id = ch_info(a:channel)['id']
                                let jobinfo = get(s:jobs, get(s:map_job_ids, channel_id, -1), {})
                                if empty(jobinfo)
                                    call neomake#log#debug(printf("output [%s]: job '%s' not found.", a:event_type, a:channel))
                                    return
                                endif
                                let data = split(a:output, '\r\?\n', 1)
                                call s:output_handler_queued(jobinfo, data, a:event_type, 0)
                            endfunction
                            
    1              0.000002 function! s:vim_output_handler_stdout(channel, output) abort
                                call s:vim_output_handler(a:channel, a:output, 'stdout')
                            endfunction
                            
    1              0.000002 function! s:vim_output_handler_stderr(channel, output) abort
                                call s:vim_output_handler(a:channel, a:output, 'stderr')
                            endfunction
                            
    1              0.000001 function! s:vim_exit_handler(channel) abort
                                let channel_id = ch_info(a:channel)['id']
                                let jobinfo = get(s:jobs, get(s:map_job_ids, channel_id, -1), {})
                                if empty(jobinfo)
                                    try
                                        let job_info = job_info(ch_getjob(a:channel))
                                    catch /^Vim(let):E916:/
                                        " Might happen with older Vim (8.0.69, but not 8.0.586).
                                        call neomake#log#debug(printf('exit: job not found: %s.', a:channel))
                                        return
                                    endtry
                                    call neomake#log#debug(printf('exit: job not found: %s (%s).', a:channel, job_info))
                                    return
                                endif
                                let job_info = job_info(ch_getjob(a:channel))
                            
                                " Handle failing starts from Vim here.
                                let status = job_info['exitval']
                                if status == 122  " Vim uses EXEC_FAILED, but only on Unix?!
                                    let jobinfo.failed_to_start = 1
                                    " The error is on stderr.
                                    let error = 'Vim job failed to run: '.substitute(join(jobinfo.stderr), '\v\s+$', '', '').'.'
                                    let jobinfo.stderr = []
                                    call neomake#log#error(error)
                                    call s:CleanJobinfo(jobinfo)
                                else
                                    call s:exit_handler(jobinfo, status)
                                endif
                            endfunction
                            
                            " @vimlint(EVL108, 1)
    1              0.000003 if has('nvim-0.2.0')
                            " @vimlint(EVL108, 0)
    1              0.000002     function! s:nvim_output_handler(job_id, data, event_type) abort
                                    let jobinfo = get(s:jobs, get(s:map_job_ids, a:job_id, -1), {})
                                    if empty(jobinfo)
                                        call neomake#log#debug(printf('output [%s]: job %d not found.', a:event_type, a:job_id))
                                        return
                                    endif
                                    if a:data == [''] && !exists('jobinfo[a:event_type]')
                                        " EOF in Neovim (see :h on_data).
                                        return
                                    endif
                                    call s:output_handler_queued(jobinfo, copy(a:data), a:event_type, 1)
                                endfunction
    1              0.000001 else
                                " Neovim: register output from jobs as quick as possible, and trigger
                                " processing through a timer.
                                " This works around https://github.com/neovim/neovim/issues/5889).
                                let s:nvim_output_handler_queue = []
                                function! s:nvim_output_handler(job_id, data, event_type) abort
                                    let jobinfo = get(s:jobs, get(s:map_job_ids, a:job_id, -1), {})
                                    if empty(jobinfo)
                                        call neomake#log#debug(printf('output [%s]: job %d not found.', a:event_type, a:job_id))
                                        return
                                    endif
                                    let args = [jobinfo, copy(a:data), a:event_type, 1]
                                    call add(s:nvim_output_handler_queue, args)
                                    if !exists('jobinfo._nvim_in_handler')
                                        let jobinfo._nvim_in_handler = 1
                                    else
                                        let jobinfo._nvim_in_handler += 1
                                    endif
                                    if !exists('s:nvim_output_handler_timer')
                                        let s:nvim_output_handler_timer = timer_start(0, function('s:nvim_output_handler_cb'))
                                    endif
                                endfunction
                            
                                function! s:nvim_output_handler_cb(_timer) abort
                                    while !empty(s:nvim_output_handler_queue)
                                        let args = remove(s:nvim_output_handler_queue, 0)
                                        let jobinfo = args[0]
                                        call call('s:output_handler', args)
                                        let jobinfo._nvim_in_handler -= 1
                            
                                        if !jobinfo._nvim_in_handler
                                            " Trigger previously delayed exit handler.
                                            unlet jobinfo._nvim_in_handler
                                            if exists('jobinfo._exited_while_in_handler')
                                                call neomake#log#debug('Trigger delayed exit.', jobinfo)
                                                call s:exit_handler(jobinfo, jobinfo._exited_while_in_handler)
                                            endif
                                        endif
                                    endwhile
                                    unlet! s:nvim_output_handler_timer
                                endfunction
                            endif
                            
                            " Exit handler for buffered output with Neovim.
                            " In this case the output gets stored on the jobstart-options dict.
    1              0.000002 function! s:nvim_exit_handler_buffered(job_id, data, _event_type) abort
                                let jobinfo = get(s:jobs, get(s:map_job_ids, a:job_id, -1), {})
                                if empty(jobinfo)
                                    call neomake#log#debug(printf('exit: job not found: %d.', a:job_id))
                                    return
                                endif
                            
                                for stream in ['stdout', 'stderr']
                                    if has_key(jobinfo.jobstart_opts, stream)
                                        let data = copy(jobinfo.jobstart_opts[stream])
                                        call s:output_handler(jobinfo, data, stream, 1)
                                    endif
                                endfor
                            
                                call s:exit_handler(jobinfo, a:data)
                            endfunction
                            
    1              0.000002 function! s:nvim_exit_handler(job_id, data, _event_type) abort
                                let jobinfo = get(s:jobs, get(s:map_job_ids, a:job_id, -1), {})
                                if empty(jobinfo)
                                    call neomake#log#debug(printf('exit: job not found: %d.', a:job_id))
                                    return
                                endif
                                call s:exit_handler(jobinfo, a:data)
                            endfunction
                            
    1              0.000001 function! s:exit_handler(jobinfo, data) abort
                                let jobinfo = a:jobinfo
                                let jobinfo.exit_code = a:data
                                if get(jobinfo, 'canceled')
                                    call neomake#log#debug('exit: job was canceled.', jobinfo)
                                    call s:CleanJobinfo(jobinfo)
                                    return
                                endif
                                let maker = jobinfo.maker
                            
                                if exists('jobinfo._output_while_in_handler') || exists('jobinfo._nvim_in_handler')
                                    let jobinfo._exited_while_in_handler = a:data
                                    call neomake#log#debug(printf('exit (delayed): %s: %s.',
                                                \ maker.name, string(a:data)), jobinfo)
                                    return
                                endif
                                call neomake#log#debug(printf('exit: %s: %s.',
                                            \ maker.name, string(a:data)), jobinfo)
                            
                                " Handle any unfinished lines from stdout/stderr callbacks.
                                for event_type in ['stdout', 'stderr']
                                    if has_key(jobinfo, event_type)
                                        let lines = jobinfo[event_type]
                                        if !empty(lines)
                                            if lines[-1] ==# ''
                                                call remove(lines, -1)
                                            endif
                                            if !empty(lines)
                                                call s:RegisterJobOutput(jobinfo, lines, event_type)
                                            endif
                                            unlet jobinfo[event_type]
                                        endif
                                    endif
                                endfor
                            
                                if !get(jobinfo, 'failed_to_start')
                                    let l:ExitCallback = neomake#utils#GetSetting('exit_callback',
                                                \ extend(copy(jobinfo), maker), 0, jobinfo.ft, jobinfo.bufnr)
                                    if l:ExitCallback isnot# 0
                                        let callback_dict = { 'status': jobinfo.exit_code,
                                                            \ 'name': maker.name,
                                                            \ 'has_next': !empty(s:make_info[jobinfo.make_id].jobs_queue) }
                                        try
                                            if type(l:ExitCallback) == type('')
                                                let l:ExitCallback = function(l:ExitCallback)
                                            endif
                                            call call(l:ExitCallback, [callback_dict], jobinfo)
                                        catch
                                            call neomake#log#error(printf(
                                                        \ 'Error during exit_callback: %s.', v:exception),
                                                        \ jobinfo)
                                        endtry
                                    endif
                                endif
                            
                                if s:async
                                    if has('nvim') || jobinfo.exit_code != 122
                                        call neomake#log#debug(printf(
                                                    \ '%s: completed with exit code %d.',
                                                    \ maker.name, jobinfo.exit_code), jobinfo)
                                    endif
                                    let jobinfo.finished = 1
                                endif
                            
                                if has_key(jobinfo, 'unexpected_output')
                                    redraw
                                    for [source, output] in items(jobinfo.unexpected_output)
                                        let msg = printf('%s: unexpected output on %s: ', maker.name, source)
                                        call neomake#log#debug(msg . join(output, '\n') . '.', jobinfo)
                            
                                        echohl WarningMsg
                                        echom printf('Neomake: %s%s', msg, output[0])
                                        for line in output[1:-1]
                                            echom line
                                        endfor
                                        echohl None
                                    endfor
                                    call neomake#log#error(printf(
                                                \ '%s: unexpected output. See :messages for more information.', maker.name), jobinfo)
                                endif
                                call s:handle_next_job(jobinfo)
                            endfunction
                            
    1              0.000002 function! s:output_handler_queued(jobinfo, data, event_type, trim_CR) abort
                                let jobinfo = a:jobinfo
                                if exists('jobinfo._output_while_in_handler')
                                    call neomake#log#debug(printf('Queueing: %s: %s: %s.',
                                                \ a:event_type, jobinfo.maker.name, string(a:data)), jobinfo)
                                    let jobinfo._output_while_in_handler += [[jobinfo, a:data, a:event_type, a:trim_CR]]
                                    return
                                else
                                    let jobinfo._output_while_in_handler = []
                                endif
                            
                                call s:output_handler(jobinfo, a:data, a:event_type, a:trim_CR)
                            
                                " Process queued events that might have arrived by now.
                                " The attribute might be unset here, since output_handler might have
                                " been interrupted.
                                if exists('jobinfo._output_while_in_handler')
                                    while has_key(jobinfo, '_output_while_in_handler') && !empty(jobinfo._output_while_in_handler)
                                        let args = remove(jobinfo._output_while_in_handler, 0)
                                        call call('s:output_handler', args)
                                    endwhile
                                    unlet! jobinfo._output_while_in_handler
                                endif
                                " Trigger previously delayed exit handler.
                                if exists('jobinfo._exited_while_in_handler')
                                    call neomake#log#debug('Trigger delayed exit.', jobinfo)
                                    call s:exit_handler(jobinfo, jobinfo._exited_while_in_handler)
                                endif
                            endfunction
                            
    1              0.000002 function! s:output_handler(jobinfo, data, event_type, trim_CR) abort
                                let jobinfo = a:jobinfo
                                call neomake#log#debug(printf('%s: %s: %s.',
                                            \ a:event_type, jobinfo.maker.name, string(a:data)), jobinfo)
                                let data = copy(a:data)
                                if a:trim_CR && !empty(a:data)
                                    call map(data, "substitute(v:val, '\\r$', '', '')")
                                endif
                                if get(jobinfo, 'canceled')
                                    call neomake#log#debug('Ignoring output (job was canceled).', jobinfo)
                                    return
                                endif
                                let last_event_type = get(jobinfo, 'event_type', a:event_type)
                            
                                " data is a list of 'lines' read. Each element *after* the first
                                " element represents a newline.
                                if has_key(jobinfo, a:event_type)
                                    let jobinfo[a:event_type][-1] .= data[0]
                                    call extend(jobinfo[a:event_type], data[1:])
                                else
                                    let jobinfo[a:event_type] = data
                                endif
                            
                                if !jobinfo.buffer_output || last_event_type !=# a:event_type
                                    let lines = jobinfo[a:event_type][:-2]
                                    let jobinfo[a:event_type] = jobinfo[a:event_type][-1:]
                            
                                    if !empty(lines)
                                        call s:RegisterJobOutput(jobinfo, lines, a:event_type)
                                    endif
                                endif
                            endfunction
                            
    1              0.000001 function! s:abort_next_makers(make_id) abort
                                let jobs_queue = s:make_info[a:make_id].jobs_queue
                                if !empty(jobs_queue)
                                    let next_makers = join(map(copy(jobs_queue), 'v:val.maker.name'), ', ')
                                    call neomake#log#info('Aborting next makers: '.next_makers.'.', {'make_id': a:make_id})
                                    let s:make_info[a:make_id].jobs_queue = []
                                endif
                            endfunction
                            
    1              0.000001 function! s:handle_next_job(prev_jobinfo) abort
                                let make_id = get(a:prev_jobinfo, 'make_id', s:make_id)
                                if !has_key(s:make_info, make_id)
                                    return {}
                                endif
                                let make_info = s:make_info[make_id]
                            
                                if !empty(a:prev_jobinfo)
                                    let status = get(a:prev_jobinfo, 'exit_code', 0)
                                    if status != 0 && index([122, 127], status) == -1
                                        " TODO: mark maker.exe as non-executable with status 127, and
                                        "       maybe re-introduce a wrapper for `executable()` to handle it.
                                        "       Ref: https://github.com/neomake/neomake/issues/1699
                                        if neomake#utils#GetSetting('serialize_abort_on_error', a:prev_jobinfo.maker, 0, a:prev_jobinfo.ft, a:prev_jobinfo.bufnr)
                                            call s:abort_next_makers(make_id)
                                            call s:CleanJobinfo(a:prev_jobinfo)
                                            return {}
                                        endif
                                    endif
                                    call s:CleanJobinfo(a:prev_jobinfo)
                                    if !has_key(s:make_info, make_id)
                                        " Last job was cleaned.
                                        return {}
                                    endif
                                endif
                            
                                " Create job from the start of the queue, returning it.
                                while !empty(make_info.jobs_queue)
                                    let options = remove(make_info.jobs_queue, 0)
                                    let maker = options.maker
                                    if empty(maker)
                                        continue
                                    endif
                            
                                    " Serialization of jobs, always for non-async Vim.
                                    if !has_key(options, 'serialize')
                                        if !s:async || neomake#utils#GetSetting('serialize', maker, 0, options.ft, options.bufnr)
                                            let options.serialize = 1
                                        else
                                            let options.serialize = 0
                                        endif
                                    endif
                                    try
                                        let jobinfo = s:MakeJob(make_id, options)
                                    catch /^Neomake: /
                                        let log_context = {'make_id': make_id}
                                        let error = substitute(v:exception, '^Neomake: ', '', '')
                                        call neomake#log#exception(error, log_context)
                            
                                        if options.serialize
                                            if neomake#utils#GetSetting('serialize_abort_on_error', maker, 0, options.ft, options.bufnr)
                                                call s:abort_next_makers(make_id)
                                                break
                                            endif
                                        endif
                                        continue
                                    endtry
                                    if !empty(jobinfo)
                                        return jobinfo
                                    endif
                                endwhile
                            
                                " Cleanup make info, but only if there are no queued actions.
                                for [_, v] in s:action_queue
                                    if v[1][0] == make_info
                                        call neomake#log#debug('Skipping cleaning of make info for queued actions.', make_info)
                                        return {}
                                    endif
                                endfor
                                call s:clean_make_info(make_info)
                                return {}
                            endfunction
                            
    1              0.000002 function! neomake#get_nearest_error() abort
                                let buf = bufnr('%')
                                let ln = line('.')
                                let ln_errors = []
                            
                                for maker_type in ['file', 'project']
                                    let buf_errors = get(s:current_errors[maker_type], buf, {})
                                    let ln_errors += get(buf_errors, ln, [])
                                endfor
                            
                                if empty(ln_errors)
                                    return {}
                                endif
                            
                                if len(ln_errors) > 1
                                    let ln_errors = copy(ln_errors)
                                    call sort(ln_errors, function('neomake#utils#sort_by_col'))
                                endif
                                return ln_errors[0]
                            endfunction
                            
    1              0.000002 function! neomake#GetCurrentErrorMsg() abort
                                let entry = neomake#get_nearest_error()
                                if empty(entry)
                                    return ''
                                endif
                                let r = entry.maker_name . ': ' . entry.text
                                let suffix = entry.type . (entry.nr != -1 ? entry.nr : '')
                                if !empty(suffix)
                                    let r .= ' ('.suffix.')'
                                endif
                                return r
                            endfunction
                            
    1              0.000001 function! neomake#EchoCurrentError(...) abort
                                if !get(g:, 'neomake_echo_current_error', 1)
                                    return
                                endif
                                " a:1 might be a timer from the VimResized event.
                                let force = a:0 ? a:1 : 0
                            
                                let message = neomake#GetCurrentErrorMsg()
                                if empty(message)
                                    if exists('s:neomake_last_echoed_error')
                                        echon ''
                                        unlet s:neomake_last_echoed_error
                                    endif
                                    return
                                endif
                                if !force && exists('s:neomake_last_echoed_error')
                                            \ && s:neomake_last_echoed_error == message
                                    return
                                endif
                                let s:neomake_last_echoed_error = message
                                call neomake#utils#WideMessage(message)
                            endfunction
                            
    1              0.000001 function! neomake#CursorMoved() abort
                                call neomake#EchoCurrentError()
                            endfunction
                            
    1              0.000001 function! s:cursormoved_delayed_cb(...) abort
                                if getpos('.') == s:cursormoved_last_pos
                                    call neomake#CursorMoved()
                                endif
                            endfunction
    1              0.000001 function! neomake#CursorMovedDelayed() abort
                                if exists('s:cursormoved_timer')
                                    call timer_stop(s:cursormoved_timer)
                                endif
                                let s:cursormoved_timer = timer_start(get(g:, 'neomake_cursormoved_delay', 100), function('s:cursormoved_delayed_cb'))
                                let s:cursormoved_last_pos = getpos('.')
                            endfunction
                            
    1              0.000002 function! neomake#Make(file_mode_or_options, ...) abort
                                if type(a:file_mode_or_options) == type({})
                                    return s:Make(a:file_mode_or_options)
                                endif
                            
                                let file_mode = a:file_mode_or_options
                                let options = {'file_mode': file_mode}
                                if file_mode
                                    let options.ft = &filetype
                                endif
                                if a:0
                                    if !empty(a:1)
                                        let maker_names = a:1
                                        " Split names on non-breaking space (annotation from completion).
                                        call map(maker_names, "type(v:val) == 1 ? split(v:val, ' (')[0] : v:val")
                                        let options.enabled_makers = a:1
                                    endif
                                    if a:0 > 1
                                        let options.exit_callback = a:2
                                    endif
                                endif
                                return map(copy(s:Make(options)), 'v:val.id')
                            endfunction
                            
    1              0.000002 function! neomake#ShCommand(bang, sh_command, ...) abort
                                let maker = neomake#utils#MakerFromCommand(a:sh_command)
                                let maker.name = 'sh: '.a:sh_command
                                let maker.errorformat = '%m'
                                let maker.default_entry_type = ''
                                let options = {
                                            \ 'enabled_makers': [maker],
                                            \ 'file_mode': 0,
                                            \ 'output_stream': 'both',
                                            \ 'buffer_output': !a:bang,
                                            \ }
                                if a:0
                                    call extend(options, a:1)
                                endif
                                let jobinfos = s:Make(options)
                                return empty(jobinfos) ? -1 : jobinfos[0].id
                            endfunction
                            
    1              0.000001 function! neomake#Sh(sh_command, ...) abort
                                " Deprecated, but documented.
                                let options = a:0 ? { 'exit_callback': a:1 } : {}
                                return neomake#ShCommand(0, a:sh_command, options)
                            endfunction
                            
                            " Deprecated (2017-10-11).
    1              0.000001 function! neomake#DisplayInfo(...) abort
                                call call('neomake#debug#display_info', a:000)
                            endfunction
                            
    1              0.000002 function! neomake#map_makers(makers, ft, auto_enabled) abort
                                let makers = []
                                let errors = []
                                let get_args = a:ft is# -1 ? [] : [a:ft]
                                for maker in a:makers
                                    try
                                        let m = call('neomake#GetMaker', [maker] + get_args)
                                    catch /^Neomake: /
                                        call add(errors, substitute(v:exception, '^Neomake: ', '', '').'.')
                                        continue
                                    endtry
                                    call add(makers, m)
                                endfor
                                if !empty(errors)
                                    let log_context = get(get(s:make_info, s:make_id, {}), 'options', {})
                                    for error in errors
                                        if a:auto_enabled
                                            call neomake#log#debug(error, log_context)
                                        else
                                            call neomake#log#error(error, log_context)
                                        endif
                                    endfor
                                endif
                                return makers
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/neomake/autoload/neomake/core.vim
Sourced 1 time
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
    1              0.000007 let g:neomake#core#valid_maker_name_pattern = '\v^\w+$'
                            
    1              0.000003 function! neomake#core#create_jobs(options, makers) abort
                                let args = [a:options, a:makers]
                                let jobs = call('s:bind_makers_for_job', args)
                                return jobs
                            endfunction
                            
    1              0.000003 function! neomake#core#instantiate_maker(maker, options, check_exe) abort
                                let maker = a:maker
                                let options = a:options
                                let ft = get(options, 'ft', '')
                                let bufnr = get(options, 'bufnr', '')
                            
                                " Call InitForJob function in maker object, if any.
                                let Init = neomake#utils#GetSetting('InitForJob', maker, g:neomake#config#undefined, ft, bufnr)
                                if empty(Init)
                                    " Deprecated: should use InitForJob instead.
                                    if has_key(maker, 'fn')
                                        unlet Init  " vim73
                                        let Init = maker.fn
                                        call neomake#log#warn_once(printf("Please use 'InitForJob' instead of 'fn' for maker %s.", maker.name),
                                                    \ printf('deprecated-fn-%s', maker.name))
                                    endif
                                endif
                                if !empty(Init)
                                    " TODO: Allow to throw and/or return 0 to abort/skip?!
                                    let returned_maker = call(Init, [options], maker)
                                    if returned_maker isnot# 0
                                        " This conditional assignment allows to both return a copy
                                        " (factory), while also can be used as a init method.
                                        let maker = returned_maker
                                    endif
                                endif
                            
                                if has_key(maker, '_bind_args')
                                    call maker._bind_args()
                                    if type(maker.exe) != type('')
                                        let error = printf('Non-string given for executable of maker %s: type %s',
                                                    \ maker.name, type(maker.exe))
                                        if !get(maker, 'auto_enabled', 0)
                                            throw 'Neomake: '.error
                                        endif
                                        call neomake#log#debug(error.'.', options)
                                        return {}
                                    endif
                                    if a:check_exe && !executable(maker.exe)
                                        if get(maker, 'auto_enabled', 0)
                                            call neomake#log#debug(printf(
                                                        \ 'Exe (%s) of auto-configured maker %s is not executable, skipping.', maker.exe, maker.name), options)
                                        else
                                            let error = printf('Exe (%s) of maker %s is not executable', maker.exe, maker.name)
                                            throw 'Neomake: '.error
                                        endif
                                        return {}
                                    endif
                                endif
                                return maker
                            endfunction
                            
                            " Map/bind a:makers to a list of job options, using a:options.
    1              0.000002 function! s:bind_makers_for_job(options, makers) abort
                                let r = []
                                for maker in a:makers
                                    let options = copy(a:options)
                                    try
                                        let maker = neomake#core#instantiate_maker(maker, options, 1)
                                    catch /^Neomake: /
                                        let error = substitute(v:exception, '^Neomake: ', '', '').'.'
                                        call neomake#log#error(error, options)
                                        continue
                                    endtry
                                    if !empty(maker)
                                        let options.maker = maker
                                        let r += [options]
                                    endif
                                endfor
                                return r
                            endfunction
                            
                            " Base class for command makers.
    1              0.000005 let g:neomake#core#command_maker_base = {}
                            
    1              0.000002 function! g:neomake#core#command_maker_base._get_fname_for_args(jobinfo) abort dict
                                " Append file?  (defaults to jobinfo.file_mode, project/global makers should set it to 0)
                                let append_file = neomake#utils#GetSetting('append_file', self, a:jobinfo.file_mode, a:jobinfo.ft, a:jobinfo.bufnr)
                                " Use/generate a filename?  (defaults to 1 if tempfile_name is set)
                                let uses_filename = append_file || neomake#utils#GetSetting('uses_filename', self, has_key(self, 'tempfile_name'), a:jobinfo.ft, a:jobinfo.bufnr)
                                if append_file || uses_filename
                                    let filename = self._get_fname_for_buffer(a:jobinfo)
                                    if append_file
                                        return filename
                                    endif
                                endif
                                return ''
                            endfunction
                            
    1              0.000002 function! g:neomake#core#command_maker_base._get_argv(_jobinfo) abort dict
                                return neomake#compat#get_argv(self.exe, self.args, type(self.args) == type([]))
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim
Sourced 1 time
Total time:   0.000197
 Self time:   0.000116

count  total (s)   self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp/utils.vim
                            " Description:   Utilities
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            
                            " Static variables {{{1
    1              0.000004 fu! ctrlp#utils#lash()
                            	retu &ssl || !exists('+ssl') ? '/' : '\'
                            endf
                            
    1              0.000002 fu! s:lash(...)
                            	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
                            endf
                            
    1              0.000002 fu! ctrlp#utils#opts()
                            	let s:lash = ctrlp#utils#lash()
                            	let usrhome = $HOME . s:lash( $HOME )
                            	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
                            	let cadir = isdirectory(usrhome.'.ctrlp_cache')
                            		\ ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
                            	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
                            	let s:cache_dir = cadir
                            endf
    1   0.000092   0.000011 cal ctrlp#utils#opts()
                            
    1              0.000004 let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
                            " Files and Directories {{{1
    1              0.000002 fu! ctrlp#utils#cachedir()
                            	retu s:cache_dir
                            endf
                            
    1              0.000002 fu! ctrlp#utils#cachefile(...)
                            	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
                            	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
                            	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file
                            endf
                            
    1              0.000002 fu! ctrlp#utils#readfile(file)
                            	if filereadable(a:file)
                            		let data = readfile(a:file)
                            		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
                            		retu data
                            	en
                            	retu []
                            endf
                            
    1              0.000002 fu! ctrlp#utils#mkdir(dir)
                            	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
                            	retu a:dir
                            endf
                            
    1              0.000002 fu! ctrlp#utils#writecache(lines, ...)
                            	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
                            		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
                            	en
                            endf
                            
    1              0.000001 fu! ctrlp#utils#glob(...)
                            	let path = ctrlp#utils#fnesc(a:1, 'g')
                            	retu s:wig_cond ? glob(path, a:2) : glob(path)
                            endf
                            
    1              0.000001 fu! ctrlp#utils#globpath(...)
                            	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])
                            endf
                            
    1              0.000002 fu! ctrlp#utils#fnesc(path, type, ...)
                            	if exists('*fnameescape')
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = fnameescape(a:path)
                            		en
                            	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
                            	en
                            	retu a:0 ? escape(path, a:1) : path
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/neomake/autoload/neomake/log.vim
Sourced 1 time
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
    1              0.000011 let s:level_to_name = {0: 'error  ', 1: 'warning', 2: 'verbose', 3: 'debug  '}
    1              0.000004 let s:name_to_level = {'error': 0, 'warning': 1, 'verbose': 2, 'debug': 3}
    1              0.000004 let s:short_level_to_name = {0: 'E', 1: 'W', 2: 'V', 3: 'D'}
    1              0.000004 let s:is_testing = exists('g:neomake_test_messages')
                            
    1              0.000003 function! s:reltime_lastmsg() abort
                                if exists('s:last_msg_ts')
                                    let cur = neomake#compat#reltimefloat()
                                    let diff = (cur - s:last_msg_ts)
                                else
                                    let diff = 0
                                endif
                                let s:last_msg_ts = neomake#compat#reltimefloat()
                            
                                if diff < 0.01
                                    return '     '
                                elseif diff < 10
                                    let format = '+%.2f'
                                elseif diff < 100
                                    let format = '+%.1f'
                                elseif diff < 100
                                    let format = '  +%.0f'
                                elseif diff < 1000
                                    let format = ' +%.0f'
                                else
                                    let format = '+%.0f'
                                endif
                                return printf(format, diff)
                            endfunction
                            
    1              0.000002 function! s:log(level, msg, ...) abort
                                let context = a:0 ? a:1 : {}
                                let verbosity = neomake#utils#get_verbosity(context)
                                let logfile = get(g:, 'neomake_logfile', '')
                            
                                if !s:is_testing && verbosity < a:level && empty(logfile)
                                    return
                                endif
                            
                                if a:0
                                    let msg = printf('[%s.%s:%s:%d] %s',
                                                \ get(context, 'make_id', '-'),
                                                \ get(context, 'id', '-'),
                                                \ get(context, 'bufnr', get(context, 'file_mode', 0) ? '?' : '-'),
                                                \ winnr(),
                                                \ a:msg)
                                else
                                    let msg = a:msg
                                endif
                            
                                " Use Vader's log for messages during tests.
                                " @vimlint(EVL104, 1, l:timediff)
                                if s:is_testing && (verbosity >= a:level || get(g:, 'neomake_test_log_all_messages', 0))
                                    let timediff = s:reltime_lastmsg()
                                    if timediff !=# '     '
                                        let test_msg = '['.s:short_level_to_name[a:level].' '.timediff.']: '.msg
                                    else
                                        let test_msg = '['.s:level_to_name[a:level].']: '.msg
                                    endif
                            
                                    call vader#log(test_msg)
                                    " Only keep context entries that are relevant for / used in the message.
                                    let context = a:0
                                                \ ? filter(copy(context), "index(['id', 'make_id', 'bufnr'], v:key) != -1")
                                                \ : {}
                                    call add(g:neomake_test_messages, [a:level, a:msg, context])
                                    if index(['.', '!', ')', ']'], a:msg[-1:-1]) == -1
                                        let g:neomake_test_errors += ['Log msg does not end with punctuation: "'.a:msg.'".']
                                    endif
                                elseif verbosity >= a:level
                                    redraw
                                    if a:level ==# 0
                                        echohl ErrorMsg
                                    elseif a:level ==# 1
                                        echohl WarningMsg
                                    endif
                                    if verbosity > 2
                                        echom 'Neomake: '.msg
                                    else
                                        " Use message without context for non-debug msgs.
                                        echom 'Neomake: '.a:msg
                                    endif
                                    if a:level ==# 0 || a:level ==# 1
                                        echohl None
                                    endif
                                endif
                                if !empty(logfile) && type(logfile) ==# type('')
                                    if !exists('s:logfile_writefile_opts')
                                        " Use 'append' with writefile, but only if it is available.  Otherwise, just
                                        " overwrite the file.  'S' is used to disable fsync in Neovim
                                        " (https://github.com/neovim/neovim/pull/6427).
                                        let s:can_append_to_logfile = v:version > 704 || (v:version == 704 && has('patch503'))
                                        if !s:can_append_to_logfile
                                            redraw
                                            echohl WarningMsg
                                            echom 'Neomake: appending to the logfile is not supported in your Vim version.'
                                            echohl NONE
                                        endif
                                        let s:logfile_writefile_opts = s:can_append_to_logfile ? 'aS' : ''
                                    endif
                            
                                    let date = strftime('%H:%M:%S')
                                    if !exists('timediff')
                                        let timediff = s:reltime_lastmsg()
                                    endif
                                    try
                                        call writefile([printf('%s [%s %s] %s',
                                                    \ date, s:short_level_to_name[a:level], timediff, msg)],
                                                    \ logfile, s:logfile_writefile_opts)
                                    catch
                                        unlet g:neomake_logfile
                                        call neomake#log#error(printf('Error when trying to write to logfile %s: %s.  Unsetting g:neomake_logfile.', logfile, v:exception))
                                    endtry
                                endif
                                " @vimlint(EVL104, 0, l:timediff)
                            endfunction
                            
    1              0.000002 function! neomake#log#error(...) abort
                                call call('s:log', [0] + a:000)
                            endfunction
                            
    1              0.000002 function! neomake#log#warning(...) abort
                                call call('s:log', [1] + a:000)
                            endfunction
                            
    1              0.000001 function! neomake#log#info(...) abort
                                call call('s:log', [2] + a:000)
                            endfunction
                            
    1              0.000001 function! neomake#log#debug(...) abort
                                call call('s:log', [3] + a:000)
                            endfunction
                            
    1              0.000002 function! neomake#log#debug_obj(msg, obj) abort
                                if s:is_testing || neomake#utils#get_verbosity() >= 3 || !empty(get(g:, 'neomake_logfile', ''))
                                    call neomake#log#debug(a:msg.': '.neomake#utils#Stringify(a:obj).'.')
                                endif
                            endfunction
                            
    1              0.000002 function! neomake#log#exception(error, ...) abort
                                let log_context = a:0 ? a:1 : {'bufnr': bufnr('%')}
                                redraw
                                echom printf('Neomake error in: %s', v:throwpoint)
                                call neomake#log#error(a:error, log_context)
                                call neomake#log#debug(printf('(in %s)', v:throwpoint), log_context)
                            endfunction
                            
    1              0.000002 let s:warned = {}
    1              0.000002 function! neomake#log#warn_once(msg, key) abort
                                if !has_key(s:warned, a:key)
                                    let s:warned[a:key] = 1
                                    echohl WarningMsg
                                    redraw | echom 'Neomake: ' . a:msg
                                    echohl None
                                    let v:warningmsg = 'Neomake: '.a:msg
                                    call neomake#log#debug('Neomake warning: '.a:msg)
                                endif
                            endfunction

SCRIPT  /Users/stevezhang/.local/share/nvim/plugged/neomake/autoload/neomake/utils.vim
Sourced 1 time
Total time:   0.000447
 Self time:   0.000447

count  total (s)   self (s)
                            " vim: ts=4 sw=4 et
    1              0.000003 scriptencoding utf-8
                            
                            " Get verbosity, optionally based on jobinfo's make_id (a:1).
    1              0.000003 function! neomake#utils#get_verbosity(...) abort
                                if a:0 && has_key(a:1, 'make_id')
                                    return neomake#GetMakeOptions(a:1.make_id).verbosity
                                endif
                                return get(g:, 'neomake_verbose', 1) + &verbose
                            endfunction
                            
    1              0.000002 function! neomake#utils#Stringify(obj) abort
                                if type(a:obj) == type([])
                                    let ls = map(copy(a:obj), 'neomake#utils#Stringify(v:val)')
                                    return '['.join(ls, ', ').']'
                                elseif type(a:obj) == type({})
                                    let ls = []
                                    for [k, V] in items(a:obj)
                                        if type(V) == type(function('tr'))
                                            let fname = substitute(string(V), ', {\zs.*\ze})', '…', '')
                                            call add(ls, k.': '.fname)
                                        else
                                            call add(ls, k.': '.neomake#utils#Stringify(V))
                                        endif
                                        unlet V  " vim73
                                    endfor
                                    return '{'.join(ls, ', ').'}'
                                elseif type(a:obj) == type(function('tr'))
                                    return string(a:obj)
                                else
                                    return a:obj
                                endif
                            endfunction
                            
    1              0.000002 function! neomake#utils#wstrpart(mb_string, start, len) abort
                                return matchstr(a:mb_string, '.\{,'.a:len.'}', 0, a:start+1)
                            endfunction
                            
                            " This comes straight out of syntastic.
                            "print as much of a:msg as possible without "Press Enter" prompt appearing
    1              0.000002 function! neomake#utils#WideMessage(msg) abort " {{{2
                                let old_ruler = &ruler
                                let old_showcmd = &showcmd
                            
                                " Replace newlines (typically in the msg) with a single space.  This
                                " might happen with writegood.
                                let msg = substitute(a:msg, '\r\?\n', ' ', 'g')
                            
                                "convert tabs to spaces so that the tabs count towards the window
                                "width as the proper amount of characters
                                let chunks = split(msg, "\t", 1)
                                let msg = join(map(chunks[:-2], "v:val . repeat(' ', &tabstop - strwidth(v:val) % &tabstop)"), '') . chunks[-1]
                                let msg = neomake#utils#wstrpart(msg, 0, &columns - 1)
                            
                                set noruler noshowcmd
                                redraw
                            
                                call neomake#log#debug('WideMessage: echo '.msg.'.')
                                echo msg
                            
                                let &ruler = old_ruler
                                let &showcmd = old_showcmd
                            endfunction " }}}2
                            
                            " This comes straight out of syntastic.
    1              0.000002 function! neomake#utils#IsRunningWindows() abort
                                return has('win32') || has('win64')
                            endfunction
                            
                            " Get directory/path separator.
    1              0.000002 function! neomake#utils#Slash() abort
                                return (!exists('+shellslash') || &shellslash) ? '/' : '\'
                            endfunction
                            
    1              0.000002 function! neomake#utils#Exists(exe) abort
                                " DEPRECATED: just use executable() directly.
                                return executable(a:exe)
                            endfunction
                            
                            " Object used with neomake#utils#MakerFromCommand.
    1              0.000025 let s:maker_from_command = extend(copy(g:neomake#core#command_maker_base), {
                                        \ 'remove_invalid_entries': 0,
                                        \ })
    1              0.000002 function! s:maker_from_command._get_argv(jobinfo) abort dict
                                let fname = self._get_fname_for_args(a:jobinfo)
                                let args = neomake#utils#ExpandArgs(self.args)
                                if !empty(fname)
                                    if self.__command_is_string
                                        let fname = neomake#utils#shellescape(fname)
                                        let args[-1] .= ' '.fname
                                    else
                                        call add(args, fname)
                                    endif
                                endif
                                return neomake#compat#get_argv(self.exe, args, 1)
                            endfunction
                            
                            " Create a maker object for a given command.
                            " Args: command (string or list).  Gets wrapped in a shell in case it is a
                            "       string.
    1              0.000002 function! neomake#utils#MakerFromCommand(command) abort
                                let maker = copy(s:maker_from_command)
                                if type(a:command) == type('')
                                    let argv = split(&shell) + split(&shellcmdflag)
                                    let maker.exe = argv[0]
                                    let maker.args = argv[1:] + [a:command]
                                    let maker.__command_is_string = 1
                                else
                                    let maker.exe = a:command[0]
                                    let maker.args = a:command[1:]
                                    let maker.__command_is_string = 0
                                endif
                                return maker
                            endfunction
                            
    1              0.000002 let s:super_ft_cache = {}
    1              0.000002 function! neomake#utils#GetSupersetOf(ft) abort
                                if !has_key(s:super_ft_cache, a:ft)
                                    call neomake#utils#load_ft_makers(a:ft)
                                    let SupersetOf = 'neomake#makers#ft#'.a:ft.'#SupersetOf'
                                    if exists('*'.SupersetOf)
                                        let s:super_ft_cache[a:ft] = call(SupersetOf, [])
                                    else
                                        let s:super_ft_cache[a:ft] = ''
                                    endif
                                endif
                                return s:super_ft_cache[a:ft]
                            endfunction
                            
    1              0.000002 let s:loaded_ft_maker_runtime = []
    1              0.000002 function! neomake#utils#load_ft_makers(ft) abort
                                " Load ft maker, but only once (for performance reasons and to allow for
                                " monkeypatching it in tests).
                                if index(s:loaded_ft_maker_runtime, a:ft) == -1
                                    if !exists('*neomake#makers#ft#'.a:ft.'#EnabledMakers')
                                        silent exe 'runtime! autoload/neomake/makers/ft/'.a:ft.'.vim'
                                    endif
                                    call add(s:loaded_ft_maker_runtime, a:ft)
                                endif
                            endfunction
                            
    1              0.000002 let s:loaded_global_maker_runtime = 0
    1              0.000002 function! neomake#utils#load_global_makers() abort
                                " Load global makers, but only once (for performance reasons and to allow
                                " for monkeypatching it in tests).
                                if !s:loaded_global_maker_runtime
                                    exe 'runtime! autoload/neomake/makers/*.vim'
                                    let s:loaded_global_maker_runtime = 1
                                endif
                            endfunction
                            
    1              0.000002 function! neomake#utils#get_ft_confname(ft, ...) abort
                                return substitute(a:ft, '\W', a:0 ? a:1 : '_', 'g')
                            endfunction
                            
                            " Resolve filetype a:ft into a list of filetypes suitable for config vars
                            " (i.e. 'foo.bar' => ['foo_bar', 'foo', 'bar']).
    1              0.000002 function! neomake#utils#get_config_fts(ft, ...) abort
                                let r = []
                                let fts = split(a:ft, '\.')
                                for ft in fts
                                    call add(r, ft)
                                    let super_ft = neomake#utils#GetSupersetOf(ft)
                                    while !empty(super_ft)
                                        if index(fts, super_ft) == -1
                                            call add(r, super_ft)
                                        endif
                                        let super_ft = neomake#utils#GetSupersetOf(super_ft)
                                    endwhile
                                endfor
                                if len(fts) > 1
                                    call insert(r, a:ft, 0)
                                endif
                                let delim = a:0 ? a:1 : '_'
                                return map(r, 'neomake#utils#get_ft_confname(v:val, delim)')
                            endfunction
                            
    1              0.000003 let s:unset = {}  " Sentinel.
                            
                            " Get a setting by key, based on filetypes, from the buffer or global
                            " namespace, defaulting to default.
                            " Use an empty bufnr ('') to ignore buffer-local settings.
    1              0.000003 function! neomake#utils#GetSetting(key, maker, default, ft, bufnr, ...) abort
                                let maker_only = a:0 ? a:1 : 0
                            
                                " Check new-style config.
                                if exists('g:neomake') || !empty(getbufvar(a:bufnr, 'neomake'))
                                    let context = {'ft': a:ft, 'maker': a:maker, 'bufnr': a:bufnr, 'maker_only': maker_only}
                                    let Ret = neomake#config#get(a:key, g:neomake#config#undefined, context)
                                    if Ret isnot g:neomake#config#undefined
                                        return Ret
                                    endif
                                endif
                            
                                return s:get_oldstyle_setting(a:key, a:maker, a:default, a:ft, a:bufnr, maker_only)
                            endfunction
                            
    1              0.000003 function! s:get_oldstyle_setting(key, maker, default, ft, bufnr, maker_only) abort
                                let maker_name = has_key(a:maker, 'name') ? a:maker.name : ''
                                if a:maker_only && empty(maker_name)
                                    if has_key(a:maker, a:key)
                                        return get(a:maker, a:key)
                                    endif
                                    return a:default
                                endif
                            
                                if a:bufnr isnot# ''
                                    if !empty(a:ft)
                                        let fts = neomake#utils#get_config_fts(a:ft) + ['']
                                    else
                                        let fts = ['']
                                    endif
                                    for ft in fts
                                        " Look through the override vars for a filetype maker, like
                                        " neomake_scss_sasslint_exe (should be a string), and
                                        " neomake_scss_sasslint_args (should be a list).
                                        let part = join(filter([ft, maker_name], '!empty(v:val)'), '_')
                                        if empty(part)
                                            break
                                        endif
                                        let config_var = 'neomake_'.part.'_'.a:key
                                        unlet! Bufcfgvar  " vim73
                                        let Bufcfgvar = neomake#compat#getbufvar(a:bufnr, config_var, s:unset)
                                        if Bufcfgvar isnot s:unset
                                            return copy(Bufcfgvar)
                                        endif
                                        if has_key(g:, config_var)
                                            return copy(get(g:, config_var))
                                        endif
                                    endfor
                                endif
                            
                                if has_key(a:maker, a:key)
                                    return get(a:maker, a:key)
                                endif
                            
                                let key = a:maker_only ? maker_name.'_'.a:key : a:key
                                " Look for 'neomake_'.key in the buffer and global namespace.
                                let bufvar = neomake#compat#getbufvar(a:bufnr, 'neomake_'.key, s:unset)
                                if bufvar isnot s:unset
                                    return bufvar
                                endif
                                if a:key !=# 'enabled_makers' && has_key(g:, 'neomake_'.key)
                                    return get(g:, 'neomake_'.key)
                                endif
                                return a:default
                            endfunction
                            
                            " Get property from highlighting group.
    1              0.000002 function! neomake#utils#GetHighlight(group, what) abort
                                let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse')
                                let what = a:what
                                if reverse
                                    let what = neomake#utils#ReverseSynIDattr(what)
                                endif
                                if what[-1:] ==# '#'
                                    let val = synIDattr(synIDtrans(hlID(a:group)), what, 'gui')
                                else
                                    let val = synIDattr(synIDtrans(hlID(a:group)), what, 'cterm')
                                endif
                                if empty(val) || val == -1
                                    let val = 'NONE'
                                endif
                                return val
                            endfunction
                            
    1              0.000002 function! neomake#utils#ReverseSynIDattr(attr) abort
                                if a:attr ==# 'fg'
                                    return 'bg'
                                elseif a:attr ==# 'bg'
                                    return 'fg'
                                elseif a:attr ==# 'fg#'
                                    return 'bg#'
                                elseif a:attr ==# 'bg#'
                                    return 'fg#'
                                endif
                                return a:attr
                            endfunction
                            
                            " Deprecated: moved to neomake#postprocess#compress_whitespace.
    1              0.000002 function! neomake#utils#CompressWhitespace(entry) abort
                                call neomake#postprocess#compress_whitespace(a:entry)
                            endfunction
                            
    1              0.000001 function! neomake#utils#redir(cmd) abort
                                " @vimlint(EVL108, 1)
                                if exists('*execute') && has('nvim-0.2.0')
                                " @vimlint(EVL108, 0)
                                    " NOTE: require Neovim, since Vim has at least an issue when using
                                    "       this in a :command-completion function.
                                    "       Ref: https://github.com/neomake/neomake/issues/650.
                                    "       Neovim 0.1.7 also parses 'highlight' wrongly.
                                    return execute(a:cmd)
                                endif
                                if type(a:cmd) == type([])
                                    let r = ''
                                    for cmd in a:cmd
                                        let r .= neomake#utils#redir(cmd)
                                    endfor
                                    return r
                                endif
                                try
                                    redir => neomake_redir
                                    silent exe a:cmd
                                catch /^Vim(redir):E121:/
                                    throw printf('Neomake: neomake#utils#redir: called with outer :redir (error: %s).',
                                                \ v:exception)
                                finally
                                    redir END
                                endtry
                                return neomake_redir
                            endfunction
                            
    1              0.000002 function! neomake#utils#ExpandArgs(args) abort
                                " Expand % in args similar to when using :!
                                " \% is ignored
                                " \\% is expanded to \\file.ext
                                " %% becomes %
                                " % must be followed with an expansion keyword
                                let ret = map(copy(a:args),
                                            \ 'substitute(v:val, '
                                            \ . '''\(\%(\\\@<!\\\)\@<!%\%(%\|\%(:[phtreS8.~]\)\+\|\ze\w\@!\)\)'', '
                                            \ . '''\=(submatch(1) == "%%" ? "%" : expand(submatch(1)))'', '
                                            \ . '''g'')')
                                let ret = map(ret, 'substitute(v:val, ''\v^\~\ze%(/|$)'', expand(''~''), ''g'')')
                                return ret
                            endfunction
                            
    1              0.000002 function! neomake#utils#hook(event, context, ...) abort
                                if exists('#User#'.a:event)
                                    let jobinfo = a:0 ? a:1 : (
                                                \ has_key(a:context, 'jobinfo') ? a:context.jobinfo : {})
                            
                                    let context_str = string(map(copy(a:context),
                                                \ "v:key ==# 'jobinfo' ? '…'"
                                                \ .": (v:key ==# 'finished_jobs' ? map(copy(v:val), 'v:val.as_string()') : v:val)"))
                                    let args = [printf('Calling User autocmd %s with context: %s.',
                                                \ a:event, context_str)]
                                    if !empty(jobinfo)
                                        let args += [jobinfo]
                                    endif
                                    call call('neomake#log#info', args)
                            
                                    if exists('g:neomake_hook_context')
                                        throw printf('Neomake internal error: hook invocation must not be nested: %s.', a:event)
                                    endif
                                    unlockvar g:neomake_hook_context
                                    let g:neomake_hook_context = a:context
                                    lockvar 1 g:neomake_hook_context
                                    try
                                        if v:version >= 704 || (v:version == 703 && has('patch442'))
                                            exec 'doautocmd <nomodeline> User ' . a:event
                                        else
                                            exec 'doautocmd User ' . a:event
                                        endif
                                    catch
                                        let error = v:exception
                                        if error[-1:] !=# '.'
                                            let error .= '.'
                                        endif
                                        call neomake#log#exception(printf(
                                                    \ 'Error during User autocmd for %s: %s',
                                                    \ a:event, error), jobinfo)
                                    finally
                                        unlet g:neomake_hook_context
                                    endtry
                                endif
                            endfunction
                            
    1              0.000004 function! neomake#utils#diff_dict(old, new) abort
                                let diff = {}
                                let keys = keys(a:old) + keys(a:new)
                                for k in keys
                                    if !has_key(a:new, k)
                                        if !has_key(diff, 'removed')
                                            let diff['removed'] = {}
                                        endif
                                        let diff['removed'][k] = a:old[k]
                                    elseif !has_key(a:old, k)
                                        if !has_key(diff, 'added')
                                            let diff['added'] = {}
                                        endif
                                        let diff['added'][k] = a:new[k]
                                    elseif type(a:old[k]) !=# type(a:new[k]) || a:old[k] !=# a:new[k]
                                        if !has_key(diff, 'changed')
                                            let diff['changed'] = {}
                                        endif
                                        let diff['changed'][k] = [a:old[k], a:new[k]]
                                    endif
                                endfor
                                return diff
                            endfunction
                            
                            " Sort quickfix/location list entries by distance to current cursor position's
                            " column, but preferring entries starting at or behind the cursor position.
    1              0.000002 function! neomake#utils#sort_by_col(a, b) abort
                                let col = getpos('.')[2]
                                if a:a.col > col
                                    if a:b.col < col
                                        return 1
                                    endif
                                elseif a:b.col > col
                                    return -1
                                endif
                                return abs(col - a:a.col) - abs(col - a:b.col)
                            endfunction
                            
    1              0.000002 function! neomake#utils#path_sep() abort
                                return neomake#utils#IsRunningWindows() ? ';' : ':'
                            endfunction
                            
                            " Find a file matching `a:glob` (using `globpath()`) by going up the
                            " directories from the start directory (a:1, defaults to `expand('%:p:h')`,
                            " i.e. the directory of the current buffer's file).)
    1              0.000002 function! neomake#utils#FindGlobFile(glob, ...) abort
                                let curDir = a:0 ? a:1 : expand('%:p:h')
                                let fileFound = []
                                while 1
                                    let fileFound = neomake#compat#globpath_list(curDir, a:glob, 1)
                                    if !empty(fileFound)
                                        return fileFound[0]
                                    endif
                                    let lastFolder = curDir
                                    let curDir = fnamemodify(curDir, ':h')
                                    if curDir ==# lastFolder
                                        break
                                    endif
                                endwhile
                                return ''
                            endfunction
                            
    1              0.000002 function! neomake#utils#JSONdecode(json) abort
                                return neomake#compat#json_decode(a:json)
                            endfunction
                            
                            " Smarter shellescape, via vim-fugitive.
    1              0.000002 function! s:gsub(str,pat,rep) abort
                                return substitute(a:str,'\v\C'.a:pat,a:rep,'g')
                            endfunction
                            
    1              0.000002 function! neomake#utils#shellescape(arg) abort
                                if a:arg =~# '^[A-Za-z0-9_/.=-]\+$'
                                    return a:arg
                                elseif &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
                                    return '"'.s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"').'"'
                                endif
                                return shellescape(a:arg)
                            endfunction
                            
    1              0.000002 function! neomake#utils#get_buffer_lines(bufnr) abort
                                let buflines = getbufline(a:bufnr, 1, '$')
                                " Special case: empty buffer; do not write an empty line in this case.
                                if len(buflines) > 1 || buflines != ['']
                                    if getbufvar(a:bufnr, '&endofline')
                                                \ || (!getbufvar(a:bufnr, '&binary')
                                                \     && (!exists('+fixendofline') || getbufvar(a:bufnr, '&fixendofline')))
                                        call add(buflines, '')
                                    endif
                                endif
                                return buflines
                            endfunction
                            
    1              0.000002 function! neomake#utils#write_tempfile(bufnr, temp_file) abort
                                call writefile(neomake#utils#get_buffer_lines(a:bufnr), a:temp_file, 'b')
                            endfunction
                            
                            " Wrapper around fnamemodify that handles special buffers (e.g. fugitive).
    1              0.000002 function! neomake#utils#fnamemodify(bufnr, modifier) abort
                                let bufnr = +a:bufnr
                                if !empty(getbufvar(bufnr, 'fugitive_type'))
                                    let fug_buffer = fugitive#buffer(bufnr)
                                    let path = fnamemodify(fug_buffer.repo().translate(fug_buffer.path()), ':.')
                                else
                                    let path = bufname(bufnr)
                                endif
                                return empty(path) ? '' : fnamemodify(path, a:modifier)
                            endfunction
                            
    1              0.000002 function! neomake#utils#fix_self_ref(obj, ...) abort
                                if type(a:obj) != type({})
                                    return a:obj
                                endif
                                let obj = copy(a:obj)
                                for k in keys(obj)
                                    if a:0
                                        let self_ref = filter(copy(a:1), 'v:val[1][0] is obj[k]')
                                        if !empty(self_ref)
                                            let obj[k] = printf('<self-ref-%d: %s>', self_ref[0][0], self_ref[0][1][1])
                                            continue
                                        endif
                                    endif
                                    if type(obj[k]) == type({})
                                        let obj[k] = neomake#utils#fix_self_ref(obj[k], a:0 ? a:1 + [[len(a:1)+1, [a:obj, k]]] : [[1, [a:obj, k]]])
                                    elseif has('nvim')
                                        " Ensure that it can be used as a string.
                                        " Ref: https://github.com/neovim/neovim/issues/7432
                                        try
                                            call string(obj[k])
                                        catch /^Vim(call):E724:/
                                            let obj[k] = '<unrepresentable object, type='.type(obj).'>'
                                        endtry
                                    endif
                                endfor
                                return obj
                            endfunction
                            
    1              0.000002 function! neomake#utils#parse_highlight(group) abort
                                let output = neomake#utils#redir('highlight '.a:group)
                                return join(split(output)[2:])
                            endfunction
                            
    1              0.000002 function! neomake#utils#highlight_is_defined(group) abort
                                if !hlexists(a:group)
                                    return 0
                                endif
                                return neomake#utils#parse_highlight(a:group) !=# 'cleared'
                            endfunction
                            
    1              0.000002 function! neomake#utils#get_project_root(...) abort
                                let bufnr = a:0 ? a:1 : bufnr('%')
                                let ft = getbufvar(bufnr, '&filetype')
                                call neomake#utils#load_ft_makers(ft)
                            
                                let project_root_files = ['.git', 'Makefile']
                            
                                let ft_project_root_files = 'neomake#makers#ft#'.ft.'#project_root_files'
                                if has_key(g:, ft_project_root_files)
                                    let project_root_files = get(g:, ft_project_root_files) + project_root_files
                                endif
                            
                                let buf_dir = expand('#'.bufnr.':p:h')
                                for fname in project_root_files
                                    let project_root = neomake#utils#FindGlobFile(fname, buf_dir)
                                    if !empty(project_root)
                                        return fnamemodify(project_root, ':h')
                                    endif
                                endfor
                                return ''
                            endfunction
                            
                            " Return the number of lines for a given buffer.
                            " This returns 0 for unloaded buffers.
    1              0.000004 if exists('*nvim_buf_line_count')
    1              0.000002     function! neomake#utils#get_buf_line_count(bufnr) abort
                                    if !bufloaded(a:bufnr)
                                        " https://github.com/neovim/neovim/issues/7688
                                        return 0
                                    endif
                                    return nvim_buf_line_count(a:bufnr)
                                endfunction
    1              0.000001 else
                                function! neomake#utils#get_buf_line_count(bufnr) abort
                                    if a:bufnr == bufnr('%')
                                        return line('$')
                                    endif
                                    " TODO: this should get cached (based on b:changedtick), and cleaned
                                    "       in BufWipeOut.
                                    return len(getbufline(a:bufnr, 1, '$'))
                                endfunction
                            endif

FUNCTION  remote#define#FunctionOnChannel()
Called 1 time
Total time:   0.000117
 Self time:   0.000093

count  total (s)   self (s)
    1              0.000004   let rpcargs = [a:channel, '"'.a:method.'"', 'a:000']
    1              0.000003   if has_key(a:opts, 'range')
                                call add(rpcargs, '[a:firstline, a:lastline]')
                              endif
    1   0.000020   0.000009   call s:AddEval(rpcargs, a:opts)
                            
    1   0.000042   0.000028   let function_def = s:GetFunctionPrefix(a:name, a:opts) . 'return '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')' . "\nendfunction"
    1              0.000044   exe function_def

FUNCTION  8()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))

FUNCTION  remote#host#Require()
Called 1 time
Total time:   0.225280
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000003   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
    1              0.000002   let host = s:hosts[a:name]
    1              0.000002   if !host.channel && !host.initialized
    1              0.000005     let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
    1   0.225255   0.000028     let host.channel = call(host.factory, [host_info])
    1              0.000002     let host.initialized = 1
    1              0.000001   endif
    1              0.000005   return host.channel

FUNCTION  lightline#init()
Called 1 time
Total time:   0.000844
 Self time:   0.000669

count  total (s)   self (s)
    1              0.000005   let s:lightline = deepcopy(get(g:, 'lightline', {}))
   25              0.000051   for [key, value] in items(s:_lightline)
   24              0.000031     if type(value) == 4
   22              0.000036       if !has_key(s:lightline, key)
   22              0.000037         let s:lightline[key] = {}
   22              0.000010       endif
   22              0.000101       call extend(s:lightline[key], value, 'keep')
   22              0.000029     elseif !has_key(s:lightline, key)
    2              0.000004       let s:lightline[key] = value
    2              0.000001     endif
   24              0.000015     unlet value
   24              0.000015   endfor
    1              0.000004   call extend(s:lightline.tabline_separator, s:lightline.separator, 'keep')
    1              0.000004   call extend(s:lightline.tabline_subseparator, s:lightline.subseparator, 'keep')
    1              0.000006   let s:lightline.tabline_configured = has_key(get(get(g:, 'lightline', {}), 'component_expand', {}), 'tabs')
    3              0.000008   for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
    2              0.000013     if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
                                  let s:lightline.tabline_configured = 1
                                  break
                                endif
    2              0.000001   endfor
    1              0.000002   if !exists('s:_statusline')
    1              0.000003     let s:_statusline = &statusline
    1              0.000000   endif
    1              0.000002   if !exists('s:_tabline')
    1              0.000002     let s:_tabline = &tabline
    1              0.000000   endif
    1              0.000001   if s:lightline.enable.tabline
    1              0.000002     set tabline=%!lightline#tabline()
    1              0.000001   else
                                let &tabline = get(s:, '_tabline', '')
                              endif
    1              0.000003   for f in values(s:lightline.component_function)
                                silent! call call(f, [])
                              endfor
    5              0.000008   for f in values(s:lightline.tab_component_function)
    4   0.000366   0.000192     silent! call call(f, [1])
    4              0.000003   endfor
    1              0.000001   let s:mode = ''

FUNCTION  remote#host#RegisterClone()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000003   if !has_key(s:hosts, a:orig_name)
                                throw 'No host named "'.a:orig_name.'" is registered'
                              endif
    1              0.000003   let Factory = s:hosts[a:orig_name].factory
    1              0.000004   let s:hosts[a:name] = { 'factory': Factory, 'channel': 0, 'initialized': 0, 'orig_name': a:orig_name }

FUNCTION  <SNR>2_loaded_names()
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000037   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')

FUNCTION  <SNR>56_AddEval()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002   if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
                              endif

FUNCTION  nerdtree#runningCygwin()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003     return has("win32unix")

FUNCTION  <SNR>19_savetofile()
Called 1 time
Total time:   0.000462
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000461   0.000010 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>81_lash()
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000023 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  NERDTreeAddKeyMap()
Called 45 times
Total time:   0.001727
 Self time:   0.000170

count  total (s)   self (s)
   45   0.001714   0.000157     call g:NERDTreeKeyMap.Create(a:options)

FUNCTION  <SNR>56_GetNextAutocmdGroup()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000002   let gid = s:next_gid
    1              0.000001   let s:next_gid += 1
                            
    1              0.000003   let group_name = 'RPC_DEFINE_AUTOCMD_GROUP_'.gid
                              " Ensure the group is defined
    1              0.000005   exe 'augroup '.group_name.' | augroup END'
    1              0.000001   return group_name

FUNCTION  <SNR>2_parse_options()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000007   let opts = copy(s:base_spec)
    1              0.000002   let type = type(a:arg)
    1              0.000001   if type == s:TYPE.string
                                let opts.tag = a:arg
                              elseif type == s:TYPE.dict
    1              0.000004     call extend(opts, a:arg)
    1              0.000002     if has_key(opts, 'dir')
                                  let opts.dir = s:dirpath(expand(opts.dir))
                                endif
    1              0.000000   else
                                throw 'Invalid argument type (expected: string or dictionary)'
                              endif
    1              0.000001   return opts

FUNCTION  lightline#tab#filename()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000004   let buflist = tabpagebuflist(a:n)
    1              0.000002   let winnr = tabpagewinnr(a:n)
    1              0.000009   let _ = expand('#'.buflist[winnr - 1].':t')
    1              0.000002   return _ !=# '' ? _ : '[No Name]'

FUNCTION  ctrlp#utils#writecache()
Called 1 time
Total time:   0.000452
 Self time:   0.000436

count  total (s)   self (s)
    1   0.000027   0.000012 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    1              0.000422 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    1              0.000001 	en

FUNCTION  ctrlp#mrufiles#opts()
Called 1 time
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000010 	let [pref, opts] = ['g:ctrlp_mruf_', { 'max': ['s:max', 250], 'include': ['s:in', ''], 'exclude': ['s:ex', ''], 'case_sensitive': ['s:cseno', 1], 'relative': ['s:re', 0], 'save_on_update': ['s:soup', 1], }]
    7              0.000018 	for [ke, va] in items(opts)
    6              0.000046 		let [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
    6              0.000003 	endfo

FUNCTION  neomake#GetCurrentErrorMsg()
Called 1 time
Total time:   0.000088
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000084   0.000015     let entry = neomake#get_nearest_error()
    1              0.000002     if empty(entry)
    1              0.000001         return ''
                                endif
                                let r = entry.maker_name . ': ' . entry.text
                                let suffix = entry.type . (entry.nr != -1 ? entry.nr : '')
                                if !empty(suffix)
                                    let r .= ' ('.suffix.')'
                                endif
                                return r

FUNCTION  deoplete#util#get_input()
Called 2 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000005   let mode = mode()
    2              0.000003   if a:event ==# 'InsertEnter'
                                let mode = 'i'
                              endif
    2              0.000020   let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
    2              0.000014   if input =~# '^.\{-}\ze\S\+$'
                                let complete_str = matchstr(input, '\S\+$')
                                let input = matchstr(input, '^.\{-}\ze\S\+$')
                              else
    2              0.000002     let complete_str = ''
    2              0.000001   endif
                            
    2              0.000003   if a:event ==# 'InsertCharPre'
                                let complete_str .= v:char
                              endif
                            
    2              0.000003   return input . complete_str

FUNCTION  AddTabularPattern()
Called 6 times
Total time:   0.001112
 Self time:   0.000359

count  total (s)   self (s)
    6              0.000005   try
    6   0.000141   0.000040     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
                            
    6              0.000053     let name = matchstr(rest, '.\{-}\ze\s*/')
    6              0.000055     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
                            
    6   0.000687   0.000036     let [ pattern, format ] = s:ParsePattern(pattern)
                            
    6              0.000013     if empty(name) || empty(pattern)
                                  throw "Invalid arguments!"
                                endif
                            
    6              0.000010     if !a:force && has_key(commandmap, name)
                                  throw string(name) . " is already defined, use ! to overwrite."
                                endif
                            
    6              0.000019     let command = "tabular#TabularizeStrings(a:lines, " . string(pattern)
                            
    6              0.000008     if !empty(format)
    6              0.000018       let command .=  ", " . string(format)
    6              0.000003     endif
                            
    6              0.000009     let command .= ")"
                            
    6              0.000024     let commandmap[name] = { 'pattern' : pattern, 'commands' : [ command ] }
    6              0.000004   catch
                                echohl ErrorMsg
                                echomsg "AddTabularPattern: " . v:exception
                                echohl None
                              endtry

FUNCTION  lightline#update()
Called 1 time
Total time:   0.006811
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000002   if s:_
    1   0.000851   0.000008     call lightline#init()
    1   0.004750   0.000007     call lightline#colorscheme()
    1              0.000001   endif
    1              0.000001   if !s:lightline.enable.statusline
                                return
                              endif
    1              0.000002   let w = winnr()
    1   0.001182   0.000012   let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
    2              0.000004   for n in range(1, winnr('$'))
    1              0.000007     call setwinvar(n, '&statusline', s[n!=w])
    1              0.000003     call setwinvar(n, 'lightline', n!=w)
    1              0.000001   endfor

FUNCTION  deoplete#mapping#_init()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                              " Note: The dummy function is needed for cpoptions bug in neovim
    1              0.000011   inoremap <expr><silent> <Plug>_ deoplete#mapping#_dummy_complete()

FUNCTION  <SNR>2_path()
Called 1 time
Total time:   0.000023
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000023   0.000008     return s:trim(a:path)

FUNCTION  <SNR>78_define_completion_via_timer()
Called 3 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    3              0.000007   if !exists('##' . a:event)
                                return
                              endif
                            
    3              0.000020   execute 'autocmd deoplete' a:event '* call s:completion_timer_start('.string(a:event).')'

FUNCTION  <SNR>65_SetConcealOption()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000001     if !g:indentLine_setConceal
                                    return
                                endif
    1              0.000002     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
    1              0.000002         let b:indentLine_ConcealOptionSet = 1
    1              0.000002         let b:indentLine_original_concealcursor = &l:concealcursor
    1              0.000002         let b:indentLine_original_conceallevel = &l:conceallevel
    1              0.000004         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
    1              0.000004         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
    1              0.000001     endif

FUNCTION  deoplete#util#get_next_input()
Called 1 time
Total time:   0.000041
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000040   0.000007   return getline('.')[len(deoplete#util#get_input(a:event)) :]

FUNCTION  <SNR>68_subseparator()
Called 5 times
Total time:   0.000200
 Self time:   0.000200

count  total (s)   self (s)
    5              0.000025   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
    5              0.000126   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
    5              0.000044   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  UltiSnips#map_keys#MapKeys()
Called 2 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    2              0.000005     if g:UltiSnipsExpandTrigger == g:UltiSnipsJumpForwardTrigger
                                    exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippetOrJump()<cr>"
                                    exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>"
                                else
    2              0.000020         exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippet()<cr>"
    2              0.000017         exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippet()<cr>"
    2              0.000001     endif
    2              0.000016     exec "xnoremap <silent> " . g:UltiSnipsExpandTrigger. " :call UltiSnips#SaveLastVisualSelection()<cr>gvs"
    2              0.000015     exec "inoremap <silent> " . g:UltiSnipsListSnippets . " <C-R>=UltiSnips#ListSnippets()<cr>"
    2              0.000015     exec "snoremap <silent> " . g:UltiSnipsListSnippets . " <Esc>:call UltiSnips#ListSnippets()<cr>"
                            
    2              0.000007     snoremap <silent> <BS> <c-g>c
    2              0.000006     snoremap <silent> <DEL> <c-g>c
    2              0.000006     snoremap <silent> <c-h> <c-g>c
    2              0.000007     snoremap <c-r> <c-g>"_c<c-r>

FUNCTION  deoplete#init#_context()
Called 1 time
Total time:   0.001900
 Self time:   0.001293

count  total (s)   self (s)
    1   0.000077   0.000037   let input = deoplete#util#get_input(a:event)
                            
    1   0.000325   0.000013   let [filetype, filetypes, same_filetypes] = deoplete#util#get_context_filetype(input, a:event)
                            
    1   0.000013   0.000009   let sources = deoplete#util#convert2list(a:sources)
    1              0.000002   if a:event !=# 'Manual' && empty(sources)
                                " Use default sources
    1   0.000103   0.000010     let sources = deoplete#custom#_get_filetype_option( 'sources', filetype, [])
    1              0.000000   endif
                            
    1   0.000013   0.000009   let event = (deoplete#util#get_prev_event() ==# 'Refresh') ? 'Manual' : a:event
                            
    1              0.000009   let width = winwidth(0) - col('.') + len(matchstr(input, '\w*$'))
    1              0.000002   let max_width = (width * 2 / 3)
                            
    1              0.000008   let bufnr = expand('<abuf>') !=# '' ? expand('<abuf>') : bufnr('%')
    1              0.000002   let bufname = bufname(bufnr)
    1              0.000052   let bufpath = fnamemodify(bufname, ':p')
    1              0.000008   if !filereadable(bufpath) || getbufvar(bufnr, '&buftype') =~# 'nofile'
    1              0.000001     let bufpath = ''
    1              0.000001   endif
                            
    1   0.001277   0.001121   return { 'changedtick': b:changedtick, 'event': event, 'input': input, 'is_windows': s:is_windows, 'next_input': deoplete#util#get_next_input(a:event), 'complete_str': '', 'encoding': &encoding, 'position': getpos('.'), 'filetype': filetype, 'filetypes': filetypes, 'same_filetypes': same_filetypes, 'ignorecase': deoplete#custom#_get_option('ignore_case'), 'smartcase': deoplete#custom#_get_option('smart_case'), 'camelcase': deoplete#custom#_get_option('camel_case'), 'delay': deoplete#custom#_get_option('auto_complete_delay'), 'sources': sources, 'max_abbr_width': max_width, 'max_kind_width': max_width, 'max_menu_width': max_width, 'bufnr': bufnr, 'bufname': bufname, 'bufpath': bufpath, 'cwd': getcwd(), 'vars': filter(copy(g:),       "stridx(v:key, 'deoplete#') == 0        && v:key !=# 'deoplete#_yarp'"), 'bufvars': filter(copy(b:), "stridx(v:key, 'deoplete_') == 0"), 'custom': deoplete#custom#_get(), 'omni__omnifunc': &l:omnifunc, 'dict__dictionary': &l:dictionary, }

FUNCTION  <SNR>65_IndentLinesEnable()
Called 1 time
Total time:   0.000256
 Self time:   0.000236

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000001         if &diff
                                        return
                                    endif
                            
    1              0.000002         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
                                    endif
                            
    1              0.000002         if !exists("w:indentLine_indentLineId")
    1              0.000002             let w:indentLine_indentLineId = []
    1              0.000001         endif
                            
    1   0.000027   0.000007         call s:SetConcealOption()
                            
    1              0.000001         if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
                                    endif
                            
    1              0.000002         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
   21              0.000020         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
   20              0.000166             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
   20              0.000014         endfor
                            
    1              0.000001         return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  deoplete#util#uniq()
Called 1 time
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
    1              0.000017   let list = map(copy(a:list), '[v:val, v:val]')
    1              0.000002   let i = 0
    1              0.000002   let seen = {}
    5              0.000012   while i < len(list)
    4              0.000017     let key = string(list[i][1])
    4              0.000011     if has_key(seen, key)
                                  call remove(list, i)
                                else
    4              0.000010       let seen[key] = 1
    4              0.000006       let i += 1
    4              0.000003     endif
    4              0.000003   endwhile
    1              0.000010   return map(list, 'v:val[0]')

FUNCTION  <SNR>2_is_local_plug()
Called 20 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   20              0.000091     return a:repo[0] =~ '[/$~]'

FUNCTION  lightline#colorscheme#fill()
Called 1 time
Total time:   0.001976
 Self time:   0.001588

count  total (s)   self (s)
    7              0.000009   for k in values(a:p)
   24              0.000026     for l in values(k)
   49              0.000034       for m in l
   31              0.000036         if len(m) < 4
   25              0.000062           if type(m[0]) == 1 && type(m[1]) == 1
   25              0.000085             if m[0] =~# '^\d\+$' && m[1] =~# '^\d\+$'
                                          call insert(m, s:upconvert(m[1]), 0)
                                          call insert(m, s:upconvert(m[1]), 0)
                                        else
   25   0.000332   0.000129               call insert(m, get(s:cuicolor, m[0], s:convert(m[0])), 2)
   25   0.000304   0.000118               call insert(m, get(s:cuicolor, m[1], s:convert(m[1])), 3)
   25              0.000065               let m[0] = get(s:guicolor, m[0], m[0])
   25              0.000058               let m[1] = get(s:guicolor, m[1], m[1])
   25              0.000015             endif
   25              0.000044           elseif type(m[0]) == 0 && type(m[1]) == 0
                                          call insert(m, s:upconvert(m[1]), 0)
                                          call insert(m, s:upconvert(m[1]), 0)
                                      endif
   25              0.000010         endif
   31              0.000016       endfor
   18              0.000009     endfor
    6              0.000002   endfor
    1              0.000001   return a:p

FUNCTION  <SNR>54_GetManifestPath()
Called 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000002   let manifest_base = ''
                            
    1              0.000003   if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
                              endif
                            
    1              0.000004   let dest = has('win32') ? '$LOCALAPPDATA' : '$XDG_DATA_HOME'
    1              0.000002   if !exists(dest)
    1              0.000003     let dest = has('win32') ? '~/AppData/Local' : '~/.local/share'
    1              0.000001   endif
                            
    1              0.000027   let dest = fnamemodify(expand(dest), ':p')
    1              0.000002   if !empty(dest)
    1              0.000004     let dest .= ('/' ==# dest[-1:] ? '' : '/') . 'nvim'
    1              0.000006     if !isdirectory(dest)
                                  call mkdir(dest, 'p', 0700)
                                endif
    1              0.000001     let manifest_base = dest
    1              0.000000   endif
                            
    1              0.000002   return manifest_base.'/rplugin.vim'

FUNCTION  <SNR>2_define_commands()
Called 1 time
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    1              0.000007   command! -nargs=+ -bar Plug call plug#(<args>)
    1              0.000067   if !executable('git')
                                return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
                              endif
    1              0.000006   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
    1              0.000004   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
    1              0.000002   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
    1              0.000003   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
    1              0.000001   command! -nargs=0 -bar PlugStatus  call s:status()
    1              0.000001   command! -nargs=0 -bar PlugDiff    call s:diff()
    1              0.000003   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)

FUNCTION  <SNR>23_SplitCommands()
Called 7 times
Total time:   0.001572
 Self time:   0.000493

count  total (s)   self (s)
    7              0.000023   if a:string =~ '^\s*$'
                                return []
                              endif
                            
    7              0.000043   let end = match(a:string, "[\"'|]")
                            
                              " Loop until we find a delimiting | or end-of-string
   27              0.000063   while end != -1 && (a:string[end] != '|' || a:string[end+1] == '|')
   20              0.000029     if a:string[end] == "'"
   19              0.000074       let end = match(a:string, "'", end+1) + 1
   19              0.000014       if end == 0
                                    throw "No matching end single quote"
                                  endif
   19              0.000015     elseif a:string[end] == '"'
                                  " Find a " preceded by an even number of \ (or 0)
    1              0.000001       let pattern = '\%(\\\@<!\%(\\\\\)*\)\@<="'
    1              0.000037       let end = matchend(a:string, pattern, end+1) + 1
    1              0.000001       if end == 0
                                    throw "No matching end double quote"
                                  endif
    1              0.000001     else " Found ||
                                  let end += 2
                                endif
                            
   20              0.000078     let end = match(a:string, "[\"'|]", end)
   20              0.000014   endwhile
                            
    7              0.000030   if end == 0 || a:string[0 : end - (end > 0)] =~ '^\s*$'
                                throw "Empty element"
                              endif
                            
    7              0.000005   if end == -1
    3              0.000005     let rv = [ a:string ]
    3              0.000002   else
    4              0.000020     let rv = [ a:string[0 : end-1] ] + s:SplitCommands(a:string[end+1 : -1])
    4              0.000002   endif
                            
    7              0.000005   return rv

FUNCTION  <SNR>73_init_internal_variables()
Called 1 time
Total time:   0.001125
 Self time:   0.000206

count  total (s)   self (s)
    1   0.000016   0.000008   call deoplete#init#_prev_completion()
    1              0.000002   let g:deoplete#_context = {}
    1              0.000001   let g:deoplete#_rank = {}
    1              0.000002   if !exists('g:deoplete#_logging')
    1              0.000001     let g:deoplete#_logging = {}
    1              0.000001   endif
    1              0.000001   unlet! g:deoplete#_initialized
    1              0.000001   try
    1   0.001088   0.000177     let g:deoplete#_serveraddr = deoplete#util#has_yarp() ? neovim_rpc#serveraddr() : v:servername
    1              0.000002     if g:deoplete#_serveraddr ==# ''
                                  " Use NVIM_LISTEN_ADDRESS
                                  let g:deoplete#_serveraddr = $NVIM_LISTEN_ADDRESS
                                endif
    1              0.000001   catch
                                if deoplete#util#has_yarp() && !exists('*neovim_rpc#serveraddr')
                                  call deoplete#util#print_error( 'deoplete requires vim-hug-neovim-rpc plugin in Vim.')
                                endif
                              endtry

FUNCTION  neomake#CursorMovedDelayed()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000003     if exists('s:cursormoved_timer')
                                    call timer_stop(s:cursormoved_timer)
                                endif
    1              0.000012     let s:cursormoved_timer = timer_start(get(g:, 'neomake_cursormoved_delay', 100), function('s:cursormoved_delayed_cb'))
    1              0.000003     let s:cursormoved_last_pos = getpos('.')

FUNCTION  <SNR>78_define_on_event()
Called 4 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    4              0.000010   if !exists('##' . a:event)
                                return
                              endif
                            
    4              0.000035   execute 'autocmd deoplete' a:event '* if !&l:previewwindow | call deoplete#send_event(' .string(a:event).') | endif'

FUNCTION  <SNR>56_GetRpcFunction()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002   if a:sync ==# 'urgent'
                                return 'rpcnotify'
                              elseif a:sync
                                return 'remote#define#request'
                              endif
    1              0.000001   return 'remote#define#notify'

FUNCTION  ctrlp#utils#lash()
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000014 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  <SNR>79_cursormoved_delayed_cb()
Called 1 time
Total time:   0.000198
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000018     if getpos('.') == s:cursormoved_last_pos
    1   0.000177   0.000016         call neomake#CursorMoved()
    1              0.000001     endif

FUNCTION  _deoplete_init()
Called 1 time
Total time:   0.000034
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000034   0.000009 return remote#define#notify(3, "/Users/stevezhang/.local/share/nvim/plugged/deoplete.nvim/rplugin/python3/deoplete:function:_deoplete_init", a:000)

FUNCTION  remote#host#Register()
Called 4 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    4              0.000017   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
    4              0.000008   let s:plugin_patterns[a:name] = a:pattern
    4              0.000010   if type(a:factory) == type(1) && a:factory
                                " Passed a channel directly
                                let s:hosts[a:name].channel = a:factory
                              endif

FUNCTION  ctrlp#mrufiles#cachefile()
Called 1 time
Total time:   0.000408
 Self time:   0.000176

count  total (s)   self (s)
    1              0.000003 	if !exists('s:cadir') || !exists('s:cafile')
    1   0.000394   0.000166 		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
    1   0.000008   0.000004 		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
    1              0.000001 	en
    1              0.000001 	retu s:cafile

FUNCTION  <SNR>23_ParsePattern()
Called 6 times
Total time:   0.000651
 Self time:   0.000337

count  total (s)   self (s)
    6              0.000010   if a:string[0] != '/'
                                return ['','']
                              endif
                            
    6   0.000477   0.000163   let pat = '\\\@<!\%(\\\\\)\{-}\zs/' . tabular#ElementFormatPattern() . '*$'
    6              0.000086   let format = matchstr(a:string[1:-1], pat)
    6              0.000010   if !empty(format)
    6              0.000009     let format = format[1 : -1]
    6              0.000016     let pattern = a:string[1 : -len(format) - 2]
    6              0.000003   else
                                let pattern = a:string[1 : -1]
                              endif
                            
    6              0.000009   return [pattern, format]

FUNCTION  nerdtree#checkForBrowse()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000008     if !isdirectory(a:dir)
    2              0.000001         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  AddTabularPipeline()
Called 3 times
Total time:   0.001109
 Self time:   0.000258

count  total (s)   self (s)
    3              0.000002   try
    3   0.000063   0.000018     let [ commandmap, rest ] = s:ChooseCommandMap(a:command)
                            
    3              0.000030     let name = matchstr(rest, '.\{-}\ze\s*/')
    3              0.000026     let pattern = substitute(rest, '.\{-}\s*\ze/', '', '')
                            
    3              0.000070     let commands = matchstr(pattern, '^/.\{-}\\\@<!\%(\\\\\)\{-}/\zs.*')
    3              0.000029     let pattern = matchstr(pattern, '/\zs.\{-}\\\@<!\%(\\\\\)\{-}\ze/')
                            
    3              0.000007     if empty(name) || empty(pattern)
                                  throw "Invalid arguments!"
                                endif
                            
    3              0.000005     if !a:force && has_key(commandmap, name)
                                  throw string(name) . " is already defined, use ! to overwrite."
                                endif
                            
    3   0.000824   0.000018     let commandlist = s:SplitCommands(commands)
                            
    3              0.000004     if empty(commandlist)
                                  throw "Must provide a list of functions!"
                                endif
                            
    3              0.000012     let commandmap[name] = { 'pattern' : pattern, 'commands' : commandlist }
    3              0.000002   catch
                                echohl ErrorMsg
                                echomsg "AddTabularPipeline: " . v:exception
                                echohl None
                              endtry

FUNCTION  <SNR>23_ChooseCommandMap()
Called 9 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    9              0.000013   let map = s:TabularCommands
    9              0.000011   let cmd = a:commandline
                            
    9              0.000043   if cmd =~# '^<buffer>\s\+'
                                if !exists('b:TabularCommands')
                                  let b:TabularCommands = {}
                                endif
                                let map = b:TabularCommands
                                let cmd = substitute(cmd, '^<buffer>\s\+', '', '')
                              endif
                            
    9              0.000013   return [ map, cmd ]

FUNCTION  deoplete#init#_option()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                              " Note: HTML omni func use search().
    1              0.000027   return { 'auto_complete': v:true, 'auto_complete_delay': 50, 'auto_refresh_delay': 50, 'camel_case': v:false, 'complete_method': 'complete', 'delimiters': ['/'], 'ignore_case': &ignorecase, 'ignore_sources': {}, 'max_list': 500, 'num_processes': s:is_windows ? 1 : 4, 'keyword_patterns': {'_': '[a-zA-Z_]\k*'}, 'omni_patterns': {  'html': ['<', '</', '<[^>]*\s[[:alnum:]-]*'],  'xhtml': ['<', '</', '<[^>]*\s[[:alnum:]-]*'],  'xml': ['<', '</', '<[^>]*\s[[:alnum:]-]*'], }, 'on_insert_enter': v:true, 'on_text_changed_i': v:true, 'profile': v:false, 'min_pattern_length': 2, 'refresh_always': v:true, 'skip_chars': ['(', ')'], 'smart_case': &smartcase, 'sources': {}, 'trigger_key': v:char, 'yarp': v:false, }

FUNCTION  ctrlp#utils#readfile()
Called 1 time
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    1              0.000016 	if filereadable(a:file)
    1              0.000101 		let data = readfile(a:file)
    1              0.000004 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    1              0.000001 		retu data
                            	en
                            	retu []

FUNCTION  <SNR>68_convert()
Called 10 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
   10              0.000020   if has_key(s:lightline.component_expand, a:name)
                                let type = get(s:lightline.component_type, a:name, a:index)
                                let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
                                return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '"]'), 'v:val[0] != []')
                              else
   10              0.000019     return [[[a:name], 0, a:index]]
                              endif

FUNCTION  lightline#link()
Called 41 times
Total time:   0.001644
 Self time:   0.001644

count  total (s)   self (s)
   41              0.000760   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
   41              0.000150   if s:mode == mode
   40              0.000063     return ''
                              endif
    1              0.000001   let s:mode = mode
    1              0.000002   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
                              endif
    1              0.000009   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    3              0.000008   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
   11              0.000023     for [i, t] in map(range(0, l), '[v:val, 0]') + types
    9              0.000007       if i != l
    7              0.000049         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
    7              0.000003       endif
   50              0.000098       for [j, s] in map(range(0, l), '[v:val, 0]') + types
   41              0.000053         if i + 1 == j || t || s && i != l
   19              0.000143           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
   19              0.000008         endif
   41              0.000018       endfor
    9              0.000004     endfor
    2              0.000001   endfor
    1              0.000005   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
    1              0.000001   return ''

FUNCTION  <SNR>68_line()
Called 1 time
Total time:   0.001150
 Self time:   0.000510

count  total (s)   self (s)
    1              0.000002   let _ = a:tabline ? '' : '%{lightline#link()}'
    1              0.000002   if s:lightline.palette == {}
                                call lightline#colorscheme()
                              endif
    1              0.000004   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
    1              0.000004   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
    1              0.000004   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
    1              0.000002   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
    1              0.000004   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
    1   0.000240   0.000016   let [lt, lc, ll] = s:expand(copy(l_))
    1              0.000004   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
    1   0.000228   0.000012   let [rt, rc, rl] = s:expand(copy(r_))
    3              0.000005   for i in range(len(lt))
    2              0.000007     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
    7              0.000009     for j in range(len(lt[i]))
    5              0.000037       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
    5              0.000034       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
    5              0.000011       if j < len(lt[i]) - 1 && s.left !=# ''
    3   0.000155   0.000031         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
    3              0.000002       endif
    5              0.000002     endfor
    2              0.000009     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
    2              0.000012     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
    2              0.000003   endfor
    1              0.000003   let _ .= '%#LightlineMiddle_' . mode . '#%='
    4              0.000006   for i in reverse(range(len(rt)))
    3              0.000014     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
    3              0.000016     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
    3              0.000010     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
    8              0.000011     for j in range(len(rt[i]))
    5              0.000034       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
    5              0.000033       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
    5              0.000010       if j < len(rt[i]) - 1 && s.right !=# ''
    2   0.000092   0.000016         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
    2              0.000001       endif
    5              0.000003     endfor
    3              0.000001   endfor
    1              0.000001   return _

FUNCTION  <SNR>65_Filter()
Called 2 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000005     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
                                endif
                            
    2              0.000004     if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
                                endif
                            
    2              0.000005     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
                                endif
                            
    2              0.000003     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
                                endfor
                            
    2              0.000001     return 1

FUNCTION  provider#pythonx#Detect()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000002   if a:major_ver == 2
                                if exists('g:python_host_prog')
                                  return [g:python_host_prog, '']
                                else
                                  let progs = ['python2', 'python2.7', 'python2.6', 'python']
                                endif
                              else
    1              0.000003     if exists('g:python3_host_prog')
    1              0.000002       return [g:python3_host_prog, '']
                                else
                                  let progs = ['python3', 'python3.7', 'python3.6', 'python3.5', 'python3.4', 'python3.3', 'python']
                                endif
                              endif
                            
                              let errors = []
                            
                              for prog in progs
                                let [result, err] = s:check_interpreter(prog, a:major_ver)
                                if result
                                  return [prog, err]
                                endif
                                " Accumulate errors in case we don't find
                                " any suitable Python interpreter.
                                call add(errors, err)
                              endfor
                            
                              " No suitable Python interpreter found.
                              return ['', 'provider/pythonx: Could not load Python ' . a:major_ver . ":\n" .  join(errors, "\n")]

FUNCTION  plug#begin()
Called 1 time
Total time:   0.000200
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000002   if a:0 > 0
    1              0.000002     let s:plug_home_org = a:1
    1   0.000061   0.000038     let home = s:path(fnamemodify(expand(a:1), ':p'))
    1              0.000002   elseif exists('g:plug_home')
                                let home = s:path(g:plug_home)
                              elseif !empty(&rtp)
                                let home = s:path(split(&rtp, ',')[0]) . '/plugged'
                              else
                                return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
                              endif
    1              0.000004   if fnamemodify(home, ':t') ==# 'plugin' && fnamemodify(home, ':h') ==# s:first_rtp
                                return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
                              endif
                            
    1              0.000002   let g:plug_home = home
    1              0.000001   let g:plugs = {}
    1              0.000001   let g:plugs_order = []
    1              0.000001   let s:triggers = {}
                            
    1   0.000109   0.000008   call s:define_commands()
    1              0.000001   return 1

FUNCTION  <SNR>65_Setup()
Called 1 time
Total time:   0.000412
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000002     if &filetype ==# ""
    1   0.000090   0.000008         call s:InitColor()
    1              0.000000     endif
                            
    1   0.000027   0.000006     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
    1   0.000264   0.000008         call s:IndentLinesEnable()
    1              0.000000     endif
                            
    1   0.000025   0.000005     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif

FUNCTION  60()
Called 9 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    9              0.000019     if !exists("s:menuItems")
    1              0.000001         let s:menuItems = []
    1              0.000000     endif
    9              0.000007     return s:menuItems

FUNCTION  62()
Called 9 times
Total time:   0.000396
 Self time:   0.000353

count  total (s)   self (s)
    9              0.000040     let newMenuItem = copy(self)
                            
    9              0.000017     let newMenuItem.text = a:options['text']
    9              0.000017     let newMenuItem.shortcut = a:options['shortcut']
    9              0.000062     let newMenuItem.children = []
                            
    9              0.000014     let newMenuItem.isActiveCallback = -1
    9              0.000017     if has_key(a:options, 'isActiveCallback')
    1              0.000002         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
    1              0.000001     endif
                            
    9              0.000011     let newMenuItem.callback = -1
    9              0.000015     if has_key(a:options, 'callback')
    9              0.000016         let newMenuItem.callback = a:options['callback']
    9              0.000004     endif
                            
    9              0.000013     if has_key(a:options, 'parent')
                                    call add(a:options['parent'].children, newMenuItem)
                                else
    9   0.000076   0.000033         call add(s:MenuItem.All(), newMenuItem)
    9              0.000004     endif
                            
    9              0.000006     return newMenuItem

FUNCTION  deoplete#util#get_prev_event()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return get(g:deoplete#_context, 'event', '')

FUNCTION  neomake#utils#get_verbosity()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000004     if a:0 && has_key(a:1, 'make_id')
                                    return neomake#GetMakeOptions(a:1.make_id).verbosity
                                endif
    1              0.000005     return get(g:, 'neomake_verbose', 1) + &verbose

FUNCTION  <SNR>2_split_rtp()
Called 2 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
    2              0.000117   return split(&rtp, '\\\@<!,')

FUNCTION  85()
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000009     if filereadable(g:NERDTreeBookmarksFile)
                                    let g:NERDTreeBookmarks = []
                                    let g:NERDTreeInvalidBookmarks = []
                                    let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
                                    let invalidBookmarksFound = 0
                                    for i in bookmarkStrings
                            
                                        "ignore blank lines
                                        if i != ''
                            
                                            let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
                                            let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
                                            let path = fnamemodify(path, ':p')
                            
                                            try
                                                let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
                                                call add(g:NERDTreeBookmarks, bookmark)
                                            catch /^NERDTree.InvalidArgumentsError/
                                                call add(g:NERDTreeInvalidBookmarks, i)
                                                let invalidBookmarksFound += 1
                                            endtry
                                        endif
                                    endfor
                                    if invalidBookmarksFound
                                        call s:Bookmark.Write()
                                        if !a:silent
                                            call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
                                        endif
                                    endif
                                endif

FUNCTION  <SNR>19_mergelists()
Called 1 time
Total time:   0.000914
 Self time:   0.000372

count  total (s)   self (s)
    1   0.000552   0.000018 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    1              0.000306 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    1              0.000039 	let mrufs = s:mrufs + diskmrufs
    1   0.000015   0.000007 	retu s:chop(mrufs)

FUNCTION  71()
Called 45 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
   45              0.000123     return get(s:keyMaps, a:key . a:scope, {})

FUNCTION  77()
Called 45 times
Total time:   0.001557
 Self time:   0.001275

count  total (s)   self (s)
   45              0.000328     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
                            
                                "dont override other mappings unless the 'override' option is given
   45   0.000381   0.000244     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
                                    return
                                end
                            
   45              0.000165     let newKeyMap = copy(self)
   45              0.000067     let newKeyMap.key = opts['key']
   45              0.000079     let newKeyMap.quickhelpText = opts['quickhelpText']
   45              0.000073     let newKeyMap.callback = opts['callback']
   45              0.000065     let newKeyMap.scope = opts['scope']
                            
   45   0.000249   0.000105     call s:KeyMap.Add(newKeyMap)

FUNCTION  78()
Called 45 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
   45              0.000126     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap

FUNCTION  <SNR>2_infer_properties()
Called 20 times
Total time:   0.000949
 Self time:   0.000556

count  total (s)   self (s)
   20              0.000025   let repo = a:repo
   20   0.000160   0.000063   if s:is_local_plug(repo)
                                return { 'dir': s:dirpath(expand(repo)) }
                              else
   20              0.000044     if repo =~ ':'
                                  let uri = repo
                                else
   20              0.000038       if repo !~ '/'
                                    throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
                                  endif
   20              0.000053       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
   20              0.000053       let uri = printf(fmt, repo)
   20              0.000009     endif
   20   0.000407   0.000112     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
                              endif

FUNCTION  <SNR>24_init_var()
Called 43 times
Total time:   0.000384
 Self time:   0.000384

count  total (s)   self (s)
   43              0.000135     if !exists('g:tagbar_' . a:var)
   43              0.000208         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)
   43              0.000019     endif

FUNCTION  remote#host#IsRunning()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000004   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
    2              0.000004   return s:hosts[a:name].channel != 0

FUNCTION  <SNR>42_SID()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002     if !exists("s:sid")
    1              0.000014         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
    1              0.000001     endif
    1              0.000001     return s:sid

FUNCTION  <SNR>65_IndentLinesDisable()
Called 1 time
Total time:   0.000032
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000003         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        for id in w:indentLine_indentLineId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_indentLineId = []
                                    endif
                            
    1   0.000016   0.000008         call s:ResetConcealOption()
    1              0.000001         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  <SNR>56_GetFunctionPrefix()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000003   let res = "function! ".a:name."(...)"
    1              0.000002   if has_key(a:opts, 'range')
                                let res = res." range"
                              endif
    1              0.000001   return res."\n"

FUNCTION  deoplete#util#get_keyword_pattern()
Called 1 time
Total time:   0.000525
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000006   if empty(a:keyword_patterns)
    1   0.000119   0.000011     let patterns = deoplete#custom#_get_filetype_option(   'keyword_patterns', a:filetype, '')
    1              0.000001   else
                                let filetype = has_key(a:keyword_patterns, a:filetype) ? a:filetype : '_'
                                let patterns = get(a:keyword_patterns, filetype, '')
                              endif
    1   0.000019   0.000013   let pattern = join(deoplete#util#convert2list(patterns), '|')
                            
                              " Convert keyword.
    1   0.000358   0.000018   let k_pattern = deoplete#util#vimoption2python( &l:iskeyword . (&l:lisp ? ',-' : ''))
    1              0.000011   return substitute(pattern, '\\k', '\=k_pattern', 'g')

FUNCTION  <SNR>2_trim()
Called 21 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
   21              0.000165   return substitute(a:str, '[\/]\+$', '', '')

FUNCTION  <SNR>19_chop()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000007 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    1              0.000001 	retu a:mrufs

FUNCTION  183()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002     return 'NERD_tree_'

FUNCTION  nerdtree#ui_glue#setupCommands()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000006     command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
    1              0.000004     command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
    1              0.000002     command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
    1              0.000004     command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
    1              0.000003     command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
    1              0.000003     command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')
    1              0.000002     command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
    1              0.000002     command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()

FUNCTION  AutoPairsInit()
Called 1 time
Total time:   0.000483
 Self time:   0.000323

count  total (s)   self (s)
    1              0.000002   let b:autopairs_loaded  = 1
    1              0.000002   if !exists('b:autopairs_enabled')
    1              0.000001     let b:autopairs_enabled = 1
    1              0.000000   end
    1              0.000002   let b:AutoPairsClosedPairs = {}
                            
    1              0.000002   if !exists('b:AutoPairs')
    1              0.000001     let b:AutoPairs = g:AutoPairs
    1              0.000000   end
                            
    1              0.000002   if !exists('b:AutoPairsMoveCharacter')
    1              0.000002     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    1              0.000000   end
                            
                              " buffer level map pairs keys
    7              0.000016   for [open, close] in items(b:AutoPairs)
    6   0.000135   0.000023     call AutoPairsMap(open)
    6              0.000008     if open != close
    3   0.000057   0.000008       call AutoPairsMap(close)
    3              0.000002     end
    6              0.000013     let b:AutoPairsClosedPairs[close] = open
    6              0.000003   endfor
                            
    9              0.000020   for key in split(b:AutoPairsMoveCharacter, '\s*')
    8              0.000031     let escaped_key = substitute(key, "'", "''", 'g')
    8              0.000069     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
    8              0.000006   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    1              0.000001   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    1              0.000006     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsMapCh
    1              0.000006     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    1              0.000000   endif
                            
    1              0.000001   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    1              0.000001     let do_abbrev = ""
    1              0.000002     if v:version == 703 && has("patch489") || v:version > 703
    1              0.000001       let do_abbrev = "<C-]>"
    1              0.000000     endif
    1              0.000007     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutFastWrap != ''
    1              0.000007     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutBackInsert != ''
    1              0.000007     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    1              0.000007     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    1              0.000008     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutJump != ''
    1              0.000007     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    1              0.000007     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    1              0.000000   end
                            

FUNCTION  <SNR>54_LoadRemotePlugins()
Called 1 time
Total time:   0.000793
 Self time:   0.000076

count  total (s)   self (s)
    1   0.000104   0.000009   let g:loaded_remote_plugins = s:GetManifest()
    1              0.000009   if filereadable(g:loaded_remote_plugins)
    1   0.000679   0.000056     execute 'source' fnameescape(g:loaded_remote_plugins)
    1              0.000001   endif

FUNCTION  deoplete#enable()
Called 2 times
Total time:   0.229305
 Self time:   0.000077

count  total (s)   self (s)
    2              0.000007   if has('vim_starting')
    1              0.000001     augroup deoplete
    1              0.000033       autocmd!
    1              0.000004       autocmd VimEnter * call deoplete#enable()
    1              0.000001     augroup END
    1              0.000001     return 1
                              endif
                            
    1   0.228356   0.000010   if deoplete#initialize() && deoplete#is_enabled()
                                return 1
                              endif
    1   0.000891   0.000010   return deoplete#init#_enable_handler()

FUNCTION  <SNR>24_setup_keymaps()
Called 1 time
Total time:   0.000333
 Self time:   0.000159

count  total (s)   self (s)
    1              0.000024     let keymaps = [ ['jump',          '<CR>'], ['preview',       'p'], ['previewwin',    'P'], ['nexttag',       '<C-N>'], ['prevtag',       '<C-P>'], ['showproto',     '<Space>'], ['hidenonpublic', 'v'], ['openfold',      ['+', '<kPlus>', 'zo']], ['closefold',     ['-', '<kMinus>', 'zc']], ['togglefold',    ['o', 'za']], ['openallfolds',  ['*', '<kMultiply>', 'zR']], ['closeallfolds', ['=', 'zM']], ['incrementfolds',  ['zr']], ['decrementfolds',  ['zm']], ['nextfold',      'zj'], ['prevfold',      'zk'], ['togglesort',            's'], ['togglecaseinsensitive', 'i'], ['toggleautoclose',       'c'], ['zoomwin',               'x'], ['close',                 'q'], ['help',                  ['<F1>', '?']], ]
                            
   23              0.000024     for [map, key] in keymaps
   22   0.000248   0.000074         call s:init_var('map_' . map, key)
   22              0.000017         unlet key
   22              0.000011     endfor

FUNCTION  <SNR>68_flatten_twice()
Called 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000002   let ys = []
    7              0.000006   for xs in a:xss
   15              0.000010     for x in xs
   10              0.000010       let ys += x
   10              0.000004     endfor
    5              0.000004   endfor
    2              0.000002   return ys

FUNCTION  ctrlp#utils#mkdir()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000011 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    1              0.000001 	retu a:dir

FUNCTION  nerdtree#runningWindows()
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000013     return has("win16") || has("win32") || has("win64")

FUNCTION  lightline#statusline()
Called 1 time
Total time:   0.001171
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000002   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
                              endif
    1   0.001166   0.000016   return s:line(0, a:inactive)

FUNCTION  deoplete#init#_custom_variables()
Called 1 time
Total time:   0.000165
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000003   if get(g:, 'deoplete#disable_auto_complete', v:false)
                                call deoplete#custom#option('auto_complete', v:false)
                              endif
    1   0.000015   0.000009   call s:check_custom_option( 'g:deoplete#auto_complete_delay', 'auto_complete_delay')
    1   0.000008   0.000004   call s:check_custom_option( 'g:deoplete#auto_refresh_delay', 'auto_refresh_delay')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#camel_case', 'camel_case')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#delimiters', 'delimiters')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#ignore_case', 'ignore_case')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#ignore_sources', 'ignore_sources')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#keyword_patterns', 'keyword_patterns')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#max_list', 'max_list')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#num_processes', 'num_processes')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#auto_complete_start_length', 'min_pattern_length')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#enable_on_insert_enter', 'on_insert_enter')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#enable_profile', 'profile')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#enable_refresh_always', 'refresh_always')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#skip_chars', 'skip_chars')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#sources', 'sources')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#enable_smart_case', 'smart_case')
    1   0.000007   0.000003   call s:check_custom_option( 'g:deoplete#enable_yarp', 'yarp')
                            
                              " Source variables
    1   0.000013   0.000008   call s:check_custom_var('file', 'g:deoplete#file#enable_buffer_path', 'enable_buffer_path')
    1   0.000008   0.000003   call s:check_custom_var('omni', 'g:deoplete#omni#input_patterns', 'input_patterns')
    1   0.000007   0.000003   call s:check_custom_var('omni', 'g:deoplete#omni#functions', 'functions')

FUNCTION  neomake#VimLeave()
Called 1 time
Total time:   0.001047
 Self time:   0.000203

count  total (s)   self (s)
    1   0.001037   0.000193     call neomake#log#debug('Calling VimLeave.')
    1              0.000004     for make_id in keys(s:make_info)
                                    call neomake#CancelMake(make_id)
                                endfor

FUNCTION  <SNR>2_reorg_rtp()
Called 1 time
Total time:   0.000743
 Self time:   0.000405

count  total (s)   self (s)
    1              0.000002   if !empty(s:first_rtp)
    1              0.000007     execute 'set rtp-='.s:first_rtp
    1              0.000005     execute 'set rtp-='.s:last_rtp
    1              0.000001   endif
                            
                              " &rtp is modified from outside
    1              0.000002   if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
                              endif
                            
    1              0.000004   let s:middle = get(s:, 'middle', &rtp)
    1   0.000403   0.000064   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
    1              0.000187   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
    1              0.000068   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
    1              0.000036   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
    1              0.000002   let s:prtp   = &rtp
                            
    1              0.000002   if !empty(s:first_rtp)
    1              0.000009     execute 'set rtp^='.s:first_rtp
    1              0.000008     execute 'set rtp+='.s:last_rtp
    1              0.000001   endif

FUNCTION  deoplete#custom#_init()
Called 1 time
Total time:   0.000044
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000002   let s:custom = {}
    1              0.000002   let s:custom.source = {}
    1              0.000001   let s:custom.source._ = {}
    1   0.000038   0.000010   let s:custom.option = deoplete#init#_option()

FUNCTION  <SNR>52_Highlight_Matching_Pair()
Called 2 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
                              " Remove any previous match.
    2              0.000005   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    2              0.000006   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    2              0.000004   let c_lnum = line('.')
    2              0.000003   let c_col = col('.')
    2              0.000002   let before = 0
                            
    2              0.000004   let text = getline(c_lnum)
    2              0.000020   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    2              0.000003   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
    2              0.000006     let [c_before, c] = matches[1:2]
    2              0.000001   endif
    2              0.000022   let plist = split(&matchpairs, '.\zs[:,]')
    2              0.000005   let i = index(plist, c)
    2              0.000002   if i < 0
                                " not found, in Insert mode try character before the cursor
    2              0.000004     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
    2              0.000001     if i < 0
                                  " not found, nothing to do
    2              0.000001       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  deoplete#util#convert2list()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  deoplete#util#vimoption2python()
Called 1 time
Total time:   0.000340
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000340   0.000016   return '[\w' . s:vimoption2python(a:option) . ']'

FUNCTION  lightline#mode()
Called 40 times
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
   40              0.000297   return get(s:lightline.mode_map, mode(), '')

FUNCTION  ctrlp#utils#opts()
Called 1 time
Total time:   0.000081
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000014   0.000007 	let s:lash = ctrlp#utils#lash()
    1   0.000022   0.000011 	let usrhome = $HOME . s:lash( $HOME )
    1              0.000005 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
    1   0.000026   0.000013 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
    1              0.000003 	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
    1              0.000002 	let s:cache_dir = cadir

FUNCTION  AutoPairsMap()
Called 9 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
                              " | is special key which separate map command from text
    9              0.000011   let key = a:key
    9              0.000010   if key == '|'
                                let key = '<BAR>'
                              end
    9              0.000038   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
    9              0.000075   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
                            

FUNCTION  deoplete#util#get_context_filetype()
Called 1 time
Total time:   0.000312
 Self time:   0.000312

count  total (s)   self (s)
    1              0.000003   if !exists('s:context_filetype')
    1              0.000002     let s:context_filetype = {}
                            
                                " Force context_filetype call.
    1              0.000001     try
    1              0.000242       call context_filetype#get_filetype()
                                catch
                                  " Ignore error
    1              0.000002     endtry
    1              0.000000   endif
                            
    1              0.000010   if empty(s:context_filetype) || s:context_filetype.prev_filetype !=# &filetype || s:context_filetype.line != line('.') || s:context_filetype.bufnr != bufnr('%') || (a:input =~# '\W$' &&     substitute(a:input, '\s\zs\s\+$', '', '') !=#     substitute(s:context_filetype.input, '\s\zs\s\+$', '', '')) || (a:input =~# '\w$' &&     substitute(a:input, '\w\+$', '', '') !=#     substitute(s:context_filetype.input, '\w\+$', '', '')) || a:event ==# 'InsertEnter'
                            
    1              0.000003     let s:context_filetype.line = line('.')
    1              0.000003     let s:context_filetype.bufnr = bufnr('%')
    1              0.000002     let s:context_filetype.input = a:input
    1              0.000002     let s:context_filetype.prev_filetype = &filetype
    1              0.000006     let s:context_filetype.filetype = (exists('*context_filetype#get_filetype') ?   context_filetype#get_filetype() :   (&filetype ==# '' ? 'nothing' : &filetype))
    1              0.000008     let s:context_filetype.filetypes = exists('*context_filetype#get_filetypes') ?   context_filetype#get_filetypes() :   &filetype ==# '' ? ['nothing'] :                     deoplete#util#uniq([&filetype]                          + split(&filetype, '\.'))
    1              0.000005     let s:context_filetype.same_filetypes = exists('*context_filetype#get_same_filetypes') ?   context_filetype#get_same_filetypes() : []
    1              0.000000   endif
    1              0.000003   return [ s:context_filetype.filetype,  s:context_filetype.filetypes, s:context_filetype.same_filetypes]

FUNCTION  neomake#log#debug()
Called 1 time
Total time:   0.000667
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000666   0.000014     call call('s:log', [3] + a:000)

FUNCTION  nerdtree#loadClassFiles()
Called 1 time
Total time:   0.004942
 Self time:   0.001641

count  total (s)   self (s)
    1   0.000805   0.000131     runtime lib/nerdtree/path.vim
    1   0.000296   0.000134     runtime lib/nerdtree/menu_controller.vim
    1   0.000221   0.000116     runtime lib/nerdtree/menu_item.vim
    1   0.000251   0.000114     runtime lib/nerdtree/key_map.vim
    1   0.000375   0.000114     runtime lib/nerdtree/bookmark.vim
    1   0.000393   0.000117     runtime lib/nerdtree/tree_file_node.vim
    1   0.000567   0.000116     runtime lib/nerdtree/tree_dir_node.vim
    1   0.000380   0.000116     runtime lib/nerdtree/opener.vim
    1   0.000389   0.000114     runtime lib/nerdtree/creator.vim
    1   0.000188   0.000115     runtime lib/nerdtree/flag_set.vim
    1   0.000274   0.000113     runtime lib/nerdtree/nerdtree.vim
    1   0.000476   0.000110     runtime lib/nerdtree/ui.vim
    1   0.000153   0.000113     runtime lib/nerdtree/event.vim
    1   0.000169   0.000113     runtime lib/nerdtree/notifier.vim

FUNCTION  remote#define#FunctionOnHost()
Called 1 time
Total time:   0.000052
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000026   0.000012   let group = s:GetNextAutocmdGroup()
    1              0.000022   exe 'autocmd! '.group.' FuncUndefined '.a:name .' call remote#define#FunctionBootstrap("'.a:host.'"' .                                 ', "'.a:method.'"' .                                 ', '.string(a:sync) .                                 ', "'.a:name.'"' .                                 ', '.string(a:opts) .                                 ', "'.group.'"' .                                 ')'

FUNCTION  deoplete#init#_channel()
Called 1 time
Total time:   0.225862
 Self time:   0.000090

count  total (s)   self (s)
    1              0.000003   if !exists('g:deoplete#_serveraddr')
                                return 1
                              endif
                            
    1              0.000003   let python3 = get(g:, 'python3_host_prog', 'python3')
    1              0.000021   if !executable(python3)
                                call deoplete#util#print_error( string(python3) . ' is not executable.')
                                call deoplete#util#print_error( 'You need to set g:python3_host_prog.')
                              endif
                            
    1              0.000001   try
    1   0.000039   0.000003     if deoplete#util#has_yarp()
                                  let g:deoplete#_yarp = yarp#py3('deoplete')
                                  call g:deoplete#_yarp.notify('deoplete_init')
                                else
                                  " rplugin.vim may not be loaded on VimEnter
    1              0.000002       if !exists('g:loaded_remote_plugins')
                                    runtime! plugin/rplugin.vim
                                  endif
                            
    1   0.225758   0.000022       call _deoplete_init()
    1              0.000001     endif
    1              0.000001   catch
                                call deoplete#util#print_error(v:exception)
                                call deoplete#util#print_error(v:throwpoint)
                            
                                if !has('python3')
                                  call deoplete#util#print_error( 'deoplete requires Python3 support("+python3").')
                                endif
                            
                                if deoplete#util#has_yarp()
                                  echomsg string(expand('<sfile>'))
                                  if !exists('*yarp#py3')
                                    call deoplete#util#print_error( 'deoplete requires nvim-yarp plugin.')
                                  endif
                                else
                                  call deoplete#util#print_error( 'deoplete failed to load. ' .'Try the :UpdateRemotePlugins command and restart Neovim. ' .'See also :checkhealth.')
                                endif
                            
                                return 1
                              endtry

FUNCTION  tabular#ElementFormatPattern()
Called 6 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    6              0.000007   return s:formatelempat

FUNCTION  <SNR>45_setup_autocmds()
Called 1 time
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    1              0.000001     augroup neomake
    1              0.000036         au!
    1              0.000003         if !exists('*nvim_buf_add_highlight')
                                        autocmd BufEnter * call neomake#highlights#ShowHighlights()
                                    endif
    1              0.000002         if has('timers')
    1              0.000005             autocmd CursorMoved * call neomake#CursorMovedDelayed()
                                        " Force-redraw display of current error after resizing Vim, which appears
                                        " to clear the previously echoed error.
    1              0.000003             autocmd VimResized * call timer_start(100, function('neomake#EchoCurrentError'))
    1              0.000001         else
                                        autocmd CursorMoved * call neomake#CursorMoved()
                                    endif
    1              0.000003         autocmd VimLeave * call neomake#VimLeave()
    1              0.000002         autocmd ColorScheme * call s:define_highlights()
    1              0.000001     augroup END

FUNCTION  ctrlp#utils#cachedir()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002 	retu s:cache_dir

FUNCTION  deoplete#initialize()
Called 1 time
Total time:   0.228347
 Self time:   0.000204

count  total (s)   self (s)
    1   0.228343   0.000201   return deoplete#init#_initialize()

FUNCTION  remote#host#PluginsForHost()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000010   if !has_key(s:plugins_for_host, a:host)
    2              0.000005     let s:plugins_for_host[a:host] = []
    2              0.000001   end
    3              0.000005   return s:plugins_for_host[a:host]

FUNCTION  lightline#tab#readonly()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003   let winnr = tabpagewinnr(a:n)
    1              0.000003   return gettabwinvar(a:n, winnr, '&readonly') ? 'RO' : ''

FUNCTION  nerdtree#postSourceActions()
Called 1 time
Total time:   0.003623
 Self time:   0.000647

count  total (s)   self (s)
    1   0.000049   0.000006     call g:NERDTreeBookmark.CacheBookmarks(1)
    1   0.002038   0.000009     call nerdtree#ui_glue#createDefaultBindings()
                            
                                "load all nerdtree plugins
    1   0.001535   0.000630     runtime! nerdtree_plugin/**/*.vim

FUNCTION  provider#Poll()
Called 1 time
Total time:   0.224737
 Self time:   0.224737

count  total (s)   self (s)
    1              0.000006   let job = {'rpc': v:true, 'stderr_buffered': v:true}
    1              0.000001   try
    1              0.001627     let channel_id = jobstart(a:argv, job)
    1              0.223057     if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
    1              0.000007       return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in get(job, 'stderr', [])
                                  echomsg row
                                endfor
                              endtry
                              throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)

FUNCTION  provider#python3#Prog()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   return s:prog

FUNCTION  ctrlp#mrufiles#init()
Called 1 time
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    1              0.000004 	if !has('autocmd') | retu | en
    1              0.000002 	let s:locked = 0
    1              0.000001 	aug CtrlPMRUF
    1              0.000087 		au!
    1              0.000011 		au BufAdd,BufEnter,BufLeave,BufWritePost * cal s:record(expand('<abuf>', 1))
    1              0.000004 		au QuickFixCmdPre  *vimgrep* let s:locked = 1
    1              0.000003 		au QuickFixCmdPost *vimgrep* let s:locked = 0
    1              0.000003 		au VimLeavePre * cal s:savetofile(s:mergelists())
    1              0.000001 	aug END

FUNCTION  deoplete#custom#_get_option()
Called 17 times
Total time:   0.000751
 Self time:   0.000446

count  total (s)   self (s)
   17   0.000689   0.000384   let custom = extend(copy(deoplete#custom#_get().option), deoplete#custom#_get_buffer().option)
   17              0.000032   return custom[a:name]

FUNCTION  <SNR>82_log()
Called 1 time
Total time:   0.000652
 Self time:   0.000175

count  total (s)   self (s)
    1              0.000003     let context = a:0 ? a:1 : {}
    1   0.000640   0.000163     let verbosity = neomake#utils#get_verbosity(context)
    1              0.000003     let logfile = get(g:, 'neomake_logfile', '')
                            
    1              0.000004     if !s:is_testing && verbosity < a:level && empty(logfile)
    1              0.000001         return
                                endif
                            
                                if a:0
                                    let msg = printf('[%s.%s:%s:%d] %s', get(context, 'make_id', '-'), get(context, 'id', '-'), get(context, 'bufnr', get(context, 'file_mode', 0) ? '?' : '-'), winnr(), a:msg)
                                else
                                    let msg = a:msg
                                endif
                            
                                " Use Vader's log for messages during tests.
                                " @vimlint(EVL104, 1, l:timediff)
                                if s:is_testing && (verbosity >= a:level || get(g:, 'neomake_test_log_all_messages', 0))
                                    let timediff = s:reltime_lastmsg()
                                    if timediff !=# '     '
                                        let test_msg = '['.s:short_level_to_name[a:level].' '.timediff.']: '.msg
                                    else
                                        let test_msg = '['.s:level_to_name[a:level].']: '.msg
                                    endif
                            
                                    call vader#log(test_msg)
                                    " Only keep context entries that are relevant for / used in the message.
                                    let context = a:0 ? filter(copy(context), "index(['id', 'make_id', 'bufnr'], v:key) != -1") : {}
                                    call add(g:neomake_test_messages, [a:level, a:msg, context])
                                    if index(['.', '!', ')', ']'], a:msg[-1:-1]) == -1
                                        let g:neomake_test_errors += ['Log msg does not end with punctuation: "'.a:msg.'".']
                                    endif
                                elseif verbosity >= a:level
                                    redraw
                                    if a:level ==# 0
                                        echohl ErrorMsg
                                    elseif a:level ==# 1
                                        echohl WarningMsg
                                    endif
                                    if verbosity > 2
                                        echom 'Neomake: '.msg
                                    else
                                        " Use message without context for non-debug msgs.
                                        echom 'Neomake: '.a:msg
                                    endif
                                    if a:level ==# 0 || a:level ==# 1
                                        echohl None
                                    endif
                                endif
                                if !empty(logfile) && type(logfile) ==# type('')
                                    if !exists('s:logfile_writefile_opts')
                                        " Use 'append' with writefile, but only if it is available.  Otherwise, just
                                        " overwrite the file.  'S' is used to disable fsync in Neovim
                                        " (https://github.com/neovim/neovim/pull/6427).
                                        let s:can_append_to_logfile = v:version > 704 || (v:version == 704 && has('patch503'))
                                        if !s:can_append_to_logfile
                                            redraw
                                            echohl WarningMsg
                                            echom 'Neomake: appending to the logfile is not supported in your Vim version.'
                                            echohl NONE
                                        endif
                                        let s:logfile_writefile_opts = s:can_append_to_logfile ? 'aS' : ''
                                    endif
                            
                                    let date = strftime('%H:%M:%S')
                                    if !exists('timediff')
                                        let timediff = s:reltime_lastmsg()
                                    endif
                                    try
                                        call writefile([printf('%s [%s %s] %s', date, s:short_level_to_name[a:level], timediff, msg)], logfile, s:logfile_writefile_opts)
                                    catch
                                        unlet g:neomake_logfile
                                        call neomake#log#error(printf('Error when trying to write to logfile %s: %s.  Unsetting g:neomake_logfile.', logfile, v:exception))
                                    endtry
                                endif
                                " @vimlint(EVL104, 0, l:timediff)

FUNCTION  neomake#get_nearest_error()
Called 1 time
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000006     let buf = bufnr('%')
    1              0.000003     let ln = line('.')
    1              0.000002     let ln_errors = []
                            
    3              0.000008     for maker_type in ['file', 'project']
    2              0.000019         let buf_errors = get(s:current_errors[maker_type], buf, {})
    2              0.000010         let ln_errors += get(buf_errors, ln, [])
    2              0.000002     endfor
                            
    1              0.000003     if empty(ln_errors)
    1              0.000002         return {}
                                endif
                            
                                if len(ln_errors) > 1
                                    let ln_errors = copy(ln_errors)
                                    call sort(ln_errors, function('neomake#utils#sort_by_col'))
                                endif
                                return ln_errors[0]

FUNCTION  <SNR>73_check_custom_option()
Called 17 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
   17              0.000029   if exists(a:old_var)
                                call deoplete#custom#option(a:new_var, eval(a:old_var))
                              endif

FUNCTION  neomake#EchoCurrentError()
Called 1 time
Total time:   0.000147
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000007     if !get(g:, 'neomake_echo_current_error', 1)
                                    return
                                endif
                                " a:1 might be a timer from the VimResized event.
    1              0.000005     let force = a:0 ? a:1 : 0
                            
    1   0.000116   0.000028     let message = neomake#GetCurrentErrorMsg()
    1              0.000003     if empty(message)
    1              0.000004         if exists('s:neomake_last_echoed_error')
                                        echon ''
                                        unlet s:neomake_last_echoed_error
                                    endif
    1              0.000001         return
                                endif
                                if !force && exists('s:neomake_last_echoed_error') && s:neomake_last_echoed_error == message
                                    return
                                endif
                                let s:neomake_last_echoed_error = message
                                call neomake#utils#WideMessage(message)

FUNCTION  <SNR>73_check_custom_var()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000006   if exists(a:old_var)
                                call deoplete#custom#var(a:source_name, a:new_var, eval(a:old_var))
                              endif

FUNCTION  deoplete#init#_enable_handler()
Called 1 time
Total time:   0.000881
 Self time:   0.000177

count  total (s)   self (s)
    1   0.000876   0.000173   call deoplete#handler#_init()
    1              0.000004   let s:is_handler_enabled = 1

FUNCTION  plug#()
Called 20 times
Total time:   0.002043
 Self time:   0.000912

count  total (s)   self (s)
   20              0.000018   if a:0 > 1
                                return s:err('Invalid number of arguments (1..2)')
                              endif
                            
   20              0.000012   try
   20   0.000225   0.000068     let repo = s:trim(a:repo)
   20   0.000112   0.000087     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
   20              0.000203     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
   20   0.001145   0.000196     let spec = extend(s:infer_properties(name, repo), opts)
   20              0.000041     if !has_key(g:plugs, name)
   20              0.000044       call add(g:plugs_order, name)
   20              0.000010     endif
   20              0.000037     let g:plugs[name] = spec
   20              0.000055     let s:loaded[name] = get(s:loaded, name, 0)
   20              0.000011   catch
                                return s:err(v:exception)
                              endtry

FUNCTION  deoplete#custom#_get_buffer()
Called 21 times
Total time:   0.000176
 Self time:   0.000171

count  total (s)   self (s)
   21              0.000061   if !exists('b:custom')
    1   0.000014   0.000009     call deoplete#custom#_init_buffer()
    1              0.000001   endif
                            
   21              0.000023   return b:custom

FUNCTION  lightline#tab#modified()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002   let winnr = tabpagewinnr(a:n)
    1              0.000005   return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'

FUNCTION  <SNR>74_vimoption2python()
Called 1 time
Total time:   0.000324
 Self time:   0.000204

count  total (s)   self (s)
    1              0.000002   let has_dash = 0
    1              0.000002   let patterns = []
    5              0.000018   for pattern in split(a:option, ',')
    4              0.000027     if pattern =~# '\d\+'
    2              0.000033       let pattern = substitute(pattern, '\d\+', '\=nr2char(submatch(0))', 'g')
    2              0.000002     endif
                            
    4              0.000007     if pattern ==# ''
                                  " ,
                                  call add(patterns, ',')
                                elseif pattern ==# '\'
                                  call add(patterns, '\\')
                                elseif pattern ==# '-'
                                  let has_dash = 1
                                else
    4              0.000013       call add(patterns, pattern)
    4              0.000003     endif
    4              0.000003   endfor
                            
                              " Dash must be last.
    1              0.000001   if has_dash
                                call add(patterns, '-')
                              endif
                            
    1   0.000142   0.000022   return join(deoplete#util#uniq(patterns), '')

FUNCTION  <SNR>22_Init()
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
                              " Setup mechanism to restore original completion type upon leaving insert
                              " mode if configured to do so
    1              0.000002   if g:SuperTabRetainCompletionDuration == 'insert'
    1              0.000001     augroup supertab_retain
    1              0.000033       autocmd!
    1              0.000005       autocmd InsertLeave * call s:SetDefaultCompletionType()
    1              0.000001     augroup END
    1              0.000000   endif

FUNCTION  <SNR>2_escrtp()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   return escape(a:path, ' ,')

FUNCTION  deoplete#init#_initialize()
Called 1 time
Total time:   0.227794
 Self time:   0.000353

count  total (s)   self (s)
    1              0.000004   if exists('g:deoplete#_initialized')
                                return 1
                              endif
                            
    1              0.000002   let g:deoplete#_initialized = v:false
                            
    1   0.001133   0.000009   call s:init_internal_variables()
    1   0.000175   0.000011   call deoplete#init#_custom_variables()
                            
    1   0.225874   0.000011   if deoplete#init#_channel()
                                return 1
                              endif
                            
    1   0.000597   0.000307   call deoplete#mapping#_init()

FUNCTION  <SNR>68_expand()
Called 2 times
Total time:   0.000441
 Self time:   0.000258

count  total (s)   self (s)
    2              0.000003   let components = []
    2              0.000002   let expanded = []
    2              0.000002   let indices = []
    2              0.000002   let previndex = -1
    2   0.000248   0.000066   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
   12              0.000016   for [component, expand, index] in xs
   10              0.000012     if previndex != index
    5              0.000009       call add(indices, index)
    5              0.000007       call add(components, [])
    5              0.000007       call add(expanded, [])
    5              0.000002     endif
   10              0.000018     call extend(components[-1], component)
   10              0.000037     call extend(expanded[-1], repeat([expand], len(component)))
   10              0.000012     let previndex = index
   10              0.000005   endfor
    2              0.000007   call add(indices, string(len(a:components)))
    2              0.000003   return [components, expanded, indices]

FUNCTION  <SNR>2_dirpath()
Called 40 times
Total time:   0.000508
 Self time:   0.000508

count  total (s)   self (s)
   40              0.000496     return substitute(a:path, '[/\\]*$', '/', '')

FUNCTION  <SNR>68_term()
Called 8 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    8              0.000026   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''

FUNCTION  deoplete#custom#_get_filetype_option()
Called 4 times
Total time:   0.000441
 Self time:   0.000183

count  total (s)   self (s)
    4   0.000122   0.000067   let buffer_option = deoplete#custom#_get_buffer().option
    4              0.000014   if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
                              endif
                            
    4   0.000250   0.000046   let option = deoplete#custom#_get_option(a:name)
    4              0.000018   let filetype = has_key(option, a:filetype) ? a:filetype : '_'
    4              0.000014   return get(option, filetype, a:default)

FUNCTION  nerdtree#ui_glue#createDefaultBindings()
Called 1 time
Total time:   0.002028
 Self time:   0.000282

count  total (s)   self (s)
    1   0.000028   0.000009     let s = '<SNR>' . s:SID() . '_'
                            
    1   0.000078   0.000010     call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })
    1   0.000054   0.000007     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })
    1   0.000051   0.000007     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })
    1   0.000046   0.000006     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })
    1   0.000043   0.000006     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })
    1   0.000046   0.000006     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })
                            
                            
    1   0.000047   0.000008     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })
    1   0.000043   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })
    1   0.000042   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })
    1   0.000046   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })
                            
    1   0.000042   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })
                            
    1   0.000042   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })
    1   0.000046   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })
    1   0.000044   0.000007     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })
                            
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })
                            
    1   0.000040   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })
    1   0.000044   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })
    1   0.000042   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })
                            
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })
                            
    1   0.000044   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })
                            
    1   0.000042   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': "all", 'callback': "nerdtree#ui_glue#chRootCwd" })
                            
    1   0.000044   0.000007     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })
                            
    1   0.000044   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })
    1   0.000045   0.000006     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })
                            
    1   0.000044   0.000007     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })
    1   0.000042   0.000006     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })
                            
    1   0.000045   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })
                            
    1   0.000042   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })
    1   0.000045   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })
    1   0.000042   0.000006     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })
    1   0.000044   0.000007     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })
                            
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })
    1   0.000045   0.000006     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })
    1   0.000041   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })
    1   0.000042   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })
                            
    1   0.000046   0.000005     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })
                            
    1   0.000043   0.000006     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })

FUNCTION  <SNR>72_convert()
Called 50 times
Total time:   0.000388
 Self time:   0.000388

count  total (s)   self (s)
   50              0.000270   let rgb = map(matchlist(a:rgb, '#\(..\)\(..\)\(..\)')[1:3], '0 + ("0x".v:val)')
   50              0.000061   if len(rgb) == 0
   50              0.000028     return 0
                              endif
                              if rgb[0] == 0xc0 && rgb[1] == 0xc0 && rgb[2] == 0xc0
                                return 7
                              elseif rgb[0] == 0x80 && rgb[1] == 0x80 && rgb[2] == 0x80
                                return 8
                              elseif (rgb[0] == 0x80 || rgb[0] == 0x00) && (rgb[1] == 0x80 || rgb[1] == 0x00) && (rgb[2] == 0x80 || rgb[2] == 0x00)
                                return (rgb[0] / 0x80) + (rgb[1] / 0x80) * 2 + (rgb[1] / 0x80) * 4
                              elseif abs(rgb[0]-rgb[1]) < 3 && abs(rgb[1]-rgb[2]) < 3 && abs(rgb[2]-rgb[0]) < 3
                                return s:black((rgb[0] + rgb[1] + rgb[2]) / 3)
                              else
                                return 16 + ((s:nr(rgb[0]) * 6) + s:nr(rgb[1])) * 6 + s:nr(rgb[2])
                              endif

FUNCTION  lightline#colorscheme()
Called 1 time
Total time:   0.004742
 Self time:   0.000205

count  total (s)   self (s)
    1              0.000001   try
    1   0.002854   0.000148     let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
    1              0.000001   catch
                                call lightline#error('Could not load colorscheme ' . s:lightline.colorscheme . '.')
                                let s:lightline.colorscheme = 'default'
                                let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
                              finally
    1              0.000004     if has('win32') && !has('gui_running') && &t_Co < 256
                                  for u in values(s:lightline.palette)
                                    for v in values(u)
                                      for _  in v
                                        let [_[2], _[3]] = [lightline#colortable#gui2cui(_[0], _[2]), lightline#colortable#gui2cui(_[1], _[3])]
                                      endfor
                                    endfor
                                  endfor
                                endif
    1              0.000002     let s:highlight = {}
    1   0.001277   0.000013     call lightline#highlight('normal')
    1   0.000584   0.000016     call lightline#link()
    1              0.000001     let s:_ = 0
    1              0.000001   endtry

FUNCTION  lightline#update_once()
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000011   if !exists('w:lightline') || w:lightline
                                call lightline#update()
                              endif

FUNCTION  <SNR>24_setup_options()
Called 1 time
Total time:   0.000341
 Self time:   0.000131

count  total (s)   self (s)
    1              0.000003     if !exists('g:tagbar_vertical') || g:tagbar_vertical == 0
    1              0.000002         let previewwin_pos = 'topleft'
    1              0.000001     else
                                    let previewwin_pos = 'rightbelow vertical'
                                endif
    1              0.000018     let options = [ ['autoclose', 0], ['autofocus', 0], ['autopreview', 0], ['autoshowtag', 0], ['case_insensitive', 0], ['compact', 0], ['expand', 0], ['foldlevel', 99], ['hide_nonpublic', 0], ['indent', 2], ['left', 0], ['previewwin_pos', previewwin_pos], ['show_visibility', 1], ['show_linenumbers', 0], ['singleclick', 0], ['sort', 1], ['systemenc', &encoding], ['vertical', 0], ['width', 40], ['zoomwidth', 1], ['silent', 0], ]
                            
   22              0.000022     for [opt, val] in options
   21   0.000273   0.000063         call s:init_var(opt, val)
   21              0.000012     endfor

FUNCTION  <SNR>65_ResetConcealOption()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000003     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    let &l:concealcursor = b:indentLine_original_concealcursor
                                    let &l:conceallevel = b:indentLine_original_conceallevel
                                    let b:indentLine_ConcealOptionSet = 0
                                endif

FUNCTION  <SNR>54_GetManifest()
Called 1 time
Total time:   0.000095
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000076   0.000009   let manifest = s:GetManifestPath()
    1              0.000010   if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                let old_manifest = s:GetOldManifestPath()
                                if filereadable(old_manifest)
                                  call rename(old_manifest, manifest)
                                endif
                              endif
    1              0.000001   return manifest

FUNCTION  <SNR>26_initVariable()
Called 65 times
Total time:   0.000698
 Self time:   0.000698

count  total (s)   self (s)
   65              0.000112     if !exists(a:var)
   60              0.000496         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
   60              0.000033         return 1
                                endif
    5              0.000003     return 0

FUNCTION  remote#host#RegisterPlugin()
Called 2 times
Total time:   0.000659
 Self time:   0.000339

count  total (s)   self (s)
    2   0.000036   0.000018   let plugins = remote#host#PluginsForHost(a:host)
                            
    2              0.000003   for plugin in plugins
                                if plugin.path == a:path
                                  throw 'Plugin "'.a:path.'" is already registered'
                                endif
                              endfor
                            
    2   0.000028   0.000016   if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
                                " For now we won't allow registration of plugins when the host is already
                                " running.
                                throw 'Host "'.a:host.'" is already running'
                              endif
                            
    3              0.000004   for spec in a:specs
    1              0.000001     let type = spec.type
    1              0.000001     let name = spec.name
    1              0.000001     let sync = spec.sync
    1              0.000001     let opts = spec.opts
    1              0.000001     let rpc_method = a:path
    1              0.000001     if type == 'command'
                                  let rpc_method .= ':command:'.name
                                  call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'autocmd'
                                  " Since multiple handlers can be attached to the same autocmd event by a
                                  " single plugin, we need a way to uniquely identify the rpc method to
                                  " call.  The solution is to append the autocmd pattern to the method
                                  " name(This still has a limit: one handler per event/pattern combo, but
                                  " there's no need to allow plugins define multiple handlers in that case)
                                  let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
                                  call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'function'
    1              0.000003       let rpc_method .= ':function:'.name
    1   0.000487   0.000198       call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
    1              0.000001     else
                                  echoerr 'Invalid declaration type: '.type
                                endif
    1              0.000001   endfor
                            
    2              0.000008   call add(plugins, {'path': a:path, 'specs': a:specs})

FUNCTION  deoplete#custom#_get()
Called 18 times
Total time:   0.000199
 Self time:   0.000155

count  total (s)   self (s)
   18              0.000060   if !exists('s:custom')
    1   0.000052   0.000008     call deoplete#custom#_init()
    1              0.000001   endif
                            
   18              0.000020   return s:custom

FUNCTION  neomake#CursorMoved()
Called 1 time
Total time:   0.000161
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000160   0.000013     call neomake#EchoCurrentError()

FUNCTION  deoplete#custom#_init_buffer()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   let b:custom = {}
    1              0.000001   let b:custom.option = {}
    1              0.000001   let b:custom.source_vars = {}

FUNCTION  <SNR>2_rtp()
Called 20 times
Total time:   0.000300
 Self time:   0.000088

count  total (s)   self (s)
   20   0.000296   0.000083     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))

FUNCTION  deoplete#handler#_init()
Called 1 time
Total time:   0.000351
 Self time:   0.000148

count  total (s)   self (s)
    1              0.000002   augroup deoplete
    1              0.000038     autocmd!
    1              0.000010     autocmd InsertLeave * call s:on_insert_leave()
    1              0.000003     autocmd CompleteDone * call s:on_complete_done()
    1              0.000002     autocmd InsertLeave * call s:completion_timer_stop()
    1              0.000001   augroup END
                            
    5              0.000009   for event in ['InsertEnter', 'BufReadPost', 'BufWritePost', 'BufDelete']
    4   0.000073   0.000020     call s:define_on_event(event)
    4              0.000003   endfor
                            
    1   0.000046   0.000007   if deoplete#custom#_get_option('on_text_changed_i')
    1   0.000022   0.000010     call s:define_completion_via_timer('TextChangedI')
    1              0.000000   endif
    1   0.000033   0.000007   if deoplete#custom#_get_option('on_insert_enter')
    1   0.000013   0.000003     call s:define_completion_via_timer('InsertEnter')
    1              0.000000   endif
    1   0.000028   0.000006   if deoplete#custom#_get_option('refresh_always')
    1   0.000013   0.000003     call s:define_completion_via_timer('InsertCharPre')
    1              0.000000   endif
                            
                              " Note: Vim 8 GUI(MacVim and Win32) is broken
                              " dummy timer call is needed before complete()
    1              0.000005   if !has('nvim') && has('gui_running') && (has('gui_macvim') || has('win32') || has('win64'))
                                let s:dummy_timer = timer_start(200, {timer -> 0}, {'repeat': -1})
                              endif
                            
    1   0.000036   0.000005   if deoplete#util#has_yarp()
                                " To fix "RuntimeError: Event loop is closed" issue
                                " Note: Workaround
                                autocmd deoplete VimLeavePre * call s:kill_yarp()
                              endif

FUNCTION  remote#define#notify()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000003   if get(s:busy, a:chan, 0) > 0
                                let pending = get(s:pending_notifications, a:chan, [])
                                call add(pending, deepcopy(a:000))
                                let s:pending_notifications[a:chan] = pending
                              else
    1              0.000015     call call('rpcnotify', [a:chan] + a:000)
    1              0.000001   endif

FUNCTION  deoplete#util#has_yarp()
Called 3 times
Total time:   0.000599
 Self time:   0.000201

count  total (s)   self (s)
    3   0.000598   0.000199   return !has('nvim') || deoplete#custom#_get_option('yarp')

FUNCTION  lightline#highlight()
Called 1 time
Total time:   0.001264
 Self time:   0.001235

count  total (s)   self (s)
    1              0.000004   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
    1              0.000005   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
    1              0.000010   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
    1              0.000010   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    1              0.000004   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
    2              0.000003   for mode in modes
    1              0.000002     let s:highlight[mode] = 1
    1              0.000004     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
    1              0.000004     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
    1              0.000003     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
    1              0.000007     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
    1              0.000007     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
    1              0.000006     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
    3              0.000009     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
   11              0.000025       for [i, t] in map(range(0, l), '[v:val, 0]') + types
    9              0.000011         if i < l || i < 1
    7              0.000046           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
    7   0.000132   0.000106           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
    7              0.000004         endif
   50              0.000105         for [j, s] in map(range(0, l), '[v:val, 0]') + types
   41              0.000057           if i + 1 == j || t || s && i != l
   19              0.000137             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
   19              0.000203             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
   19              0.000009           endif
   41              0.000017         endfor
    9              0.000004       endfor
    2              0.000001     endfor
    1   0.000015   0.000012     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
    1              0.000001   endfor

FUNCTION  <SNR>65_LeadingSpaceDisable()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000003         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
                                    endif
                            
    1              0.000000         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  <SNR>65_InitColor()
Called 1 time
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000001     if !g:indentLine_setColors
                                    return
                                endif
                            
    1              0.000002     let default_term_bg = "NONE"
    1              0.000001     let default_gui_bg  = "NONE"
    1              0.000002     if &background ==# "light"
                                    let default_term_fg = 249
                                    let default_gui_fg = "Grey70"
                                else
    1              0.000001         let default_term_fg = 239
    1              0.000001         let default_gui_fg = "Grey30"
    1              0.000001     endif
                            
    1              0.000001     if g:indentLine_defaultGroup != ""
                                    let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                    let default_term_fg = synIDattr(default_id, "fg", "term") == "" ? default_term_fg :  synIDattr(default_id, "fg", "term")
                                    let default_term_bg = synIDattr(default_id, "bg", "term") == "" ? default_term_bg :  synIDattr(default_id, "bg", "term")
                                    let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                    let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
                                endif
                            
    1              0.000002     if !exists("g:indentLine_color_term")
    1              0.000001         let term_color = default_term_fg
    1              0.000000     else
                                    let term_color = g:indentLine_color_term
                                endif
                            
    1              0.000002     if !exists("g:indentLine_bgcolor_term")
    1              0.000001         let term_bgcolor = default_term_bg
    1              0.000000     else
                                    let term_bgcolor = g:indentLine_bgcolor_term
                                endif
                            
    1              0.000002     if !exists("g:indentLine_color_gui")
    1              0.000001         let gui_color = default_gui_fg
    1              0.000000     else
                                    let gui_color = g:indentLine_color_gui
                                endif
                            
    1              0.000002     if !exists("g:indentLine_bgcolor_gui")
    1              0.000001         let gui_bgcolor = default_gui_bg
    1              0.000000     else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
                                endif
                            
    1              0.000009     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    1              0.000010     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    1              0.000001     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
                                endif

FUNCTION  provider#pythonx#Require()
Called 1 time
Total time:   0.225227
 Self time:   0.000272

count  total (s)   self (s)
    1              0.000003   let ver = (a:host.orig_name ==# 'python') ? 2 : 3
                            
                              " Python host arguments
    1   0.000010   0.000009   let prog = (ver == '2' ?  provider#python#Prog() : provider#python3#Prog())
    1              0.000002   let args = [prog, '-c', 'import sys; sys.path.remove(""); import neovim; neovim.start_host()']
                            
                              " Collect registered Python plugins into args
    1   0.000010   0.000004   let python_plugins = remote#host#PluginsForHost(a:host.name)
    2              0.000003   for plugin in python_plugins
    1              0.000003     call add(args, plugin.path)
    1              0.000001   endfor
                            
    1   0.225189   0.000242   return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE')

FUNCTION  lightline#tab#tabnum()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return a:n

FUNCTION  <SNR>53_LocalBrowse()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
    1              0.000002   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
    1              0.000001    return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  NERDTreeAddMenuItem()
Called 9 times
Total time:   0.000428
 Self time:   0.000032

count  total (s)   self (s)
    9   0.000425   0.000029     call g:NERDTreeMenuItem.Create(a:options)

FUNCTION  <SNR>19_record()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000002 	if s:locked | retu | en
    1              0.000002 	let bufnr = a:bufnr + 0
    1              0.000003 	let bufname = bufname(bufnr)
    1              0.000002 	if bufnr > 0 && !empty(bufname)
                            		cal filter(s:mrbs, 'v:val != bufnr')
                            		cal insert(s:mrbs, bufnr)
                            		cal s:addtomrufs(bufname)
                            	en

FUNCTION  AutoPairsTryInit()
Called 1 time
Total time:   0.000558
 Self time:   0.000075

count  total (s)   self (s)
    1              0.000002   if exists('b:autopairs_loaded')
                                return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    1              0.000001   if g:AutoPairsMapCR
    1              0.000002     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    1              0.000008       let info = maparg('<CR>', 'i', 0, 1)
    1              0.000001       if empty(info)
    1              0.000001         let old_cr = '<CR>'
    1              0.000001         let is_expr = 0
    1              0.000001       else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
    1              0.000000     else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
    1              0.000004     if old_cr !~ 'AutoPairsReturn'
    1              0.000001       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
    1              0.000010       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    1              0.000001     end
    1              0.000000   endif
    1   0.000492   0.000009   call AutoPairsInit()

FUNCTION  deoplete#init#_prev_completion()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008   let g:deoplete#_prev_completion = { 'event': '', 'input': '', 'candidates': [], }

FUNCTION  remote#define#FunctionBootstrap()
Called 1 time
Total time:   0.225674
 Self time:   0.000276

count  total (s)   self (s)
    1   0.225296   0.000015   let channel = remote#host#Require(a:host)
                            
    1              0.000169   exe 'autocmd! '.a:group
    1              0.000055   exe 'augroup! '.a:group
    1              0.000001   if channel
    1   0.000147   0.000030     call remote#define#FunctionOnChannel(channel, a:method, a:sync, a:name, a:opts)
    1              0.000001   else
                                echoerr 'Host "'a:host.'" for "'.a:name.'" function is not available'
                              endif

FUNCTION  plug#end()
Called 1 time
Total time:   0.009467
 Self time:   0.000989

count  total (s)   self (s)
    1              0.000002   if !exists('g:plugs')
                                return s:err('Call plug#begin() first')
                              endif
                            
    1              0.000002   if exists('#PlugLOD')
                                augroup PlugLOD
                                  autocmd!
                                augroup END
                                augroup! PlugLOD
                              endif
    1              0.000003   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
                            
    1              0.000002   if exists('g:did_load_filetypes')
                                filetype off
                              endif
   21              0.000016   for name in g:plugs_order
   20              0.000028     if !has_key(g:plugs, name)
                                  continue
                                endif
   20              0.000025     let plug = g:plugs[name]
   20              0.000064     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
   20              0.000024       let s:loaded[name] = 1
   20              0.000013       continue
                                endif
                            
                                if has_key(plug, 'on')
                                  let s:triggers[name] = { 'map': [], 'cmd': [] }
                                  for cmd in s:to_a(plug.on)
                                    if cmd =~? '^<Plug>.\+'
                                      if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
                                        call s:assoc(lod.map, cmd, name)
                                      endif
                                      call add(s:triggers[name].map, cmd)
                                    elseif cmd =~# '^[A-Z]'
                                      let cmd = substitute(cmd, '!*$', '', '')
                                      if exists(':'.cmd) != 2
                                        call s:assoc(lod.cmd, cmd, name)
                                      endif
                                      call add(s:triggers[name].cmd, cmd)
                                    else
                                      call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')
                                    endif
                                  endfor
                                endif
                            
                                if has_key(plug, 'for')
                                  let types = s:to_a(plug.for)
                                  if !empty(types)
                                    augroup filetypedetect
                                    call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
                                    augroup END
                                  endif
                                  for type in types
                                    call s:assoc(lod.ft, type, name)
                                  endfor
                                endif
                              endfor
                            
    1              0.000006   for [cmd, names] in items(lod.cmd)
                                execute printf( 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))
                              endfor
                            
    1              0.000002   for [map, names] in items(lod.map)
                                for [mode, map_prefix, key_prefix] in [['i', '<C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
                                  execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
                                endfor
                              endfor
                            
    1              0.000002   for [ft, names] in items(lod.ft)
                                augroup PlugLOD
                                  execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))
                                augroup END
                              endfor
                            
    1   0.000757   0.000014   call s:reorg_rtp()
    1   0.007536   0.000606   filetype plugin indent on
    1              0.000004   if has('vim_starting')
    1              0.000004     if has('syntax') && !exists('g:syntax_on')
    1   0.000867   0.000062       syntax enable
    1              0.000001     end
    1              0.000000   else
                                call s:reload_plugins()
                              endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.229305   0.000077  deoplete#enable()
    1   0.228347   0.000204  deoplete#initialize()
    1   0.227794   0.000353  deoplete#init#_initialize()
    1   0.225862   0.000090  deoplete#init#_channel()
    1   0.225674   0.000276  remote#define#FunctionBootstrap()
    1   0.225280   0.000053  remote#host#Require()
    1   0.225227   0.000272  provider#pythonx#Require()
    1   0.224737             provider#Poll()
    1   0.009467   0.000989  plug#end()
    1   0.006811   0.000053  lightline#update()
    1   0.004942   0.001641  nerdtree#loadClassFiles()
    1   0.004742   0.000205  lightline#colorscheme()
    1   0.003623   0.000647  nerdtree#postSourceActions()
   20   0.002043   0.000912  plug#()
    1   0.002028   0.000282  nerdtree#ui_glue#createDefaultBindings()
    1   0.001976   0.001588  lightline#colorscheme#fill()
    1   0.001900   0.001293  deoplete#init#_context()
   45   0.001727   0.000170  NERDTreeAddKeyMap()
   41   0.001644             lightline#link()
    7   0.001572   0.000493  <SNR>23_SplitCommands()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1              0.224737  provider#Poll()
   41              0.001644  lightline#link()
    1   0.004942   0.001641  nerdtree#loadClassFiles()
    1   0.001976   0.001588  lightline#colorscheme#fill()
    1   0.001900   0.001293  deoplete#init#_context()
   45   0.001557   0.001275  77()
    1   0.001264   0.001235  lightline#highlight()
    1   0.009467   0.000989  plug#end()
   20   0.002043   0.000912  plug#()
   65              0.000698  <SNR>26_initVariable()
    1   0.000844   0.000669  lightline#init()
    1   0.003623   0.000647  nerdtree#postSourceActions()
   20   0.000949   0.000556  <SNR>2_infer_properties()
    1   0.001150   0.000510  <SNR>68_line()
   40              0.000508  <SNR>2_dirpath()
    7   0.001572   0.000493  <SNR>23_SplitCommands()
   17   0.000751   0.000446  deoplete#custom#_get_option()
    1   0.000452   0.000436  ctrlp#utils#writecache()
    1   0.000743   0.000405  <SNR>2_reorg_rtp()
   50              0.000388  <SNR>72_convert()

